<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JOE&#39;S BLOG</title>
  <icon>https://www.gravatar.com/avatar/4d7b6eb90ff6162c577a0163e274b344</icon>
  <subtitle>好记性不如烂键盘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joewt.com/"/>
  <updated>2018-12-07T15:41:01.365Z</updated>
  <id>https://joewt.com/</id>
  
  <author>
    <name>JOE</name>
    <email>joewttx@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP编译选项和常见错误</title>
    <link href="https://joewt.com/2018/12/07/php-compile/"/>
    <id>https://joewt.com/2018/12/07/php-compile/</id>
    <published>2018-12-07T13:06:48.000Z</published>
    <updated>2018-12-07T15:41:01.365Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录了PHP各个版本的源码编译选项以及编译过程中出现的错误和解决办法</p></blockquote><p>以下为每个版本的PHP的编译错误，以及可能会出现的问题  </p><a id="more"></a><h2 id="PHP7-3-0"><a href="#PHP7-3-0" class="headerlink" title="PHP7.3.0"></a>PHP7.3.0</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/Users/joe/php-7.3.0 \</span><br><span class="line">--with-config-file-path=/Users/joe/php-7.3.0 \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--with-fpm-user=www \</span><br><span class="line">--with-fpm-group=www \</span><br><span class="line">--enable-mysqlnd \</span><br><span class="line">--with-mysqli=mysqlnd \</span><br><span class="line">--with-pdo-mysql=mysqlnd \</span><br><span class="line">--enable-mysqlnd-compression-support \</span><br><span class="line">--with-iconv-dir \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-libxml-dir \</span><br><span class="line">--enable-xml \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--with-curl \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-intl \</span><br><span class="line">--with-mcrypt \</span><br><span class="line">--with-libmbfl \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--with-gd \</span><br><span class="line">--enable-gd-native-ttf \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-mhash \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--enable-zip \</span><br><span class="line">--enable-soap \</span><br><span class="line">--with-gettext \</span><br><span class="line">--disable-fileinfo \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--with-pear \</span><br><span class="line">--enable-maintainer-zts \</span><br><span class="line">--with-ldap=shared \</span><br><span class="line">--without-gdbm \</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configure: error: Cannot locate header file libintl.h</span><br><span class="line"></span><br><span class="line">在mac上运行</span><br><span class="line">brew install gettext</span><br><span class="line">之后编辑configure文件找到(大概在3.8w行左右)$PHP_GETTEXT /usr/local /usr</span><br><span class="line">并在后面添加/usr/local/opt/gettext</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">configure: error: Unable to detect ICU prefix or no failed. Please verify ICU install prefix and make sure icu-config works.</span><br><span class="line">在mac上运行</span><br><span class="line">brew install icu4c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/icu4c/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/icu4c/include&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录了PHP各个版本的源码编译选项以及编译过程中出现的错误和解决办法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下为每个版本的PHP的编译错误，以及可能会出现的问题  &lt;/p&gt;
    
    </summary>
    
      <category term="PHP扩展开发" scheme="https://joewt.com/categories/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>积极养鱼</title>
    <link href="https://joewt.com/2018/11/12/yu/"/>
    <id>https://joewt.com/2018/11/12/yu/</id>
    <published>2018-11-12T10:58:27.107Z</published>
    <updated>2018-11-12T11:00:31.354Z</updated>
    
    <content type="html"><![CDATA[<p>养鱼 养鱼 养鱼 养一条傻傻的二鱼</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;养鱼 养鱼 养鱼 养一条傻傻的二鱼&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://joewt.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://joewt.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>C语言中几个基本概念</title>
    <link href="https://joewt.com/2018/10/24/c-advanced/"/>
    <id>https://joewt.com/2018/10/24/c-advanced/</id>
    <published>2018-10-24T04:08:43.000Z</published>
    <updated>2018-11-14T03:30:50.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分清以下几个概念"><a href="#分清以下几个概念" class="headerlink" title="分清以下几个概念"></a>分清以下几个概念</h2><ol><li>指针数组 数组指针</li><li>指针函数 函数指针</li><li>指针常量 常量指针</li><li>typedef</li><li>#define</li><li>可变参数</li><li>字符串常量</li></ol><blockquote><p>内容主要来自《C专家编程》《C陷阱和缺陷》《C和指针》 </p></blockquote><a id="more"></a><h2 id="常量和指针"><a href="#常量和指针" class="headerlink" title="常量和指针"></a>常量和指针</h2><p>首先看比较容易理解的常量指针和指针常量  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int const a;</span><br><span class="line">const int a;</span><br></pre></td></tr></table></figure><p>首先看如上声明,const 在前还是在后表示的意思都是一样的，表示a是一个常量 类型为int，a的值初始化后就不能修改了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int const *pi;</span><br><span class="line">const int *pi;</span><br></pre></td></tr></table></figure><p>常量指针有2种表示方法意思都是一样的, 以上2个都表示常量指针,<br>可以修改指针的值但不能修改指针指向的值,这个在函数库的原型里可以见到比如printf和scanf,<br>后面的…表示可变参数后面会讲到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int printf(const char * __restrict, ...) </span><br><span class="line">int scanf(const char * __restrict, ...)</span><br></pre></td></tr></table></figure></p><p>再来看看指针常量的声明,一般只有一种表示方法<br>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * const pi;</span><br></pre></td></tr></table></figure></p><p>表示pi 这个指针是常量，pi的值不能修改,但是pi指向的值是可以修改的  </p><p>如果既不想改变指针的值也不想改变指针指向的值，可以声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int const * const pi;</span><br></pre></td></tr></table></figure></p><h2 id="指针和数组的爱恨情仇"><a href="#指针和数组的爱恨情仇" class="headerlink" title="指针和数组的爱恨情仇"></a>指针和数组的爱恨情仇</h2><p>指针和数组他们之间没有任何关系  </p><ul><li>指针就是指针，指针变量在32位系统下，永远占4个byte，其值为某一个内存的地址。指针可以指向任何地方，但是不是任何地方你都能通过这个指针变量访问到。</li><li>数组就是数组，其大小与元素的类型和个数有关。定义数组时必须指定其元素的类型和个数。数组可以存放任何类型的数据，但不能存函数。  </li></ul><h3 id="如何分辨数组指针和指针数组"><a href="#如何分辨数组指针和指针数组" class="headerlink" title="如何分辨数组指针和指针数组"></a>如何分辨数组指针和指针数组</h3><ul><li>指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“存储指针的数组”的简称</li><li>数组指针：首先它是一个指针，他指向一个数组。在32位系统下永远是占4个字节，至于它指向的数组占多少个字节，不知道。它是“指向数组的指针”的简称<!--More-->考虑下，下面2个哪个是指针数组，哪个是数组指针<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A). int *p1[10];</span><br><span class="line">B). int (*p2)[10];</span><br></pre></td></tr></table></figure></li></ul><p>根据右左法则，先找到未定义标识符，p1右边是[]因为[]比<code>*</code>的优先级高，p1先与[]结合，所以它是一个数组。<code>int *</code>修饰的是数组的内容。<br>再看p2，因为”()”比”[]”优先级高，所以<code>(*p2)</code>表示这是一个指针，指针变量名为p2,int修饰的数组内容，即数组的每个元素。数组在这里没有名字，是匿名数组。所以p2是一个数组指针，指向一个包含10个int类型数据的数组。</p><h3 id="多维数组和多级指针"><a href="#多维数组和多级指针" class="headerlink" title="多维数组和多级指针"></a>多维数组和多级指针</h3><p>考虑下面一个例子<br>&amp;p[4][2]-&amp;a[4][2]的值为多少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5][5];</span><br><span class="line">    int (*p)[4];</span><br><span class="line">    p = a;</span><br><span class="line">    printf(&quot;a_ptr=%#p,p_ptr=%#p\n&quot;,&amp;a[4][2],&amp;p[4][2]);</span><br><span class="line">    printf(&quot;%p,%d\n&quot;,&amp;p[4][2]-&amp;a[4][2],&amp;p[4][2]-&amp;a[4][2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="http://img.hnitoj.cn/7AB30FB4610D9CD6E007B4CE48D73270.png" alt=""><br>文字解析，不如看图来的好<br><img src="http://img.hnitoj.cn/D28B21B0082E0FBB411BBCEFA515B45E.png" alt="">  </p><h3 id="数组参数与指针参数"><a href="#数组参数与指针参数" class="headerlink" title="数组参数与指针参数"></a>数组参数与指针参数</h3><h4 id="一维数组参数"><a href="#一维数组参数" class="headerlink" title="一维数组参数"></a>一维数组参数</h4><h5 id="能否向函数传递一个数组？"><a href="#能否向函数传递一个数组？" class="headerlink" title="能否向函数传递一个数组？"></a>能否向函数传递一个数组？</h5><p>考虑以下程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun(char a[10])</span><br><span class="line">&#123;</span><br><span class="line">    char c = a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    fun(b[10]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的调用，fun(b[10]);将b[10]这个数组传递到fun函数。这样显然不对。<br>b[0]代表是数组的一个元素，那么b[10]也是，只是这里越界了。但在编译阶段，编译器并不会真正计算b[10]的地址并取值，所在在编译阶段不会报错，但是编译器会给出警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在我的Mac上编译出现这个</span><br><span class="line">warning: incompatible integer to pointer conversion passing &apos;char&apos; to parameter of type &apos;char *&apos;; take the address with &amp; [-Wint-conversion]  </span><br><span class="line">warning: array index 10 is past the end of the array (which contains 10 elements) [-Warray-bounds]</span><br><span class="line">//在作者的电脑上给出的警告是这样的  </span><br><span class="line">warning C4047: &apos;function&apos; : &apos;char *&apos; differs in levels of indirection from &apos;char &apos;</span><br><span class="line">warning C4024: &apos;fun&apos; : different types for formal and actual parameter 1</span><br></pre></td></tr></table></figure></p><p>虽然编译没问题，但运行肯定有问题。<br>具体分析如下:  </p><ol><li>b[10]并不存在，在编译的时候由于没有去实际地址取值，所以没有出错，但是在运行时，将计算b[10]的实际地址，并且取值。这时发生越界错误</li><li>编译器的警告已经告诉我们编译器需要的是一个char*类型的参数，而传递过去的是一个char类型的参数，这时候fun函数会将传入的char类型的数据当地址处理，同样会发生错误</li><li>对第二个错误的理解，fun函数明明传递的是一个数组啊，编译器怎么会说是char*类型呢？  </li></ol><p>将fun(b[10])改为fun(b)，编译后不会出现警告了。</p><h5 id="无法向函数传递一个数组"><a href="#无法向函数传递一个数组" class="headerlink" title="无法向函数传递一个数组"></a>无法向函数传递一个数组</h5><p>可以简单验证下，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun(char a[10])</span><br><span class="line">&#123;</span><br><span class="line">    int i=sizeof(a);</span><br><span class="line">    printf(&quot;i:%d\n&quot;,i);</span><br><span class="line">    char c=a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    int j = sizeof(b);</span><br><span class="line">    printf(&quot;j:%d\n&quot;,j);</span><br><span class="line">    fun(b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://img.hnitoj.cn/FC89DCB14091449DBE1B2B8A345E07EA.png" alt=""><br>如果数组b真正传递到函数内部，那么i的值应该为10，但我测试后发现i的值为8(作者测的值为4)。造成这样的原因是这样一条规则:   </p><ul><li>C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针</li></ul><blockquote><p>这么做是有原因的。在 C 语言中，所有非数组形式的数据实参均以传值形式（对实参<br>做一份拷贝并传递给被调用的函数，函数不能修改作为实参的实际变量的值，而只能修改<br>传递给它的那份拷贝）调用。然而，如果要拷贝整个数组，无论在空间上还是在时间上，<br>其开销都是非常大的。更重要的是，在绝大部分情况下，你其实并不需要整个数组的拷贝，<br>你只想告诉函数在那一刻对哪个特定的数组感兴趣。这样的话，为了节省时间和空间，提<br>高程序运行的效率，于是就有了上述的规则。同样的，函数的返回值也不能是一个数组，<br>而只能是指针。这里要明确的一个概念就是：函数本身是没有类型的，只有函数的返回值<br>才有类型。很多书都把这点弄错了，甚至出现“XXX 类型的函数”这种说法。简直是荒唐<br>至极！</p></blockquote><p>所以我们写代码的时候，可以写成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void fun(char a[])</span><br><span class="line">&#123;</span><br><span class="line">    char c=a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    fun(b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fun(char *p)</span><br><span class="line">&#123;</span><br><span class="line">    char c=p[3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2><p>指针函数首先是一个函数，返回的类型是一个指针形式的<br>函数指针是一个指针，指向的是一个函数  </p><p>首先看下函数声明<br>任何C变量的声明都由两部分组成:</p><ul><li>类型以及一组类似表达式的声明符(declarator)。声明符从表面上看与表达式有些类似，对它求值应该返回一个声明中给定类型的结果</li></ul><p>最简单的声明符就是单个变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f, g;</span><br></pre></td></tr></table></figure></p><p>这个声明的含义:</p><ul><li>当对其求值时，表达式f和g的类型为浮点数类型(float)。</li></ul><p>因为声明符与表达式的相似，所以我们也可以在声明符中任意使用括号:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float ((f));</span><br></pre></td></tr></table></figure></p><p>这个声明的含义是:</p><ul><li>当对其求值时，((f))的类型为浮点型，由此可以推知，f也是浮点类型。</li></ul><p>同样的逻辑也适合用于函数和指针类型的声明，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float ff();</span><br></pre></td></tr></table></figure></p><p>这个声明的含义是:</p><ul><li>表达式ff()求值结果是一个浮点数，也就是说，ff是一个返回值为浮点数类型的函数。</li></ul><p>类似的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float *pf;</span><br></pre></td></tr></table></figure></p><ul><li>这个声明的含义是*pf是一个浮点数，也就是说，pf是一个指向浮点数的指针</li></ul><p>以上形式组合起来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float *g(), (*h)();</span><br></pre></td></tr></table></figure></p><ul><li>表示<code>*g()</code>与<code>(*h)()</code>是浮点表达式。因为()结合优先级高于<em>,`</em>g()`也就是*(g()): g是一个函数，该函数的返回值类型为指向浮点数的指针。同理，h是一个函数指针，h所指向函数的返回值为浮点类型。</li></ul><p>有了以上的说明 函数指针 指针函数也就能明白了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *func(int a, int b);</span><br></pre></td></tr></table></figure><p>表示 func是一个函数 其返回值是int *，所以是指针函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*func)(int a, intb);</span><br></pre></td></tr></table></figure><p>首先 func是一个指针 该指针指向一个函数 返回值是int 类型的，在使用的时候需要把一个函数的地址传给他  </p><p>函数指针的使用经常用于回调函数<br>下面就是一个简单的回调函数使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef int (*callback)(char *p);</span><br><span class="line"></span><br><span class="line">int fun1(char *str)&#123;</span><br><span class="line">    printf(&quot;回调 func1: %s\n&quot;,str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fun2(char *str)&#123;</span><br><span class="line">    printf(&quot;回调 func2: %s\n&quot;,str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int t1(callback p_callback, char *str)&#123;</span><br><span class="line">    p_callback(str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char *str = &quot;hi!&quot;;</span><br><span class="line">    t1(fun1, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="typedef的使用"><a href="#typedef的使用" class="headerlink" title="typedef的使用"></a>typedef的使用</h2><p>typedef 常常用于为类型创建一个新的别名<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef char Line[12];</span><br><span class="line">Line text; // 这行的意思就是 char text[12];</span><br></pre></td></tr></table></figure></p><p>使用typedef 主要是简化代码比如上面的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*callback)(char *p)</span><br></pre></td></tr></table></figure></p><p>使用的时候就可是使用如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback call;</span><br></pre></td></tr></table></figure></p><p>typedef的另外一个用处就是定义机器无关的类型，促进跨平台</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>宏只是简单的字符串替换<br>通过使用 -E 参数查看宏展开后的结果  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure><p>比如如下代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MALLOC(size,type) ((type*)malloc(sizeof(type) * (size)))</span><br><span class="line">#define PRINT(FORMAT,VALUE)\</span><br><span class="line">printf(&quot;The value of&quot;#VALUE&quot;is &quot; FORMAT&quot;\n&quot;,VALUE)</span><br><span class="line">#define M 10</span><br><span class="line">#define SQ(x) ((x)*(x))</span><br><span class="line">#define DEBUG printf(&quot;FIle %s line %d :&quot;\</span><br><span class="line">                    &quot;x = %d, y = %d \n&quot;,\</span><br><span class="line">                    __FILE__, __LINE__,10,20)</span><br><span class="line">#define MAX(a,b) ((a)&gt;(b)?(a):(b))</span><br><span class="line">#define ERROR_LOG(module)   fprintf(stderr,&quot;error: &quot;module&quot;\n&quot;)</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = M;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);</span><br><span class="line">    DEBUG;</span><br><span class="line">    int b = 121/SQ(2);</span><br><span class="line">    printf(&quot;%d\n&quot;,b);</span><br><span class="line">    int *p = MALLOC(10,int);</span><br><span class="line">    int a = 0;</span><br><span class="line">    int c = 1;</span><br><span class="line">    int d = MAX(a++,c++);</span><br><span class="line">    int x = 1;</span><br><span class="line">    PRINT(&quot;%d&quot;,x+20);</span><br><span class="line">    ERROR_LOG(&quot;add&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么展开后的结果如下</span><br><span class="line">省略一大段</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 10;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);</span><br><span class="line">    printf(&quot;FIle %s line %d :&quot; &quot;x = %d, y = %d \n&quot;, &quot;main.c&quot;, 17,10,20);</span><br><span class="line">    int b = 121/((2)*(2));</span><br><span class="line">    printf(&quot;%d\n&quot;,b);</span><br><span class="line">    int *p = ((int*)malloc(sizeof(int) * (10)));</span><br><span class="line">    int a = 0;</span><br><span class="line">    int c = 1;</span><br><span class="line">    int d = ((a++)&gt;(c++)?(a++):(c++));</span><br><span class="line">    int x = 1;</span><br><span class="line">    printf(&quot;The value of&quot;&quot;x+20&quot;&quot;is &quot; &quot;%d&quot;&quot;\n&quot;,x+20);</span><br><span class="line">    fprintf(__stderrp,&quot;error: &quot;&quot;add&quot;&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">int fun(int n, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list var_arg;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    va_start(var_arg, n); </span><br><span class="line">    for(i = 0; i &lt; n; i+=1)</span><br><span class="line">    &#123;   </span><br><span class="line">        sum += va_arg(var_arg, int);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    va_end(var_arg);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n = 5;</span><br><span class="line">    int sum = fun(n,1,2,3,4,5);</span><br><span class="line">    printf(&quot;%d\n&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串常量用于表达式中，为指针常量<br>对于如下的程序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char *str = &quot;hello&quot;+1;</span><br><span class="line">    printf(&quot;%c\n&quot;,*str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是 e<br>字符串常量实际上是个指针,加1的话结果是个指针，指向第二个字符,所以结果是e</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分清以下几个概念&quot;&gt;&lt;a href=&quot;#分清以下几个概念&quot; class=&quot;headerlink&quot; title=&quot;分清以下几个概念&quot;&gt;&lt;/a&gt;分清以下几个概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;指针数组 数组指针&lt;/li&gt;
&lt;li&gt;指针函数 函数指针&lt;/li&gt;
&lt;li&gt;指针常量 常量指针&lt;/li&gt;
&lt;li&gt;typedef&lt;/li&gt;
&lt;li&gt;#define&lt;/li&gt;
&lt;li&gt;可变参数&lt;/li&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;内容主要来自《C专家编程》《C陷阱和缺陷》《C和指针》 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://joewt.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>PHP的基本变量</title>
    <link href="https://joewt.com/2018/09/11/php-extension-2.1/"/>
    <id>https://joewt.com/2018/09/11/php-extension-2.1/</id>
    <published>2018-09-10T16:08:43.000Z</published>
    <updated>2018-10-17T15:19:13.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zval"><a href="#zval" class="headerlink" title="zval"></a>zval</h2><p>PHP在内核中是通过zval这个结构体来存储变量的，PHP的变量是弱类型的，首先来看看PHP5的zval设计   </p><h3 id="PHP5的zval"><a href="#PHP5的zval" class="headerlink" title="PHP5的zval"></a>PHP5的zval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 考虑到结构体对齐 大小为24字节</span><br><span class="line">*/</span><br><span class="line">struct _zval_struct&#123;</span><br><span class="line">/*变量信息*/</span><br><span class="line">zvalue_value value;     // 16字节</span><br><span class="line">zend_uint refcount__gc;  // 4字节</span><br><span class="line">zend_uchar type;         /* 类型   1字节*/</span><br><span class="line">zend_uchar is_ref__gc;   // 1字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 以下说的大小是在 x86-64下</span><br><span class="line"> 在内存对齐的情况下_zvalue_value的大小为16字节</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">long lval;    // 8字节</span><br><span class="line">double dval;  // 8字节</span><br><span class="line">struct&#123;</span><br><span class="line">char *val;</span><br><span class="line">int len;</span><br><span class="line">&#125; str;        // 12字节</span><br><span class="line">HashTable *ht;       /*HashTable 数组  8字节*/</span><br><span class="line">zend_object_value obj;   // 12字节</span><br><span class="line">zend_ast *ast;     // 8字节</span><br><span class="line">&#125;zvalue_value;</span><br></pre></td></tr></table></figure><p>PHP5的zval核心由一个zvalue_value类型的联合体和zend_uchar类型的type组成，<br><code>refcount__gc</code>是用来进行垃圾回收的，<code>is_ref__gc</code> 表示是否是引用类型<br>PHP5.3 为了解决循环引用实际申请的结构体为<code>_zval_gc_info</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">该大小为 32字节</span><br><span class="line">*/</span><br><span class="line">typedef struct _zval_gc_info &#123;</span><br><span class="line">zval z;</span><br><span class="line">union &#123;</span><br><span class="line">gc_root_buffer     *buffered;</span><br><span class="line">struct _zval_gc_info *next;</span><br><span class="line">&#125; u;    // 4字节</span><br><span class="line">&#125;zval_gc_info;</span><br></pre></td></tr></table></figure><p>zval_gc_info 在内存池中分配，内存池会为每个zval_gc_info额外申请一个大小为16字节的zend_mm_block结构体，用来存放内存相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_mm_block_info &#123;</span><br><span class="line">size_t _size;</span><br><span class="line">size_t _prev;</span><br><span class="line">&#125; zend_mm_block_info;</span><br><span class="line"></span><br><span class="line">typedef struct _zend_mm_block&#123;</span><br><span class="line">zend_mm_block_info info;</span><br><span class="line">&#125; zend_mm_block;</span><br></pre></td></tr></table></figure><p>最终一个变量在PHP5中占48字节  </p><h3 id="PHP7的zval"><a href="#PHP7的zval" class="headerlink" title="PHP7的zval"></a>PHP7的zval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef union _zend_value &#123;</span><br><span class="line">zend_long         lval;             /* 整形 */</span><br><span class="line">double            dval;             /* 浮点型 */</span><br><span class="line">zend_refcounted  *counted;          /* 引用计数 */</span><br><span class="line">zend_string      *str;              /* 字符串类型 */</span><br><span class="line">zend_array       *arr;              /* 数组类型 */</span><br><span class="line">zend_object      *obj;              /* 对象类型 */</span><br><span class="line">zend_resource    *res;              /* 资源类型 *</span><br><span class="line">zend_reference   *ref;              /* 引用类型 */</span><br><span class="line">zend_ast_ref     *ast;              /* 抽象语法树 */</span><br><span class="line">zval             *zv;               /* zval类型 */</span><br><span class="line">void             *ptr;              /* 指针类型 */</span><br><span class="line">zend_class_entry *ce;               /* class类型 */</span><br><span class="line">zend_function    *func;             /* function类型 */</span><br><span class="line">struct &#123;</span><br><span class="line">uint32_t w1;</span><br><span class="line">uint32_t w2;</span><br><span class="line">&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">zend_value        value;/* value */</span><br><span class="line">union &#123;</span><br><span class="line">struct &#123;</span><br><span class="line">ZEND_ENDIAN_LOHI_4(</span><br><span class="line">zend_uchar    type,/* zval类型 */</span><br><span class="line">zend_uchar    type_flags,</span><br><span class="line">zend_uchar    const_flags,</span><br><span class="line">zend_uchar    reserved)    /* call info for EX(This) */</span><br><span class="line">&#125; v;</span><br><span class="line">uint32_t type_info;</span><br><span class="line">&#125; u1;</span><br><span class="line">union &#123;</span><br><span class="line">uint32_t     next;                 /* hash collision chain */</span><br><span class="line">uint32_t     cache_slot;           /* literal cache slot */</span><br><span class="line">uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">uint32_t     access_flags;         /* class constant access flags */</span><br><span class="line">uint32_t     property_guard;       /* single property guard */</span><br><span class="line">uint32_t     extra;                /* not further specified */</span><br><span class="line">&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到PHP7中zval定义的好像比较复杂但都是联合体，所以实际占用大小只有16字节<br>接下类看看各个字段的含义。  </p><p>u1字段的含义  </p><ol><li>type: 记录变量类型  </li><li>type_flag: 对应变量类型的特有的标记  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IS_TYPE_CONSTANT        /* 是常量类型 */</span><br><span class="line">IS_TYPE_IMMUTABLE       /* 不可变的类型 */</span><br><span class="line">IS_TYPE_REFCOUNTED      /* 需要引用计数的类型 */</span><br><span class="line">IS_TYPE_COLLECTABLE     /* 可能包含循环引用的类型(IS_ARRAY, IS_OBJECT) */</span><br><span class="line">IS_TYPE_COPYABLE        /* 可被复制的类型 */</span><br></pre></td></tr></table></figure><ol><li>const_flag: 常量类型的标记</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define IS_CONSTANT_UNQUALIFIED    0x010</span><br><span class="line">#define IS_CONSTANT_VISITED_MARK   0x020</span><br><span class="line">#define IS_CONSTANT_CLASS          0x080</span><br><span class="line">#define IS_CONSTANT_IN_NAMESPACE   0x100</span><br></pre></td></tr></table></figure><ol><li>reserved: 保留字段</li></ol><p>u2字段的含义，主要是辅助字段  </p><ol><li>next: 用于哈希冲突中记录下一个元素的位置</li><li>cache_slot: 运行时缓存</li><li>lineno:  文件执行的行号，应用在AST节点上</li><li>num_args: 函数调用时传入参数的个数</li><li>fe_pos:  遍历数组时的当前位置</li><li>fe_iter_idx: 与fe_pos类似，针对对象使用</li><li>access_flags: 对象类的访问标志, public protected private</li><li>property_guard: 防止类中魔术方法的循环调用</li></ol><h2 id="PHP7-变量类型"><a href="#PHP7-变量类型" class="headerlink" title="PHP7 变量类型"></a>PHP7 变量类型</h2><p>PHP7 通过定义20种宏，来u1.v.type字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* regular data types */</span><br><span class="line">#define IS_UNDEF                    0</span><br><span class="line">#define IS_NULL                     1</span><br><span class="line">#define IS_FALSE                    2</span><br><span class="line">#define IS_TRUE                     3</span><br><span class="line">#define IS_LONG                     4</span><br><span class="line">#define IS_DOUBLE                   5</span><br><span class="line">#define IS_STRING                   6</span><br><span class="line">#define IS_ARRAY                    7</span><br><span class="line">#define IS_OBJECT                   8</span><br><span class="line">#define IS_RESOURCE                 9</span><br><span class="line">#define IS_REFERENCE                10</span><br><span class="line"></span><br><span class="line">/* constant expressions */</span><br><span class="line">#define IS_CONSTANT                 11</span><br><span class="line">#define IS_CONSTANT_AST             12</span><br><span class="line"></span><br><span class="line">/* fake types */</span><br><span class="line">#define _IS_BOOL                    13</span><br><span class="line">#define IS_CALLABLE                 14</span><br><span class="line">#define IS_ITERABLE                 19</span><br><span class="line">#define IS_VOID                     18</span><br><span class="line"></span><br><span class="line">/* internal types */</span><br><span class="line">#define IS_INDIRECT                 15  /* 间接类型 */</span><br><span class="line">#define IS_PTR                      17  /* 指针类型 */</span><br><span class="line">#define _IS_ERROR                   20  /* 错误类型 *</span><br></pre></td></tr></table></figure><h3 id="整形和浮点型"><a href="#整形和浮点型" class="headerlink" title="整形和浮点型"></a>整形和浮点型</h3><p>整形和浮点型在zval是直接存储的，实现的比较简单</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串类型的结构如下共占32字节  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_string&#123;</span><br><span class="line">zend_refcounted_h gc;     // 用于引用计数 8字节</span><br><span class="line">zend_ulong        h;      // 哈希值 8字节</span><br><span class="line">size_t            len;    // 字符串长度 8字节</span><br><span class="line">char              val[1]; // 柔性数组，1字节 字符串的值存储位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct _zend_refcounted_h &#123;</span><br><span class="line">    uint32_t        refcounted; </span><br><span class="line">    union &#123;</span><br><span class="line">        struct&#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_3 (</span><br><span class="line">                zend_uchar  type,</span><br><span class="line">                zend_uchar  flags,</span><br><span class="line">                uint16_t    gc_info</span><br><span class="line">            )</span><br><span class="line">    &#125; v;</span><br><span class="line">    uint32_t type_info;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125;zend_refcounted_h;</span><br><span class="line">```  </span><br><span class="line">#### 字段说明  </span><br><span class="line">gc   </span><br><span class="line">gc字段主要存放引用计数等信息。flags存放类别信息，type存放变量类别  </span><br><span class="line"></span><br><span class="line">h  </span><br><span class="line">h字段的作用是缓存字符串的哈希值  </span><br><span class="line"></span><br><span class="line">val  </span><br><span class="line">val字段存储字符串值  </span><br><span class="line"></span><br><span class="line">len  </span><br><span class="line">字符串长度  </span><br><span class="line"></span><br><span class="line">PHP中的字符串是二进制安全的，在遇到\0的时候并不认为结束了，读取的时候以len的值为准  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 几个常用字符串的操作  </span><br><span class="line">echo 输出一个或多个字符串  </span><br><span class="line">在Zend/zend_vm_execute.h下</span><br></pre></td></tr></table></figure><p>static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>    USE_OPLINE</p><pre><code>zval *z;SAVE_OPLINE();z = EX_CONSTANT(opline-&gt;op1); //获取变量if (Z_TYPE_P(z) == IS_STRING) { // 判断是否是字符串 是的或就直接输出    zend_string *str = Z_STR_P(z);     if (ZSTR_LEN(str) != 0) {        zend_write(ZSTR_VAL(str), ZSTR_LEN(str));  //将字符串写入到标准输出    }} else {    zend_string *str = _zval_get_string_func(z);  //强制转换    if (ZSTR_LEN(str) != 0) {        zend_write(ZSTR_VAL(str), ZSTR_LEN(str));   //写入到标准输出    } else if (IS_CONST == IS_CV &amp;&amp; UNEXPECTED(Z_TYPE_P(z) == IS_UNDEF)) {        GET_OP1_UNDEF_CV(z, BP_VAR_R);    }    zend_string_release(str);}ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();</code></pre><p>}</p><p>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;zval&quot;&gt;&lt;a href=&quot;#zval&quot; class=&quot;headerlink&quot; title=&quot;zval&quot;&gt;&lt;/a&gt;zval&lt;/h2&gt;&lt;p&gt;PHP在内核中是通过zval这个结构体来存储变量的，PHP的变量是弱类型的，首先来看看PHP5的zval设计   &lt;/p&gt;
&lt;h3 id=&quot;PHP5的zval&quot;&gt;&lt;a href=&quot;#PHP5的zval&quot; class=&quot;headerlink&quot; title=&quot;PHP5的zval&quot;&gt;&lt;/a&gt;PHP5的zval&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 考虑到结构体对齐 大小为24字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct _zval_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	/*变量信息*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zvalue_value value;     // 16字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zend_uint refcount__gc;  // 4字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zend_uchar type;         /* 类型   1字节*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zend_uchar is_ref__gc;   // 1字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PHP扩展开发" scheme="https://joewt.com/categories/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>认识PHP的一些基本原理</title>
    <link href="https://joewt.com/2018/09/01/php-extension-1-1/"/>
    <id>https://joewt.com/2018/09/01/php-extension-1-1/</id>
    <published>2018-09-01T10:08:43.000Z</published>
    <updated>2018-10-19T07:09:33.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从PHP的执行原理开始"><a href="#从PHP的执行原理开始" class="headerlink" title="从PHP的执行原理开始"></a>从PHP的执行原理开始</h2><p>PHP是一门解释型语言,执行过程如下：<br>第一步：源码通过词法分析得到Token。Token是PHP代码被切割成的有意义的标识。在zend_language_parse.h文件中做了定义，比如echo对应的Token是T_ECHO，值为328<br>第二步：语法分析将Token和符合文法规则的代码生成抽象语法树。在PHP7中，AST是新特征<br>第三步：将AST生成对应的opcode，并被虚拟机执行。opcode是PHP定义的一组指令标识，对应相应的handler。opcodes是opcode的集合形式，是PHP执行过程的中间代码，类似Java的字节码。PHP优化中有一个常见的“开启opcache”，指的就是opcodes的缓存  </p><a id="more"></a><h2 id="PHP7内核架构"><a href="#PHP7内核架构" class="headerlink" title="PHP7内核架构"></a>PHP7内核架构</h2><p>主要来自于《PHP7底层设计与源码实现》</p><p><img src="http://img.hnitoj.cn/image/php/php7source.png" alt=""></p><ul><li><p>Zend引擎：词法/语法分析、AST编译和opcodes的执行均在Zend引擎中实现。引擎为PHP提供了基础服务，PHP的可靠性和高性能都依赖引擎的基础支撑。  </p></li><li><p>PHP层：来自外部的交互通过PHP层来处理。  </p></li><li>SAPI：SAPI(Server API),包含了常见的cli SAPI，cgi SAPI和fmpSAPI。SAPI提供了一个和外部通信的接口。  </li><li>扩展部分：Zend引擎提供了核心能力和接口规范。在此基础上进行扩展开发。</li></ul><p>以下为几种常见的SAPI  </p><ul><li>cli： PHP的命令行交互接口</li><li>fpm-fcgi: fmp全称为FastCGI Process Manager，PHP官方提供的FastCGI进程管理器。举例来说，当有http请求发送到nginx服务器，nginx按照FastCGI协议把请求交给php-fpm进程处理  </li><li>apache2handler: Apache扩展，编译后生产动态链接库，配置到Apache下，当有http请求到Apache时，根据配置会调用此动态链接库，执行PHP代码，完成与PHP的交互</li></ul><h2 id="PHP的生命周期"><a href="#PHP的生命周期" class="headerlink" title="PHP的生命周期"></a>PHP的生命周期</h2><p>在cli模式下，PHP的执行过程主要分为5大阶段：  </p><ol><li>模块初始化阶段  php_module_startup</li><li>请求初始化阶段  php_request_startup</li><li>执行阶段  php_execute_script</li><li>请求关闭阶段  php_request_shutdown</li><li>模块关闭阶段  php_module_shutdown</li></ol><p>web模式没有1或5</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从PHP的执行原理开始&quot;&gt;&lt;a href=&quot;#从PHP的执行原理开始&quot; class=&quot;headerlink&quot; title=&quot;从PHP的执行原理开始&quot;&gt;&lt;/a&gt;从PHP的执行原理开始&lt;/h2&gt;&lt;p&gt;PHP是一门解释型语言,执行过程如下：&lt;br&gt;第一步：源码通过词法分析得到Token。Token是PHP代码被切割成的有意义的标识。在zend_language_parse.h文件中做了定义，比如echo对应的Token是T_ECHO，值为328&lt;br&gt;第二步：语法分析将Token和符合文法规则的代码生成抽象语法树。在PHP7中，AST是新特征&lt;br&gt;第三步：将AST生成对应的opcode，并被虚拟机执行。opcode是PHP定义的一组指令标识，对应相应的handler。opcodes是opcode的集合形式，是PHP执行过程的中间代码，类似Java的字节码。PHP优化中有一个常见的“开启opcache”，指的就是opcodes的缓存  &lt;/p&gt;
    
    </summary>
    
      <category term="PHP扩展开发" scheme="https://joewt.com/categories/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>记一次性能优化点</title>
    <link href="https://joewt.com/2018/08/27/mysql-optimize-1/"/>
    <id>https://joewt.com/2018/08/27/mysql-optimize-1/</id>
    <published>2018-08-27T11:39:08.000Z</published>
    <updated>2018-08-27T12:16:52.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近学习了个小项目, 打算把它作为我们队的论坛系统，但部署到服务器上时发现 打开一个页面要等好久。在此记录下如何解决的，最后的处理结果也是非常简单。  </p></blockquote><a id="more"></a><p><a href="https://bbs.hnitoj.cn" target="_blank" rel="noopener">线上地址</a>  </p><p><a href="https://github.com/yinrenxin/laravel-larabbs" target="_blank" rel="noopener">项目地址</a>  </p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>这个项目是用Laravel框架，本地开发使用Homestead，开发起来非常方便。线上部署使用了<a href="http://laradock.io/introduction/" target="_blank" rel="noopener">Laradock</a>比较好用的一个Docker化的一个PHP运行环境  </p><p>因为某个还未解决的问题，没有使用Laradock里的MySQL容器，我就想着使用另外一台服务器运行MySQL，当整个部署完成后，MySQL远程连接开启。启动项目：）   </p><h2 id="问题展现"><a href="#问题展现" class="headerlink" title="问题展现"></a>问题展现</h2><p>。。。。怎么有点慢，打开 Laravel Debugbar，发现页面加载耗时10S(……)，再次查看，发现每次请求,第一条sql耗时将近10S,后面的sql语句还算正常。  </p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>通过查询相关资料，原来是MySQL还要进行DNS解析，这就好办了禁用DNS解析就行通过在mysql的配置文件里添加  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><p>如果禁用DNS查询MySQL怎么知道远程连接的客户端在哪个位置呢，这个也好解决，只要在配置MySQL远程连接时指定一个固定的IP就行(必须使用IP地址)。  </p><p>之后再打开应用就快很多了。</p><blockquote><p>When a new thread connects to mysqld, mysqld will spawn a new thread to handle the request. This thread will first check if the hostname is in the hostname cache. If not the thread will call gethostbyaddr_r() and gethostbyname_r() to resolve the hostname.</p><p>If the operating system doesn’t support the above thread-safe calls, the thread will lock a mutex and call gethostbyaddr() and gethostbyname() instead. Note that in this case no other thread can resolve other hostnames that is not in the hostname cache until the first thread is ready.</p><p>You can disable DNS host lookup by starting mysqld with –skip-name-resolve. In this case you can however only use IP names in the MySQL privilege tables.</p><p>If you have a very slow DNS and many hosts, you can get more performance by either disabling DNS lookop with –skip-name-resolve or by increasing the HOST_CACHE_SIZE define (default: 128) and recompile mysqld.</p><p>You can disable the hostname cache with –skip-host-cache. You can clear the hostname cache with FLUSH HOSTS or mysqladmin flush-hosts.</p><p>If you don’t want to allow connections over TCP/IP, you can do this by starting mysqld with –skip-networking.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近学习了个小项目, 打算把它作为我们队的论坛系统，但部署到服务器上时发现 打开一个页面要等好久。在此记录下如何解决的，最后的处理结果也是非常简单。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MYSQL优化" scheme="https://joewt.com/categories/MYSQL%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="MYSQL" scheme="https://joewt.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>网络IPC: 套接字(十六)</title>
    <link href="https://joewt.com/2018/08/03/network-IPC/"/>
    <id>https://joewt.com/2018/08/03/network-IPC/</id>
    <published>2018-08-03T06:03:47.000Z</published>
    <updated>2018-08-03T08:50:12.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX系统提供的经典进程间通信机制(IPC): 管道、FIFO、消息队列、信号量以及共享存储。这些机制允许在同一台计算机上运行的进程可以相互通信。本章内容主要是研究在不同计算机上的进程相互通信的机制: 网络进程间通信(network IPC)。  </p><a id="more"></a><h2 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h2><p>套接字描述符在UNIX系统上被当做一种文件描述符，UNIX系统一切皆文件。<br>调用socket函数，创建一个套接字  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int damain, int type, int protocol);</span><br><span class="line">//成功：返回描述符，出错：返回-1</span><br></pre></td></tr></table></figure><p>参数domain确定通信特征，包括地址格式  </p><table><thead><tr><th style="text-align:left">域</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">AF_INET</td><td style="text-align:left">IPv4</td></tr><tr><td style="text-align:left">AF_INET6</td><td style="text-align:left">IPv6</td></tr><tr><td style="text-align:left">AF_UNIX</td><td style="text-align:left">UNIX域</td></tr><tr><td style="text-align:left">AF_UPSPEC</td><td style="text-align:left">未指定</td></tr></tbody></table><p>参数type确定套接字类型，进一步确定通信特征   </p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">SOCK_DGRAM</td><td style="text-align:left">固定长度、无连接、不可靠的报文传递</td></tr><tr><td style="text-align:left">SOCK_RAW</td><td style="text-align:left">IP协议的数据报接口</td></tr><tr><td style="text-align:left">SOCK_SEQPACKET</td><td style="text-align:left">固定长度、有序的、可靠的、面向连接的报文传递</td></tr><tr><td style="text-align:left">SOCK_STREAM</td><td style="text-align:left">有序的、可靠的、双向的、面向连接的字节流</td></tr></tbody></table><p>参数protocal通常是0、表示为给定的域和套接字类型选择默认协议  </p><p>数据报(SOCK_DGRAM)接口，类似于UDP通信，两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。<br>字节流(SOCK_STREAM),类似于TCP，在交换数据前，需要建立一个逻辑连接。  </p><p>套接字通信时双向的。可以采用shutdown函数来禁止一个套接字的I/O。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int shutdown(int sockfd, int how);</span><br><span class="line">//成功：返回0 失败：返回-1</span><br></pre></td></tr></table></figure><p>how参数  </p><ul><li>SHUT_RE(关闭读端)，无法从套接字读取数据</li><li>SHUT_WR(关闭写端)，无法使用套接字发送数据</li><li>SHUT_RDWR，无法读，也无法读  </li></ul><p>有两个函数用于点分十进制和二进制地址格式之前的相互转换  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">const char *inet_ntop(int domain, const void *restrict addr,</span><br><span class="line">                    char *restrict str, socklen_t size);</span><br><span class="line">                    //成功：返回地址字符串指针，出错：返回NULL</span><br><span class="line"></span><br><span class="line">int inet_pton(int domain, const char *restrict str,</span><br><span class="line">                void *restrict addr);</span><br><span class="line">                    //成功：返回1，格式无效返回0，失败：返回-1</span><br></pre></td></tr></table></figure><h2 id="将套接字与地址关联"><a href="#将套接字与地址关联" class="headerlink" title="将套接字与地址关联"></a>将套接字与地址关联</h2><p>使用bind函数来关联地址和套接字  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t len);</span><br><span class="line">//成功：返回0，失败：返回-1</span><br></pre></td></tr></table></figure><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>使用connect函数来建立连接  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t len);</span><br><span class="line">//成功：返回0，失败：返回-1</span><br></pre></td></tr></table></figure><p>在connect中指定的地址是我们想与之通信的服务器地址。如果sockfd没有绑定到一个地址，connect会给调用者绑定一个默认地址。  </p><p>服务器调用listen函数宣告它愿意接受连接请求  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">//成功：返回0，失败：返回-1</span><br></pre></td></tr></table></figure><p>参数backlog提供了一个提示，提示系统该进程所要入队的未完成连接请求数量。实际值由系统决定<br>一旦队列满，系统就会拒绝多余的连接请求，所以backlog的值应该基于服务器期望负载和处理量来选择，其中处理量是指接受连接请求与启动服务的数量。<br>一旦服务器调用了listen，所用的套接字就能接收连接请求。使用accept函数来获得连接请求并建立连接。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *restrict addr,</span><br><span class="line">            socklen_t *restrict len);</span><br><span class="line">            //成功：返回文件描述符，出错：返回-1</span><br></pre></td></tr></table></figure><p>函数accept返回的是套接字描述符，该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字(sockfd)具有相同的套接字类型和地址族。传给accept的原始套接字没有关联到这个连接，而是继续保持可用状态并接收其他连接请求。<br>如果不关心客户端标识，可以将参赛addr和len设为NULL。否则，在调用accept之前，将addr参数设为足够大的缓冲区来存放地址，并且将len指向的整数设为这个缓冲区的字节大小。返回时，accept会在缓冲区填充客户端的地址，并且更新指向len的整数来反映该地址的大小。<br>如果没有连接请求等待，accept会阻塞直到一个请求到来。如果sockfd处于非阻塞模式，accept会返回-1，并将errno设置为EAGAIN或EWOULDBLOCK。<br>如果服务器调用accept，并且当前没有连接请求，服务器会阻塞直到一个请求到来。另外，服务器可以使用poll或select来等待一个请求的到来。在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现。  </p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);</span><br><span class="line">//成功: 返回发送的字节数，失败：返回-1</span><br></pre></td></tr></table></figure><p>对于支持报文边界的协议，如果尝试发送单个报文的长度超过协议锁支持的最大长度，那么send会失败，并将errno设为EMSGSIZE。对于字节流协议，send会阻塞直到整个数据传输完成。函数sendto和send类似。区别在于sendto可以在无连接的套接字上指定一个目标地址。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr * destaddr, socklen_t destlen);</span><br><span class="line">//成功：返回发送的字节数，失败：返回-1</span><br></pre></td></tr></table></figure><p>使用recv函数接收数据   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);</span><br><span class="line">//返回数据的字节长度，无数据或等放已经按序结束，返回0，出错：返回-1</span><br></pre></td></tr></table></figure><h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>通常，recv函数没有数据可用时会阻塞等待。同样的，当套接字输出队列没有足够空间来发送消息时，send函数会阻塞。在套接字非阻塞模式下，行为会改变。在这种情况下，这些函数不会阻塞而是会失败，将errno设置为EWOULDBLOCK或者EAGAIN。当这种情况发生时，可以用poll或select来判断能否接收或者传输数据。  </p><p>Single UNIX Specification 包含通用异步I/O机制的支持。套接字机制有自己的处理异步I/O的方式。<br>在基于套接字的异步I/O中，当从套接字中读取数据时，或者当套接字写队列中空间变得可用时，可以安排要发送的信号SIGIO。<br>启用异步I/O的步骤  </p><ol><li>建立套接字所有权，这样信号可以被传递到合适的进程。  <ul><li>在fcntl中使用F_SETOWN命令</li><li>在ioctl中使用FIOSETOWN命令</li><li>在ioctl中使用SIOCSGRP命令 </li></ul></li><li>通知套接字当I/O操作不会阻塞时发信号。  <ul><li>在fcntl中使用F_SETFL命令并且启用文件标志<code>O_ASYNC</code>。</li><li>在ioctl中使用FIOASYNC命令。</li></ul></li></ol><p>但没有得到普遍支持</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;UNIX系统提供的经典进程间通信机制(IPC): 管道、FIFO、消息队列、信号量以及共享存储。这些机制允许在同一台计算机上运行的进程可以相互通信。本章内容主要是研究在不同计算机上的进程相互通信的机制: 网络进程间通信(network IPC)。  &lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>守护进程(十三)</title>
    <link href="https://joewt.com/2018/07/10/daemons/"/>
    <id>https://joewt.com/2018/07/10/daemons/</id>
    <published>2018-07-09T16:17:42.000Z</published>
    <updated>2018-10-19T07:09:33.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>守护进程(daemon)是在系统引导装入时启动，仅在系统关闭时才终止。守护进程是在后台运行的。  </p><h2 id="守护进程特征"><a href="#守护进程特征" class="headerlink" title="守护进程特征"></a>守护进程特征</h2><p>在命令行下输入 ps -axj(BSD系统)  查看系统中各个进程的状态。  </p><a id="more"></a><p><img src="http://img.hnitoj.cn/apue/img/chapter13/figure13-1.png" alt="">  </p><p>父ID为0的个进程通常是内核进程，内核进程存在于系统的整个生命周期，他们以超级用户特权运行，无控制终端，无命令行。  </p><p>在ps的输出中，内核守护进程的名字出现在方括号中。  </p><p><img src="http://img.hnitoj.cn/apue/img/chapter13/figure13-2.png" alt="">  </p><p>可以看到Linux使用了kthreadd的特殊内核进程来创建其他的内核进程，所以其他内核进程的父进程为2 也就是kthreadd进程。对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。如在Linux中。  </p><ul><li>kswapd 内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢写会磁盘。</li><li>flush  守护进程在可用内存达到设置的最小阀值时将脏页面冲洗至磁盘。同时它还定期将脏页面冲洗会磁盘防止数据丢失。</li><li>sync_supers 定期将文件系统元数据冲洗至磁盘。</li><li>jbd 帮助实现了ext4文件系统中的日志功能。</li></ul><hr><ul><li>进程1通常是init进程，它是系统守护进程，主要负责启动各运行层次特定的系统服务。  </li><li>rpcbind守护进程提供将RPC程序号映射为网络端口号的服务。  </li><li>rsyslogd守护进程可以被由管理员启用的将系统日志记录的任何程序使用  </li><li>inetd守护进程。侦听系统网络接口，以便取得来自网络的对各种网络服务进程的请求  </li><li>nfsd、nfsiod、lockd、rpciod、rpc.idmapd、rpc.statd、rpc.mountd提供了网络文件系统的支持。  </li></ul><h2 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h2><p>编写一个守护进程需要遵循一些规则，防止产生不必要的交互。  </p><ol><li>调用umask将文件模式创建屏蔽字设置为一个已知值通常为0</li><li>调用fork，然后父进程exit</li><li>调用setsid创建一个新会话</li><li>当前工作目录更改为根目录</li><li>关闭不需要的文件描述符</li><li>某些守护进程打开/dev/null 使其具有文件描述符0、1、2</li></ol><h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程出错处理，大多数守护进程都使用 BSD的syslog设施。  </p><p><img src="http://img.hnitoj.cn/apue/img/chapter13/figure13-3.png" alt="">  </p><p> 有3种产生日志消息的方式  </p><ol><li>内核例程可以调用log函数。</li><li>大多数用户进程(守护进程)调用syslog(3)函数来产生日志消息，</li><li>无论一个用户进程是在此主机上，还是在通过TPC/IP网络连接到此主机的其他主机上，都可以将日志消息发送到UDP的514端口。  </li></ol><p> 通常，syslogd守护进程读取所有3种格式的日志消息。启动时读取一个配置文件，通常是/etc/syslogd.conf该文件决定了不同种类的消息应送到何处。  </p><p> syslog设施的接口是syslog函数  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;syslog.h&gt;</span><br><span class="line">void openlog(const char *ident, int option, int facility);</span><br><span class="line">void syslog(int priority, const char *format, ...);</span><br><span class="line">void closelog(void);</span><br><span class="line">int setlogmask(int maskpri);</span><br></pre></td></tr></table></figure><h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p> 某些守护进程会实现为，在任意时刻只运行该守护进程的一个副本。对于cron守护进程而言，如果有多个实例运行，那么每个副本都可能试图开始某个预定的操作，会造成重复执行，这可能会出错。  </p><p> 如果守护进程需要访问一个设备，而该设备驱动程序有时会阻止想要多次打开/dev 目录下相应设备节点的尝试。这就限制了在一个时刻只能运行守护进程的一个副本。但如果没有这种设备可供使用，那么就需要自行处理。   </p><p> 文件和记录锁机制为一种方法提供了基础，该方法保证一个守护进程只有一个副本在运行。如果每一个守护进程创建一个固定名字的文件，并在该文件的整体上加一把写锁，那么只允许创建一把这样的锁。在此之后创建写锁的尝试都会失败，这向后续进程副本指明已有一个副本正在运行。  </p><h2 id="守护进程惯例"><a href="#守护进程惯例" class="headerlink" title="守护进程惯例"></a>守护进程惯例</h2><p> 在UNIX系统中，守护进程遵循以下通用惯例  </p><ul><li>若守护进程使用锁文件，那么该文件通常存储在/var/run目录中。</li><li>若守护进程支持配置选项，那么配置文件一般位于/etc下，如/etc/syslog.conf  </li><li>守护进程可以由命令行启动，但通常它们是由系统启动脚本之一启动的<code>/etc/rc*或/etc/init.d/*</code>。</li><li>配置文件一般只在启动时读取，如果更改配置文件，就要重启进程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;守护进程(daemon)是在系统引导装入时启动，仅在系统关闭时才终止。守护进程是在后台运行的。  &lt;/p&gt;
&lt;h2 id=&quot;守护进程特征&quot;&gt;&lt;a href=&quot;#守护进程特征&quot; class=&quot;headerlink&quot; title=&quot;守护进程特征&quot;&gt;&lt;/a&gt;守护进程特征&lt;/h2&gt;&lt;p&gt;在命令行下输入 ps -axj(BSD系统)  查看系统中各个进程的状态。  &lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TP5集成Swoole</title>
    <link href="https://joewt.com/2018/06/20/thinkphpMeetsSwoole/"/>
    <id>https://joewt.com/2018/06/20/thinkphpMeetsSwoole/</id>
    <published>2018-06-20T12:45:28.000Z</published>
    <updated>2018-10-19T07:09:33.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>thinkphp5.1和swoole  </p><p>tp5的安装使用composer安装，使用以下命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project topthink/think  tp5  --prefer-dist</span><br></pre></td></tr></table></figure></p><blockquote><p>thinkphp5.1.18更新,完善了swoole的支持,不用再自己更改Request类了  </p></blockquote><p><a href="http://www.thinkphp.cn/topic/57791.html" target="_blank" rel="noopener"><br>ThinkPHP5.1.18版本发布——完善Swoole/Workerman支持</a></p><p>swoole的安装参考我写的swoole安装教程  </p><h2 id="swoole简单使用"><a href="#swoole简单使用" class="headerlink" title="swoole简单使用"></a>swoole简单使用</h2><a id="more"></a><p>一般来说我们的浏览器发起一个请求先走nginx或apache，然后通过fast_CGI交给php来执行php代码,FPM是fast_cgi的进程管理器,FPM通过一些配置管理很多的fast_cgi进程。<br>当我们使用swoole来开启一个http服务的话就不需要使用fpm了。</p><p>首先看官方文档的一个例子  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$http = new swoole_http_server(&quot;127.0.0.1&quot;, 9501);</span><br><span class="line">//在收到一个http请求后，会调用该函数</span><br><span class="line">$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123;</span><br><span class="line">    //发送http响应体，结束请求处理</span><br><span class="line">    $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>如果想加载静态的html文件，可以使用document_root配置  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$http = new swoole_http_server(&quot;127.0.0.1&quot;, 9501);</span><br><span class="line">//worker_num设置启动的worker进程数</span><br><span class="line">$http-&gt;set(</span><br><span class="line">    [</span><br><span class="line">        &apos;enable_static_handler&apos; =&gt; true,</span><br><span class="line">        &apos;document_root&apos; =&gt; &quot;/thinkphp/public/static/live&quot;,</span><br><span class="line">        &apos;worker_num&apos; =&gt; 5,</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123;</span><br><span class="line">    $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>使用命令行运行该程序，打开浏览器即可看到结果,这里就不给结果了。  </p><h2 id="tp5结合swoole"><a href="#tp5结合swoole" class="headerlink" title="tp5结合swoole"></a>tp5结合swoole</h2><p>首先把上面的http_server的代码放到tp5的项目目录下，我是放到了项目的根目录下<br><img src="http://img.hnitoj.cn/figure1.1.png" alt="">  </p><ul><li><p>如果我们不修改，当我们输入url的时候并不会找到相应的控制器方法。swoole通过request事件，通过回调函数处理相应的请求get,post等。  </p></li><li><p>通过swoole的workerstart事件回调函数加载框架代码</p></li><li><p>通过观察tp5的代码可以看到,index.php首先加载了引导文件start.php, start.php又加载了base.php文件。我们要加载的便是该文件  </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$http-&gt;on(&apos;WorkerStart&apos;,function(swoole_server $server,$worker_id)&#123;</span><br><span class="line">    define(&apos;APP_PATH&apos;, __DIR__ . &apos;/../application/&apos;);</span><br><span class="line">    // 这里 引入 base.php  而不引入start.php  是因为</span><br><span class="line">    // start.php 的话 就会执行thinkphp 的相应的控制器方法了</span><br><span class="line">    require __DIR__ . &apos;/../thinkphp/base.php&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>这样便把tp5的代码加载到worker进程里,接着处理请求部分<br>因为tp5使用原生的php代码，所以需要把swoole的请求转换下。swoole接收get，post跟原生的不一样。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$http-&gt;on(&apos;request&apos;, function ($request, $response) use($http)&#123;</span><br><span class="line">    if(isset($request-&gt;server))&#123;</span><br><span class="line">        foreach($request-&gt;server as $k =&gt; $v)&#123;</span><br><span class="line">            $_SERVER[strtoupper($k)] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isset($request-&gt;server))&#123;</span><br><span class="line">        foreach($request-&gt;server as $k =&gt; $v)&#123;</span><br><span class="line">            $_SERVER[strtoupper($k)] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //swoole对于超全局数组并不会释放，所以要先清空一次</span><br><span class="line">    $_GET = [];</span><br><span class="line">    if(isset($request-&gt;get))&#123;</span><br><span class="line">        foreach ($request-&gt;get as $k =&gt; $v)&#123;</span><br><span class="line">            $_GET[$k] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $_POST = [];</span><br><span class="line">    if(isset($request-&gt;post))&#123;</span><br><span class="line">        foreach ($request-&gt;post as $k =&gt; $v)&#123;</span><br><span class="line">            $_POST[$k] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //把返回放到一个缓冲区里</span><br><span class="line">    ob_start();</span><br><span class="line">    try &#123;</span><br><span class="line">        think\Container::get(&apos;app&apos;, [defined(&apos;APP_PATH&apos;) ? APP_PATH : &apos;&apos;])</span><br><span class="line">            -&gt;run()</span><br><span class="line">            -&gt;send();</span><br><span class="line">    &#125;catch(\Exception $e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    echo request()-&gt;action();</span><br><span class="line">    $res = ob_get_contents();</span><br><span class="line">    ob_end_clean();</span><br><span class="line">    $response-&gt;end($res);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样改完后我们测试下 </p><p><img src="http://img.hnitoj.cn/figure1.2.png" alt=""></p><p><img src="http://img.hnitoj.cn/figure1.3.png" alt="">  </p><p><img src="http://img.hnitoj.cn/figure1.4.png" alt=""> </p><p>我们发现当我们修改方法时，始终显示的是index方法，这里有一个解决办法。</p><p>找到thinkphp/library/think/Request.php文件,里面有2个方法更改如下  </p><p><img src="http://img.hnitoj.cn/figure1.6.png" alt=""><br><img src="http://img.hnitoj.cn/figure1.7.png" alt="">  </p><p>之后我们就可以正常的通过url进行访问了。这里改成这样的原因，是因为tp会把模块，控制器，方法放到一个变量中，如果我们有重复访问同一个控制器，方法时这样比较高效。但worker进程并不会注销变量。就造成了访问不同控制器，方法始终是同一个控制器，方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;thinkphp5.1和swoole  &lt;/p&gt;
&lt;p&gt;tp5的安装使用composer安装，使用以下命令安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;composer create-project topthink/think  tp5  --prefer-dist&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;thinkphp5.1.18更新,完善了swoole的支持,不用再自己更改Request类了  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.thinkphp.cn/topic/57791.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;br&gt;ThinkPHP5.1.18版本发布——完善Swoole/Workerman支持&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;swoole的安装参考我写的swoole安装教程  &lt;/p&gt;
&lt;h2 id=&quot;swoole简单使用&quot;&gt;&lt;a href=&quot;#swoole简单使用&quot; class=&quot;headerlink&quot; title=&quot;swoole简单使用&quot;&gt;&lt;/a&gt;swoole简单使用&lt;/h2&gt;
    
    </summary>
    
      <category term="Swoole" scheme="https://joewt.com/categories/Swoole/"/>
    
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
      <category term="swoole" scheme="https://joewt.com/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>线程(十一)上</title>
    <link href="https://joewt.com/2018/06/06/pthread/"/>
    <id>https://joewt.com/2018/06/06/pthread/</id>
    <published>2018-06-05T16:29:40.000Z</published>
    <updated>2018-06-06T03:09:47.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>线程的一些基础知识，包括线程的创建、线程终止</p></blockquote><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>典型的UNIX进程可以看成只有一个控制线程；一个进程在某一时刻只能做一件事情。有了多个控制线程后，在程序设计时就可以把进程设计成在某一时刻做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处  </p><ol><li>简化处理异步事件的代码</li><li>分解复杂的问题提高整个程序的吞吐量</li><li>使用多线程改善响应时间  </li></ol><a id="more"></a><p>每个线程都包含有表示执行环境所必须的信息。其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。  </p><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>每个线程都有一个线程ID。但跟进程不一样，进程ID在整个系统中是唯一的，线程ID只有在它所属的进程上下文中才有意义。  </p><p>线程ID通过使用pthread_t数据类型表示，必须要使用一个函数对两个线程ID进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_equal(pthread_t tid1, pthread_t tid2);</span><br><span class="line">// 相等返回非零，不同返回0</span><br></pre></td></tr></table></figure></p><p>线程通过调用pthread_self函数获得自身的线程ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_t pthread_self(void);</span><br></pre></td></tr></table></figure></p><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>新增的线程可以通过调用pthread_create函数创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_create(pthread_t *restrict tidp, </span><br><span class="line">                   const pthread_attr_t *restrict attr,</span><br><span class="line">                   void *(*start_rtn)(void *), void *restrict arg);</span><br><span class="line">//成功返回0，失败返回错误编号</span><br></pre></td></tr></table></figure></p><ul><li>当pthread_create成功返回时，新创建线程的线程ID会被设置成tidp指向的内存单元。attr用于定制各种不同的线程属性(第12章介绍)，设置为NULL，表示创建一个具有默认属性的线程。</li><li>新创建的线程从start_rtn函数的地址开始执行，该函数只有一个无类型指针参数arg。如果有多个参数传递，需要把这些参数放到一个结构中，然后传递这个结构的地址进去。</li><li>线程创建时不能保证执行顺序  </li></ul><p>如下程序创建了一个线程，打印了进程ID、新线程的线程ID以及初始线程的线程ID。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t ntid;</span><br><span class="line">void printids(const char *s)&#123;</span><br><span class="line">    pid_t   pid;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    tid = pthread_self();</span><br><span class="line">    printf(&quot;%s pid %lu tid %lu (0x%lx)\n&quot;,s,(unsigned long)pid, (unsigned long)tid, (unsigned long)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * thr_fn(void *arg)&#123;</span><br><span class="line">    printids(&quot;new thread:&quot;);</span><br><span class="line">    return ((void *)0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    err = pthread_create(&amp;ntid, NULL, thr_fn, NULL);</span><br><span class="line">    if(err !=0 )</span><br><span class="line">        err_exit(err, &quot;can&apos;t create thread&quot;);</span><br><span class="line">    printids(&quot;main thread:&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图所示<br><img src="/img/chapter-11/figure11.2.png" alt=""><br>可以看到打印出了相同的进程ID，但在mac系统上线程ID不在相同地址段范围  </p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、<code>_Exit</code>或者<code>_exit</code>，那么整个进程就会终止。<br>单个线程可以通过3种方式退出，可以在不终止整个进程的情况下，停止它的控制流。 </p><ol><li>线程可以简单的从启动例程中返回，返回值是线程的退出码。</li><li>线程可以被同一进程中的其他线程取消。</li><li>线程调用pthread_exit。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_exit(void *rval_ptr);</span><br></pre></td></tr></table></figure><p>rval_ptr参数是一个无类型指针，进程中的其他线程可以通过调用pthread_join函数访问到这个指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_join(pthread_t thread, void **rval_ptr);</span><br><span class="line">//成功返回0，失败返回错误编号</span><br></pre></td></tr></table></figure><ul><li>调用线程将一直阻塞，直到指定的线程调用pthread_exit、从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，rval_ptr就包含返回码。如果线程被取消，由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED。  </li><li>通过调用pthread_join自动把线程置于分离状态，这样资源就可以恢复。如果线程已经处于分离状态，pthread_join就会调用失败，返回EINVAL  </li></ul><p>如下程序展示了如何获取已经终止线程的退出码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *thr_fn1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;thread 1 returning\n&quot;);</span><br><span class="line">    return((void *)0);</span><br><span class="line">&#125;</span><br><span class="line">void *thr_fn2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;thread 2 exiting\n&quot;);</span><br><span class="line">    pthread_exit((void *)2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int         err;</span><br><span class="line">    pthread_t   tid1,tid2;</span><br><span class="line">    void        *tret;</span><br><span class="line">    err = pthread_create(&amp;tid1,NULL,thr_fn1,NULL);</span><br><span class="line">    if (err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t create thread 1&quot;);</span><br><span class="line">    err = pthread_create(&amp;tid2,NULL,thr_fn2,NULL);</span><br><span class="line">    if (err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t create thread 2&quot;);</span><br><span class="line">    err = pthread_join(tid1, &amp;tret);</span><br><span class="line">    if(err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t join with thread 1&quot;);</span><br><span class="line">    printf(&quot;thread 1 exit code %ld\n&quot;,(long)tret);</span><br><span class="line">    err = pthread_join(tid2, &amp;tret);</span><br><span class="line">    if (err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t join with thread 2&quot;);</span><br><span class="line">    printf(&quot;thred 2 exit code %ld\n&quot;,(long)tret);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:<br><img src="/img/chapter-11/figure11.3.png" alt="">  </p><p>线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_cancel(pthread_t tid);</span><br><span class="line">//成功返回0，失败返回错误编号</span><br></pre></td></tr></table></figure><p>pthread_cancel并不等待线程终止，它仅仅提出请求  </p><p>线程可以安排它退出时需要调用的函数(线程清理处理程序)。一个线程可以建立多个清理处理程序。处理程序记录在栈中，他们的执行顺序与他们注册时相反。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_cleanup_push(void (*rtn)(void *), void *arg);</span><br><span class="line">void pthread_cleanup_pop(int execute);</span><br></pre></td></tr></table></figure><p>当线程执行以下动作时，清理函数rtn是由pthread_cleanup_push函数调度的，调用时只有一个参数arg:  </p><ul><li>调用pthread_exit时</li><li>响应取消请求时</li><li>用非零execute参数调用pthread_cleanup_pop时  </li></ul><p>如果execute参数设置为0，清理函数将不被调用。  </p><p>如下程序是使用线程清理处理程序的例子  </p><pre><code>#include &quot;apue.h&quot;#include &lt;pthread.h&gt;void cleanup(void *arg){    printf(&quot;cleanup: %s\n&quot;,(char *)arg);}void *thr_fn1(void *arg){    printf(&quot;thread 1 start\n&quot;);    pthread_cleanup_push(cleanup, &quot;thread 1 first handler&quot;);    pthread_cleanup_push(cleanup, &quot;thread 1 second handler&quot;);    printf(&quot;thread 1 push complete\n&quot;);    if (arg)        return ((void *)1);    pthread_cleanup_pop(0);    pthread_cleanup_pop(0);    return ((void *)1);}void *thr_fn2(void *arg){    printf(&quot;thread 2 start\n&quot;);    pthread_cleanup_push(cleanup, &quot;thread 2 first handler&quot;);    pthread_cleanup_push(cleanup, &quot;thread 2 second handler&quot;);    printf(&quot;thread 2 push complete\n&quot;);    if (arg)        return ((void *)2);    pthread_cleanup_pop(0);    pthread_cleanup_pop(0);    return ((void *)2);}int main(int argc, const char *args[]){    int             err;    pthread_t       tid1,tid2;    void            *tret;    err = pthread_create(&amp;tid1, NULL, thr_fn1, (void*)1);    if (err !=0 )        err_exit(err, &quot;can&apos;t create thread 1&quot;);    err = pthread_create(&amp;tid2, NULL, thr_fn2, (void*)1);    if (err !=0 )        err_exit(err, &quot;can&apos;t create thread 2&quot;);    err = pthread_join(tid1, &amp;tret);    if (err !=0 )        err_exit(err, &quot;can&apos;t join with thread 1&quot;);    printf(&quot;thread 1 exit code %ld\n&quot;, (long)tret);    err = pthread_join(tid2, &amp;tret);    if (err !=0 )        err_exit(err, &quot;can&apos;t join with thread 2&quot;);    printf(&quot;thread 2 exit code %ld\n&quot;, (long)tret);    exit(0);}</code></pre><p>运行结果如下<br><img src="/img/chapter-11/figure11.5.png" alt="">  </p><p>mac 下会产生core文件。这是因为在mac平台上，pthread_cleanup_push是用宏实现的，而宏把某些上下文存放到栈上。当线程1在调用pthread_cleanup_push和调用pthread_cleanup_pop之间返回时，栈已被改写，而这个平台在调用清理处理程序时就用了这个被改写的上下文。在Single UNIX Specification中，函数如果在调用pthread_cleanup_push和pthread_cleanup_pop之间返回，会产生未定义行为。唯一的可移植方法是调用pthread_exit.  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;线程的一些基础知识，包括线程的创建、线程终止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程的概念&quot;&gt;&lt;a href=&quot;#线程的概念&quot; class=&quot;headerlink&quot; title=&quot;线程的概念&quot;&gt;&lt;/a&gt;线程的概念&lt;/h2&gt;&lt;p&gt;典型的UNIX进程可以看成只有一个控制线程；一个进程在某一时刻只能做一件事情。有了多个控制线程后，在程序设计时就可以把进程设计成在某一时刻做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化处理异步事件的代码&lt;/li&gt;
&lt;li&gt;分解复杂的问题提高整个程序的吞吐量&lt;/li&gt;
&lt;li&gt;使用多线程改善响应时间  &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何真正消化一本书？</title>
    <link href="https://joewt.com/2018/05/06/ReadingBooks/"/>
    <id>https://joewt.com/2018/05/06/ReadingBooks/</id>
    <published>2018-05-06T04:02:31.000Z</published>
    <updated>2018-05-06T04:25:20.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是李笑来正在预售的《七年就是一辈子》中的内容，略经 36 氪编辑。作者李笑来的微信公众号为 “学习学习再学习（xiaolai-xuexi）”。</p></blockquote><p>书大抵上分为两种：虚构类（Fiction），非虚构类（Non-Fiction）。读非虚构类的书籍，是为了获取新知识，并应用到生活中，让自己获得进步；就我个人而言，我更喜欢看非虚构类的书籍，从中获得的愉悦，感觉更大，因为那种愉悦通常有更为坚实的支撑 —— 进步。而虚构类的书籍，在大学毕业之后已经很少读了，可能是因为我自己在那里很难体会到太多的乐趣，更可能的另外一个原因是我已经彻底把获取那种愉悦的途径转移到了影视作品上。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="(一)"></a>(一)</h2><p>我读书很快，也因此读得很多，但我从来不强调自己的阅读速度 —— 甚至，我坚持认为“阅读速度” 是个伪概念，在我眼里，只有 “理解速度”，理解速度快，才能有效提高阅读量。</p><p>曾经有一段时间，我阅读英文书籍的时候，干脆是在电脑上用键盘敲，边敲边读…… 因为那个时候我发现自己的理解速度甚至跟不上手指头敲键盘的速度。别说遇到生词需要去查了，甚至常常出现的情况是，手指已经将一句话敲完了，却发现自己的脑子竟然不能理解这句话的确切意思……</p><p>没多久，理解速度开始提高，我也没啥兴趣拿着一本书 “一目十行” 地读。遇到好书，我会抽时间朗读完，一本二十万字左右的书朗读完，也不过十几个小时，中间断断续续，也能一个星期内搞定。更多的时候，时间花在那些需要停下来认真思考的部分，需要停下来心平气和地开开脑洞的部分，需要反复搜索寻找更多资料与关联的部分……反正，眼球快速移动本身，没有任何意义。</p><blockquote><p>阅读，是为了理解，而理解这事儿，慢，即是快；快，便是无。</p></blockquote><h2 id="二"><a href="#二" class="headerlink" title="(二)"></a>(二)</h2><p><strong><strong> 大多数情况下，我的阅读并没有功利性。完整性阅读，是没办法有功利性的，因为其实完全没办法知道所读、所学的东西究竟什么时候才能真正发挥它的核能量。</strong></strong> 还有另外一层原因是，还没读完（输入），还没消化完（处理），当然也完全没有开始行动（实践），所以，别说发挥核能量了，连发挥一点能量的可能性都很少。</p><p>另外一种阅读，我称之为检索性阅读。这种阅读本身就是功利性的，比如为了支持某个论点去搜索更为精彩、更为经典的事例；又比如为了思考得更为全面，去翻翻不同属性的人群是如何看待某个问题的；再比如，为了以上同样的目的去检索自己已读过的书库……</p><p>我总觉得阅读是构成自己生命的最重要组成部分之一，所以当然很舍不得降低它的质量。在信息泛滥的时代里（注意，不是知识泛滥），有个小技巧特别管用：<strong>标题党的文章直接不看了——说实话，即便错过什么了，也没什么可惜。</strong>这个小技巧真的不知道帮我节约了多少时间，提高了多少生活质量。</p><p>我从来都懒得接受 “碎片化 xx” 之类的概念，比如，碎片化阅读，碎片化思考，碎片化时间什么的，谁爱碎谁自己碎去，我才不想要一个碎片化的生活呢。</p><p>信息这东西，必须系统才有价值。碎片化的信息也许有用，但就算完全忽略，也不至于致命。舍了就舍了，没啥。这种勇气其实不少人都有，巴菲特就是其中之一。害怕错过什么，是一种情绪，来自于空虚的情绪：因为什么都没有，所以就渴望有一点什么，所以就特别害怕错过任何机会。充实的人，是不怕错过什么的，因为已经充实，错过点什么，真的无所谓，机会有的是，错过一大把又如何，反正因为充实而能够相信自己确实有实力终归抓到至少一个适合自己的机会。</p><p>所以，一定要读书，而不是把本来只不过是获得知识的辅助手段而已的杂志、文摘、新闻等等当做唯一主要手段。买好书，读好书，读懂好书，然后用知识改变自己的生活。</p><h2 id="三"><a href="#三" class="headerlink" title="(三)"></a>(三)</h2><p><strong>别人是不可能帮你吃饭的。同样的道理，别人其实是完全没办法帮你读书的。</strong>虽然我们在学校的时候，总是习惯了由老师带着、逼着读完整本书。</p><p>我一直觉得现在的学校其实是一种特别诡异的存在：一个学期好几个月，好几个老师就带着学生们完整地读完那么几本书，然后有些老师其实还讲不明白，大部分学生还学不明白…… 于是，生命就那么被浪费了。</p><p>从另外一个角度望过去，这几乎是在刻意把学生们变傻、变笨。这是在潜移默化地告诉学生们，“这东西好难的！难到什么地步呢？难到一届又一届的学生，都要花很长时间学，然后大部分还学不会、学不好呢！”</p><p>最要命的还不是拉长原本可以很短的理解时间，而是让学生们学啊学啊学啊学，就不让学生们用！这是什么道理？你看多少人，小学六年，初中三年，高中三年，大学本科四年，加起来都十六年了，学了十六年英语，然后竟然从来没用过……</p><p>说来说去，总结起来就是：别被他们骗了，你本来没那么傻……</p><h2 id="四"><a href="#四" class="headerlink" title="(四)"></a>(四)</h2><p><strong>拿来一本书，就好像要打一场仗，打仗之前最好先考察一下地形吧？</strong>同样的道理，拿来一本书，不应该是抓起来就从第一个字开始读起，一直读到最后……应该先看看目录，再看看附录，仔细读读前言，也不妨在网上先扫扫书评……要先大致对这本书有个了解，然后再开始行动比较好。</p><p>不同的作者有不同的组织方式，但大体上都是差不多的。总是要分章节。每一章其实都是在着重讲解一个概念，它的应用，它的方法论。而陆续的章节，通常是必须理解上一个概念之后才能进一步理解的概念，及其应用与方法论。所以，一头扎入内容之前，最好把这些概念大致过一遍，不理解没关系，哪怕先记住那些概念的名字和先后关系都很有帮助。</p><p><strong>在读的过程中，不断整理这些概念与方法论之间的关系，其实是 “消化” 的必要过程。</strong>有些人从小就学会了并且早就习惯这么做，而大多数人一辈子不会这么干 —— 这就是为什么最终绝大多数人只具备读半本杂志，看个豆腐块文章的能力，而不大可能真正独立消化一整本书的根本原因。</p><h2 id="五"><a href="#五" class="headerlink" title="(五)"></a>(五)</h2><p><strong>在阅读的过程中，要不断向后总结，向前预期 </strong>—— 这是最基本的理解技巧。在阅读的过程中，要不断总结刚才输入的东西都有什么，它们之间是什么样的关系；与此同时，还要不断预期下一步的内容是什么……这是一个不断循环的输入处理的过程。很多人懂得向后总结，却不懂得也应该同时不断向前预期，于是他们只有输入与处理这两个部分。当然绝大多数人除了输入之外什么都没有，连处理都没有。最终只有少数人的阅读理解过程是不断循环地 “输入、处理、输出” 的过程，尽管这里的 “输出” 某种意义上不过是 “伪输出”……</p><p>向前预期，常常相当于为 “跳读、略读” 提供一个安全机制。读着读着，发现作者提出了一个自己已经深入了解过的论点，再往下扫一眼，发现论据也是自己之前了解的，那这一部分就可以安全地跳过了。又由于一直保持着一个预期，再往下读的时候，发现 “嗯？怎么回事儿？跟我想的不一样呢？” 那就要折回去认真找原因……反之，要是一样，说明自己的跨越是正确的么。</p><p>所以说，在良好的阅读习惯下，理解速度会不断积累，最终不断加快 —— 因为所有的知识都有共同点：它们不一定能用在哪里，它们早晚必然融会贯通。所以，理解过的东西越多，理解新的东西就越快。说穿了，理解能力差，无非就是见识少，仅此而已。</p><h2 id="六"><a href="#六" class="headerlink" title="(六)"></a>(六)</h2><p>一旦遇到需要分享 “如何读书” 的场合，我总是会提起这句话：</p><blockquote><p>我有一个奇怪的本领：就是，把一本书拿过来，我即便读不懂，我也能读得完。</p></blockquote><p>这句话总是引来哄堂大笑，可实际上，首先我是认真的；其次，却也更为重要的是，觉得这事儿荒谬恰恰是大多数人其实不懂如何读书的表现。</p><p>读不懂怎么办？没关系，只有一个办法靠谱：硬着头皮读完，然后反复读很多遍。这是一个特别重要的本领，很多人不知道。其实，重要的知识，从来都是通过反复学习才能获得的。一下就能学会得东西，通常上价值不大。</p><p>有一点弄不明白就放弃，那能学会什么呢？</p><p>还有一个常见现象：有些书籍就是难懂，因为它的内容结构并不完全线性，也就是说，第二章的内容需要第五章的知识才能理解彻底…… 所以，最终，只有我们这种不怕暂时读不懂，能硬着头皮读完，然后再反复来过的人才能消化这种书籍。</p><h2 id="七"><a href="#七" class="headerlink" title="(七)"></a>(七)</h2><p>一定要用起来。很多有用的东西，之所以最终没用，是因为压根没用过。知识无用，这是二货思维，所有的知识都是有用的，哪怕巫术都有用，更何况知识。可是不用的东西，没用起来的东西，还不如虚无 —— 因为读过、学过，时间与精力已经耗费了，这可是最宝贵的不可逆不可回收不可再生资源！</p><p>2000 年，我突击考了 TOEFL、GRE，就跑去新东方应聘出国留学培训教师职位；2005 年开始前后写了两年多，终于觉得自己能用文字讲明白道理了，就写了《把时间当作朋友》；2012 年我学了 Ruby On Rails，就和李路和沙欣哲一起搞出来了一个 Knewone；2014 年我学会了使用 Sketch，就用它设计了若干个 APP 的原型，顺带逼着几个程序员也变成了设计师；2015 年上半年，我读了许多本关于社区建设的书（其中包括那本著名的 The Art of Community: Building the New Age of Participation， <a href="http://www.artofcommunityonline.org），你看我正在打造社群……" target="_blank" rel="noopener">http://www.artofcommunityonline.org），你看我正在打造社群……</a> 不仅如此，我还帮很多人打造社群。</p><p>不用，学它干嘛？这与我读书的原则也是相通的：不用认真读的书，读它干嘛？这与我对生活的态度也是一样的，既然活着，就要活好，活得精彩。</p><h2 id="八"><a href="#八" class="headerlink" title="(八)"></a>(八)</h2><p>暂时用不起来怎么办？教！我总是重复这句话：</p><blockquote><p>教是最好的学习方法。</p></blockquote><p>把你学到的，总结好的，琢磨清楚的那些知识（不是胡说八道的那些东西）传递出去，分享给你身边的人。“教”，不一定非要像老师一样在课堂上给一帮学生讲（还不允许他们打断）……“教” 可以有很多种形式，比如，“分享”，就是 “教” 的一种形式。在饭桌上都可以进行：</p><p>“我最近读到一个新的概念，特震撼：三度影响力…… 原来肥胖症居然在某种程度上是可以传染的！”</p><p>如果你的朋友对此感兴趣，那你就要再仔细一点说明其机理，其作用，甚至用更多的来自自己身边的例子去讲解。在一来二去的交谈中，你会发现自己也还有很多没弄明白的地方，还有很多地方需要更准确的陈述，需要更精彩、更令人信服、惊叹的论据…… 怎么办？回来改进呗，下次在另外一个饭桌上再演练一次……</p><p>所以，我也总是分享这个道理：</p><blockquote><p>分享，不仅需要能力支撑，也是培养能力的最重要手段。知识分享，没有成本，只有收益 —— 双方都有的收益。</p></blockquote><p>分享的技巧很简单：</p><blockquote><ol><li>真诚，只分享自己确实觉得好的东西；</li><li>也是真诚，绝对不能居高临下地装蛋；</li><li>还是真诚，对方完全有可能不理解你。</li></ol></blockquote><h2 id="九"><a href="#九" class="headerlink" title="(九)"></a>(九)</h2><p>还没完！别忘了问自己这个最重要的问题：</p><p>这个概念、这个方法论、这个道理、这个知识，还可以用在什么地方？</p><p>这是让你真正培养融会贯通能力的方式。所谓的聪明就是这么来的：脑子里有足够多清晰正确的概念与方法论，然后它们之间还有正确应有的关联…… 所以聪明的操作系统总是有更多的想法、更多的方案、更多的可能性。</p><p>万一想到了可以 “出其不意” 地使用的场景，那就赚大了，因为同样的东西到了你的手里却发挥了不一样的作用，你当然与众不同，也只能与众不同。</p><h2 id="十"><a href="#十" class="headerlink" title="(十)"></a>(十)</h2><p><strong>与喜欢学习的人泡在一起</strong> —— 这一点真的特别重要(当然跟喜欢的人在一起共同学习提高了啦(手动艾特某人))。潜移默化的力量是非常大的，与喜欢学习的人在一起，正面的影响力很大；与不喜欢学习的人在一起，负面的影响力不仅很大也很可怕。</p><p>寻找那些终生学习的人，把他们当作朋友，把他们当作榜样。</p><p>网络时代有个好处，这种人虽然身边并不多见，但网络上却很常见。为什么呢？网络消灭了地域的限制，甚至消灭了语言的限制。我就有个很长期的榜样：Bruce Eckel。我根本不认识他，也没有过任何传统意义上的交往，连 email 往来都没有。他是 Thinking In C++ 的作者。十多年前，他在网上发布 Thinking In C++ 第一版的写作计划，然后以极快的速度更新完成…… 毫无疑问，见识到有人这样，就成了后来我写书的时候 “雷厉风行” 的根本原因和动力。再反过来说，人家写书都可以这样，我们读书怎么可以拖拖拉拉呢？</p><blockquote><p>转载: <a href="https://www.ycjcl.cc/" target="_blank" rel="noopener">信鑫-King’s Blog</a>&gt;&gt;<a href="https://www.ycjcl.cc/2016/01/22/ru-he-zhen-zheng-xiao-hua-ben-shu-zhuan-zi-36kr/" target="_blank" rel="noopener">如何真正消化一本书？(转自36Kr)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是李笑来正在预售的《七年就是一辈子》中的内容，略经 36 氪编辑。作者李笑来的微信公众号为 “学习学习再学习（xiaolai-xuexi）”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书大抵上分为两种：虚构类（Fiction），非虚构类（Non-Fiction）。读非虚构类的书籍，是为了获取新知识，并应用到生活中，让自己获得进步；就我个人而言，我更喜欢看非虚构类的书籍，从中获得的愉悦，感觉更大，因为那种愉悦通常有更为坚实的支撑 —— 进步。而虚构类的书籍，在大学毕业之后已经很少读了，可能是因为我自己在那里很难体会到太多的乐趣，更可能的另外一个原因是我已经彻底把获取那种愉悦的途径转移到了影视作品上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="book" scheme="https://joewt.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>swoole安装</title>
    <link href="https://joewt.com/2018/04/13/swoole-install/"/>
    <id>https://joewt.com/2018/04/13/swoole-install/</id>
    <published>2018-04-13T02:08:51.000Z</published>
    <updated>2018-10-19T07:09:33.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>各个环境下有所区别，我使用的是mac系统，首先说的是mac系统下的安装  </p><p>mac系统 自带的有php，这里并不用自带的。使用mamp,php的目录在如下的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/mamp/bin/php</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="noopener">swoole</a></p><p>下载最新的版本即可</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完解压后，目录下会有一个make.sh 这是个简易的安装脚本<br>需要改下phpize，改成mamp下的phpize，在<code>/Applicatons/mamp/bin/php/php7.xxx/bin/</code>目录下<br>./configure 有一些编译参数，根据自己的情况而定<br><a href="https://wiki.swoole.com/wiki/page/437.html" target="_blank" rel="noopener">这里查看</a></p><p>之后执行脚本即可</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装成功后，修改php.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=swoole.so</span><br></pre></td></tr></table></figure></p><p>之后通过php -m 查看扩展是否安装成功,使用mamp下的php命令</p><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><p>一个官方的案例–创建TCP服务器<br>server.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建Server对象，监听 127.0.0.1:9501端口</span><br><span class="line">$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501); </span><br><span class="line"></span><br><span class="line">//监听连接进入事件</span><br><span class="line">$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123;  </span><br><span class="line">    echo &quot;Client: Connect.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听数据接收事件</span><br><span class="line">$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123;</span><br><span class="line">    $serv-&gt;send($fd, &quot;Server: &quot;.$data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听连接关闭事件</span><br><span class="line">$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123;</span><br><span class="line">    echo &quot;Client: Close.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//启动服务器</span><br><span class="line">$serv-&gt;start();</span><br></pre></td></tr></table></figure></p><p><img src="http://img.hnitoj.cn/swoole-install-finish.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;各个环境下有所区别，我使用的是mac系统，首先说的是mac系统下的安装  &lt;/p&gt;
&lt;p&gt;mac系统 自带的有php，这里并不用自带的。使用mamp,php的目录在如下的目录下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/Applications/mamp/bin/php&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swoole" scheme="https://joewt.com/categories/Swoole/"/>
    
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
      <category term="swoole" scheme="https://joewt.com/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局</title>
    <link href="https://joewt.com/2018/03/07/css-layout/"/>
    <id>https://joewt.com/2018/03/07/css-layout/</id>
    <published>2018-03-07T14:06:10.000Z</published>
    <updated>2018-10-19T07:09:33.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h3><ul><li>CSS知识体系的重中之重</li><li>早期以table为主（简单）  </li><li>后来以技巧性布局为主（难）</li><li>现在有flexbox/grid（偏简单）</li><li>响应式布局是必备知识</li></ul><h3 id="常用布局方法"><a href="#常用布局方法" class="headerlink" title="常用布局方法"></a>常用布局方法</h3><ul><li>table 表格布局</li><li>float 浮动+margin</li><li>inline-block 布局</li><li>flexbox 布局</li></ul><a id="more"></a><h3 id="布局属性"><a href="#布局属性" class="headerlink" title="布局属性"></a>布局属性</h3><p>盒子模型<br><img src="http://img.hnitoj.cn/hz.png" alt=""> </p><h4 id="设置布局的两个基本属性-display-position"><a href="#设置布局的两个基本属性-display-position" class="headerlink" title="设置布局的两个基本属性 display/position"></a>设置布局的两个基本属性 display/position</h4><ul><li>确定元素的显示类型<ul><li>block(块级元素)/inline(内联元素或者叫行内元素)/inline-block(行内块级元素)</li></ul></li><li>确定元素位置<ul><li>static/relative/absolute/fixed</li></ul></li></ul><p>position:   </p><ul><li>relative: 根据元素原来的位置进行偏移</li><li>absolute: 脱离文档流，不会对其他元素造成影响 相对于最近的 absolute或relative进行偏移</li><li>fixed: 脱离文档流，是相对于屏幕 可视区域 固定的</li></ul><p>z-index: 定义层级 设置谁显示在最上方，越大就越在最上，对设置了relative,absolute,fixed的有用</p><h3 id="flexbox布局"><a href="#flexbox布局" class="headerlink" title="flexbox布局"></a>flexbox布局</h3><ul><li>弹性盒子</li><li>盒子本来就是并列的</li><li>指定宽度即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.flex &#123;</span><br><span class="line">  flex: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果想设置固定的宽度</span><br><span class="line">.xxx &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  flex: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;flex&quot;&gt;</span><br><span class="line">      xxxx</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h3><ul><li>元素浮动</li><li>脱离文档流</li><li>但不会脱离文本流</li></ul><h5 id="float"><a href="#float" class="headerlink" title="float"></a>float</h5><ul><li><p>对自身的影响</p><ul><li>形成“块” （BFC）</li><li>位置尽量靠上</li><li>位置尽量靠左(右) 在靠上的前提下</li></ul></li><li><p>对兄弟的影响</p><ul><li>上面贴非float元素</li><li>旁边贴float元素</li><li>不影响其他块级元素位置</li><li>影响其他块级元素内部文本</li></ul></li><li><p>对父级元素的影响</p><ul><li>从布局上“消失”</li><li>高度塌陷</li></ul></li><li><p>清除浮动</p><ul><li>overflow: hidden(auto)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container2::after&#123;</span><br><span class="line">           content: &apos;ffff&apos;;</span><br><span class="line">           clear: both;</span><br><span class="line">           display: block;</span><br><span class="line">           height: 0;</span><br><span class="line">           visibility: hidden;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2栏布局"><a href="#2栏布局" class="headerlink" title="2栏布局"></a>2栏布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: 800px;</span><br><span class="line">            height: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: blue;</span><br><span class="line">            float: left;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: 200px;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">            left</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">            right</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="3栏布局"><a href="#3栏布局" class="headerlink" title="3栏布局"></a>3栏布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .container&#123;</span><br><span class="line">        width: 800px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        background: blue;</span><br><span class="line">        float: left;</span><br><span class="line">        height: 100%;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        background: red;</span><br><span class="line">        float: right;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .middle&#123;</span><br><span class="line">        margin-left: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">        left</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">            right</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        middle</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h2&gt;&lt;h3 id=&quot;CSS-布局&quot;&gt;&lt;a href=&quot;#CSS-布局&quot; class=&quot;headerlink&quot; title=&quot;CSS 布局&quot;&gt;&lt;/a&gt;CSS 布局&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CSS知识体系的重中之重&lt;/li&gt;
&lt;li&gt;早期以table为主（简单）  &lt;/li&gt;
&lt;li&gt;后来以技巧性布局为主（难）&lt;/li&gt;
&lt;li&gt;现在有flexbox/grid（偏简单）&lt;/li&gt;
&lt;li&gt;响应式布局是必备知识&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用布局方法&quot;&gt;&lt;a href=&quot;#常用布局方法&quot; class=&quot;headerlink&quot; title=&quot;常用布局方法&quot;&gt;&lt;/a&gt;常用布局方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;table 表格布局&lt;/li&gt;
&lt;li&gt;float 浮动+margin&lt;/li&gt;
&lt;li&gt;inline-block 布局&lt;/li&gt;
&lt;li&gt;flexbox 布局&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS学习" scheme="https://joewt.com/categories/CSS%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="https://joewt.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>进程控制(八)</title>
    <link href="https://joewt.com/2018/02/12/progress-control/"/>
    <id>https://joewt.com/2018/02/12/progress-control/</id>
    <published>2018-02-12T13:44:44.000Z</published>
    <updated>2018-10-19T07:09:33.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本章主要介绍了UNIX系统的进程控制</p><ul><li>创建新进程、执行程序和进程终止</li><li>进程属性的各种ID，他们如何受到进程控制原语的影响</li><li>解释器文件和system函数</li><li>进程会计机制</li></ul><a id="more"></a><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整数表示的唯一进程ID，该ID唯一，但进程ID是可以复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。防止将新进程误认为是使用同一ID的某个已终止的先前进程。<br>一些专用进程  </p><ul><li>ID为0，通常是调度进程，也被称为交换进程。</li><li>ID为1，通常是init进程，在自举过程结束时由内核调用。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件(/etc/rc*或/etc/inittab或/etc/init.d文件)。并将系统引导到一个状态(如多用户)。init进程决不会终止。它是一个普通的用户进程(不是内核中的系统进程)，但是它以超级用户特权运行。</li><li>某些UNIX的虚拟存储器实现中，进程ID2是页守护进程(page daemon)，此进程负责支持虚拟存储器系统的分页操作。</li></ul><p>除了进程ID，每个进程还有一些其他标识符。下列函数返回这些标识符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t getpid(void);     //调用进程的进程ID</span><br><span class="line">pid_t getppid(void);    //调用进程的父进程ID</span><br><span class="line">pid_t getuid(void);     //调用进程的实际用户ID</span><br><span class="line">pid_t geteuid(void);    //调用进程的有效用户ID</span><br><span class="line">pid_t getgid(void);     //调用进程的实际组ID</span><br><span class="line">pid_t getegid(void);    //调用进程的有效组ID</span><br></pre></td></tr></table></figure></p><h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有的进程可以调用fork函数创建一个新进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">//返回值：子进程返回0，父进程返回子进程ID；若出错返回-1</span><br></pre></td></tr></table></figure></p><p>由fork创建的新进程被称为子进程(child process)。fork函数被调用一次，但返回两次。子进程返回0，父进程返回子进程的进程ID。   </p><p>父进程返回子进程的ID的原因：  </p><ul><li>因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。  </li></ul><p>子进程返回0的原因：</p><ul><li>一个进程只会有一个父进程，所以子进程总是可以调用getppid以获取其父进程的进程ID(进程ID0总是由内核交换程序使用，所以一个子进程的进程ID不可能为0)  </li></ul><p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间。父进程和子进程共享正文段<br>由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全副本。作为替代，使用了写时复制技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int globvar = 6;</span><br><span class="line">char buf[] = &quot;a write to stdout\n&quot;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int     var;</span><br><span class="line">    pid_t   pid;</span><br><span class="line"></span><br><span class="line">    var = 99;</span><br><span class="line">    if (write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)</span><br><span class="line">        err_sys(&quot;write error&quot;);</span><br><span class="line">    printf(&quot;before fork\n&quot;);</span><br><span class="line">    if((pid = fork())&lt;0) &#123;</span><br><span class="line">        err_sys(&quot;fork error&quot;);</span><br><span class="line">    &#125; else if(pid == 0) &#123;</span><br><span class="line">        printf(&quot;这是子进程:\n&quot;);</span><br><span class="line">        globvar++;</span><br><span class="line">        var++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;这是父进程:\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;pid = %ld, glob = %d, var = %d\n&quot;, (long)getpid(), globvar, var);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.hnitoj.cn/figure8.1.png" alt="figure8.1"><br>一般来说子进程和父进程的执行顺序是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程间通信。在上面的程序中父进程使进程休眠2s，以使子进程先执行。但不保证2s足够，第二次 的结果父进程并没有休眠2s。父进程先执行了。在10章将会说明在fork之后如何使用信号使父进程和子进程同步。<br>当写标准输出时，我们将buf长度减1作为输出字节数，这是为了避免将终止null字节写出。strlen计算不包含终止null字节的字符串长度，而sizeof计算包括终止null字节的缓冲区长度。两者之间的另一个区别是，使用strlen需进行一次函数调用，而对于sizeof而言，因为缓冲区已用已知字符串进行初始化，其长度是固定的，所以sizeof是在编译时计算缓冲区长度。  </p><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>对图中程序注意的另一点是：在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了dup函数。父进程和子进程每个相同的打开描述符共享一个文件表项(如下图所示)。<br><img src="http://img.hnitoj.cn/figure3.9.png" alt=""><br>考虑下述情况，一个进程具有3个不同的打开文件，它们是标准输入、标准输出和标准错误。在从fork返回时，我们有了如下图中所示的结构。<br><img src="http://img.hnitoj.cn/figure8.2.png" alt=""><br>父进程和子进程共享同一个文件偏移量。考虑如下情况:  </p><ul><li>一个进程fork了一个子进程，然后等待子进程终止。假定，作为普通处理的一部分，父进程和子进程都向标准输出进行写操作。如果父进程的标准输出已重定向(很可能是由shell实现的)，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。在这个例子中，当父进程等待子进程时，子进程写到标准输出；而在子进程终止后，父进程也写到标准输出上，并且知道其输出会追加在子进程所写数据之后。如果父进程和子进程不共享同一文件偏移量，要实现这种形式的交互就要困难很多，可能需要父进程显示地动作。</li><li>如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步(如使父进程等待子进程)，那么他们的输出就会相互混合(假定所用的描述符是在fork之前打开的)。虽然这种情况是可能发生的，但这并不是常见的操作模式。  </li></ul><p>在fork之后处理文件描述符有以下两种常见的情况。</p><ol><li>父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新。</li><li><p>父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，父进程和子进程各自关闭它们不需要使用的文件描述符，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程经常使用的。<br> 除了打开文件之外，父进程的很多其他属性也有子进程继承，包括:</p><ul><li>实际用户ID、实际组ID、有效用户ID、有效组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>终端控制</li><li>设置用户ID标志和设置组ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>信号屏蔽和安排</li><li>对任一打开描述符的执行时关闭(close-on-exec)标志</li><li>环境</li><li>连接的共享存储段</li><li>存储映像</li><li><p>资源限制  </p><p>父进程和子进程之间的具体区别如下:</p></li><li>fork的返回值不同</li><li>进程ID不同</li><li>这两个进程的父进程ID不同:子进程的父进程ID是创建它的进程的ID，而父进程的父进程ID则不变</li><li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0(在下面的小结中介绍)</li><li>子进程不继承父进程设置的文件锁</li><li>子进程的未处理闹钟被清除</li><li>子进程的未处理信号集设置为空集</li></ul></li></ol><p>使fork失败的两个主要原因是:</p><ol><li>系统中已经有了太多的进程(通常意味着某个方面出了问题)</li><li>该实际用户ID的进程总数超过了系统限制(CHAILD_MAX规定了每个实际用户ID在任意时刻可拥有的最大进程数)  </li></ol><p>fork有以下两种用法  </p><ol><li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的—父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程批处理此请求。父进程则继续等待下一个服务请求</li><li>一个进程要执行一个不同的程序。这对shell是最常见的。在这种情况下，子进程从fork返回后立即调用exec  </li></ol><p>某些系统将第二种用法中的两个操作(fork之后执行exec)组合成一个操作，称为spawn。UNIX系统将这两个操作分开，因为在很多场合需要单独使用fork，其后并不跟随exec。另外，将这两个操作分开，使得子进程在fork和exec之间可以更改自己的属性，如I/O重定向、用户ID。信号安排等。在第15章有更多的例子。  </p><h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同，但两者的语义不同。  </p><ul><li>可移植的应用程序不应该使用这个函数</li></ul><p>vfork和fork的区别:  </p><ul><li>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec(或exit)，于是也就不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。这种优化工作方式在某些UNIX系统中提高了工作效率，但如果子进程修改数据、进行函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果。  </li><li>vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。(如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁)  </li></ul><h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>如第7章所述，进程有5种正常终止及3种异常终止方式。<br>5种正常终止方式具体如下:</p><ol><li>在main函数内执行return函数。等效于exit</li><li>调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序(终止处理程序在调用atexit函数时登记)，然后关闭所有标准I/O流等。因为ISO C并不处理文件描述符、多进程以及作业控制，所以这一定义对UNIX系统而言是不完整的。</li><li>调用_exit或_Exit函数。ISO C定义_Exit,其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗，这取决于实现。在UNIX系统中，<code>_Exit</code>和<code>_exit</code>是同义的，并不冲洗标准I/O流。<code>_exit</code>函数由<code>exit</code>调用。<code>_exit</code>函数由<code>exit</code>调用，它处理UNIX系统特定的细节。<code>_exit</code>是由POSIX.1说明的。  </li><li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。</li><li>进程的最后一个线程调用pthread_exit函数，在这种状态下，进程终止状态总是0，这与传递给pthread_exit的参数无关。</li></ol><p>3种异常终止具体如下:</p><ol><li>调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例。</li><li>当进程接收到某种信号时。信号可由进程自身(如调用abort函数)、其他进程或内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生相应的信号。</li><li>最后一个线程对“取消”请求作出响应。默认情况下，“取消”以延迟方式发生:一个线程要求取消另一个线程，若干时间之后，目标线程终止  </li></ol><p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。对于上述任意一种终止情形，我们希望终止进程能够通知其父进程它是如何终止的:  </p><ul><li>对于3个终止函数(exit,<code>_exit</code>,<code>_Exit</code>),实现这一点的方法是，将其退出状态(exit status)作为参数传递给函数。</li><li>在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的终止状态。</li><li>在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态  </li></ul><p>如果父进程在子进程之前终止:</p><ul><li>对于父进程已经终止的所有进程，它们的父进程都改为init进程。我们称这些进程由init进程收养。其操作过程:<ul><li>在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1.这种处理方法保证了每个进程有有一个父进程。</li></ul></li></ul><p>如果子进程在父进程之前终止:</p><ul><li>内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。</li></ul><p>一个由init进程收养的进程终止时会发生什么:</p><ul><li>init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。防止了在系统中塞满僵尸进程。</li></ul><h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。子进程终止是一个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。<br>调用wait或waitpid会发生什么:  </p><ol><li>如果其所有子进程都还在运行，则阻塞。</li><li>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li><li>如果它没有任何子进程，则立即出错返回。</li></ol><p>如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在随机时间点调用wait，则进程可能会阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">pid_t wait(int *statloc);</span><br><span class="line">pid_t waitpid(pid_t pid, int *statloc, int options);</span><br><span class="line">//成功，返回进程ID；出错返回0或-1</span><br></pre></td></tr></table></figure></p><p>两个函数的区别:</p><ul><li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞。</li><li>waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。  </li><li>如果子进程已经终止，并且是一个僵尸进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。</li><li>如调用者阻塞而且它有多个子进程，则在其某一个进程终止时，wait就立即返回。</li><li>因为wait返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。</li></ul><p>对于statloc参数:</p><ul><li>statloc是一个整形指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将参数指定为空指针。</li></ul><p>POSIX.1 定义了waitpid函数,函数中pid参数说明如下:</p><ul><li>pid == -1   等待任一子进程。此种情况下，waitpid与wait等效</li><li>pid &gt; 0     等待进程ID与pid相等的子进程</li><li>pid == 0    等待组ID等于调用进程组ID的任一子进程</li><li>pid &lt; -1    等待组ID等于pid绝对值的任一子进程  </li></ul><p>waitpid和wait出错返回</p><ul><li>waitpid函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由statloc指向的存储单元中。对于wait。</li><li>wait，其唯一的出错是调用进程没有子进程。而waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错。</li></ul><p>options参数或者是0，或者是如下图中常量按位或运算的结果:  </p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">WCONTINUED</td><td style="text-align:left">若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态(POSIX.1的XSI扩展)</td></tr><tr><td style="text-align:left">WNOHANG</td><td style="text-align:left">若由pid指定的子进程并不是理解可用的，则waitpid不阻塞，此时其返回值为0</td></tr><tr><td style="text-align:left">WUNTRACED</td><td style="text-align:left">若某实现支持作业控制，而由pid指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应于一个停止的子进程</td></tr></tbody></table><p>waitpid函数提供了wait函数没有提供的3个功能。  </p><ol><li>waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。</li><li>waitpid提供了一个wait的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞</li><li>waitpid通过WUNTRACED和WCONTINUED选项支持作业控制</li></ol><p>fork两次避免僵尸进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    if ((pid = fork())&lt;0)&#123;</span><br><span class="line">        err_sys(&quot;fork error&quot;);</span><br><span class="line">    &#125; else if (pid == 0)&#123;</span><br><span class="line">        //子进程</span><br><span class="line">        if ((pid = fork()) &lt; 0)</span><br><span class="line">            err_sys(&quot;fork error&quot;);</span><br><span class="line">        else if (pid &gt; 0)  //子进程 或 孙进程的父进程</span><br><span class="line">            exit(0);</span><br><span class="line"></span><br><span class="line">        //孙进程</span><br><span class="line">        sleep(2);</span><br><span class="line">        //打印孙进程的 父ID</span><br><span class="line">        printf(&quot;second child, parent pid = %ld\n&quot;,(long)getppid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //父进程</span><br><span class="line">    if (waitpid(pid, NULL, 0) != pid)</span><br><span class="line">        err_sys(&quot;waitpid error&quot;);</span><br><span class="line"></span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://img.hnitoj.cn/figure8.8.png" alt=""><br>孙进程(用了更加形象的描述，原书中是第二个子进程)调用sleep以保证在打印其父ID时子进程已终止。在fork之后，父进程和子进程都可继续执行，并且我们无法预知哪一个会先执行。在fork之后，如果不使孙进程休眠，那么它可能比其父进程(也就是子进程)先执行，于是它打印的父进程ID将是创建它的父进程，而不是init进程(进程ID1)。  </p><h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>waitid类似于waitpid，但更加灵活<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</span><br><span class="line">//成功，返回0；出错，返回-1</span><br></pre></td></tr></table></figure></p><p>该函数与waitpid类似，waitid允许一个进程指定要等待的子进程。<br>id参数的作用与idtype的值相关，idtype类型在下表中  </p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">P_PID</td><td style="text-align:left">等待一特定进程：id包含要等待子进程的进程ID</td></tr><tr><td style="text-align:left">P_PGID</td><td style="text-align:left">等待一特定进程组的任一子进程：id包含要等待子进程的进程组ID</td></tr><tr><td style="text-align:left">P_ALL</td><td style="text-align:left">等待任一子进程：忽略id</td></tr></tbody></table><p>options参数是如下图中个标志的按位或运算  </p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">WCONTINUED</td><td style="text-align:left">等待一进程，它以前曾被停止，此后又继续，但其状态尚未报告</td></tr><tr><td style="text-align:left">WEXITED</td><td style="text-align:left">等待已退出的进程</td></tr><tr><td style="text-align:left">WNOHANG</td><td style="text-align:left">如无可用的子进程退出状态，立即返回而非阻塞</td></tr><tr><td style="text-align:left">WNOWAIT</td><td style="text-align:left">不破坏子进程退出状态。该子进程退出状态可由后续的wait、waitid或waitpid调用取得</td></tr><tr><td style="text-align:left">WSTOPPED</td><td style="text-align:left">等待一进程，它已经停止，但其状态尚未报告</td></tr></tbody></table><p>infop参数是指向siginfo结构的指针。该结构包含了造成子进程状态改变有关信号的详细信息。  </p><h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>这俩函数比上面3个函数提供的功能多一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line">pid_t wait3(int *statloc, int options, struct rusage *rusage);</span><br><span class="line">pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);</span><br><span class="line">//成功，返回进程ID；失败，返回-1</span><br></pre></td></tr></table></figure></p><p>返回的信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。  </p><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>竞争发生的原因：当多个进程都企图对共享数据进行某种处理，而最后结果又取决于进程运行的顺序时。<br>在上一小节中的程序。当孙进程打印其父ID时，有一个潜在的竞争条件:  </p><ul><li>如果孙进程在子进程之前运行，孙进程的父进程就是子进程。但是如果子进程先运行，并有足够的时间到达并执行exit，则孙进程的父进程就是init。</li></ul><p>如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止，则可使用下列形式的循环  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (getppid() != 1)</span><br><span class="line">    sleep(1);</span><br></pre></td></tr></table></figure><p>这种形式的循环称为轮询(polling),它的问题是浪费CPU时间，因为调用者每隔1S都被唤醒，然后进行条件测试。<br>为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制(第10章会介绍),进程间通信在15、17章介绍。  </p><h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。  </p><p>7种不同的exec函数原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);</span><br><span class="line">int execv(const char *pathname, char *const argv[]);</span><br><span class="line">int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */);</span><br><span class="line">int execve(const char *pathname, char *const argv[], char *const envp[]);</span><br><span class="line">int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);</span><br><span class="line">int execvp(const char *filename, char *const argv[]);</span><br><span class="line">int fexecve(int fd, char *const argv[], char *const envp[]);</span><br><span class="line">//出错返回-1，成功不返回</span><br></pre></td></tr></table></figure><p>这些函数的区别如下:</p><ul><li>前4个函数取路径名作为参数，后2个函数取文件名作为参数，最后一个取文件描述符作为参数。当指定filename作为参数时<ul><li>如果filename 中包含 /, 则就将其视为路径名</li><li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件</li></ul></li><li>PATH变量包含了一张目录表，如下所示:最后的路径前缀.表示当前目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/bin:/usr/bin:/usr/local/bin:.</span><br></pre></td></tr></table></figure></li></ul><p>出于安全性考虑在搜索路径中决不要包括当前目录  </p><ul><li>如果execlp或execvp使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的机器可执行文件，则就认为该文件是一个可执行文件，于是试着调用/bin/sh,并以该filename作为shell的输入</li><li>fexecve函数依赖调用进程，调用进程可以使用文件描述符验证所需要的文件并且无竞争地执行该文件</li></ul><p>另一个区别与参数表有关:  </p><ul><li>函数execl、execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数(execv,execvp,execve和fexecve),则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数。</li></ul><p>最后一个区别</p><ul><li>以e结尾的3个函数(execle、execve和fexecve)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境。通常，一个进程允许将其环境传播给其子进程，但有时也有这种情况，进程想要为子进程指定某一个确定的变量。例如，在初始化一个新登录shell时，login程序通常创建一个只定义少数几个变量的特殊环境，而我们在登录时，可以通过shell启动文件，将其他变量加到环境中。  <ul><li>在ISO C原型中，所有命令行参数、空指针和envp指针都用省略号(…)表示</li></ul></li></ul><p>POSIX.1 要求在exec时关闭打开目录流。这通常是由opendir函数实现的，它调用fcntl函数为对应于打开目录流的描述符设置执行时关闭标志。<br>在很多UNIX实现中，这7个函数中只有execve是内核的系统调用。其他6个只是函数库，他们最终都要调用该系统调用  </p><hr><h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中，特权以及访问控制，是基于用户ID和组ID的。所以我们需要合适的权限访问资源<br>setuid函数设置实际用户ID和有效用户ID,setgid函数设置实际组ID和有效组ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int setuid(uid_t uid);</span><br><span class="line">int setgid(gid_t gid);</span><br><span class="line">//成功返回0，出错返回-1</span><br></pre></td></tr></table></figure></p><ul><li>若进程具有超级用户权限，则setuid函数将实际用户ID，有效用户ID以及保存的设置用户ID(saved set-user-ID)设置为uid。</li><li>若进程没有超级用后权限，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID</li><li>如果都不满足，则errno设置为EPERM，并返回-1  </li></ul><p>(未完待续)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本章主要介绍了UNIX系统的进程控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建新进程、执行程序和进程终止&lt;/li&gt;
&lt;li&gt;进程属性的各种ID，他们如何受到进程控制原语的影响&lt;/li&gt;
&lt;li&gt;解释器文件和system函数&lt;/li&gt;
&lt;li&gt;进程会计机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>常用的命令总结及各种实用工具</title>
    <link href="https://joewt.com/2018/02/11/decompression/"/>
    <id>https://joewt.com/2018/02/11/decompression/</id>
    <published>2018-02-11T12:48:31.000Z</published>
    <updated>2018-12-03T06:23:47.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令和工具"><a href="#常用命令和工具" class="headerlink" title="常用命令和工具"></a>常用命令和工具</h1><ul><li>gdb</li><li>zip tar</li><li>find</li><li>ldd</li><li>lsof</li><li>ps </li><li>pstack</li><li>strace</li><li>ipcs</li><li>top</li><li>free</li><li>vmstat</li><li>iostat</li><li>sar</li><li>readelf</li><li>objdump</li><li>nm</li><li>size</li></ul><a id="more"></a><h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如果要使用gdb对 c/c++ 进行调试 需要在编译选项上加 -g   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o main main.c</span><br></pre></td></tr></table></figure><p>然后使用如下命令使用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb main &lt;core.xxx&gt;</span><br></pre></td></tr></table></figure><p>core文件是程序非法执行后产生的 core dump 文件  </p><h2 id="core-dump"><a href="#core-dump" class="headerlink" title="core dump"></a>core dump</h2><p>/etc/profile 下添加<br>ulimit -S -c unlimited &gt; /dev/null 2&gt;&amp;1</p><p>/etc/sysctl.conf 添加<br>kernel.core<em>pattern = ./core</em>%t<em>%p</em>%e<br>kernel.core_uses_pid = 1</p><h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><ul><li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li>until+行号： 运行至某行，不仅仅用来跳出循环</li><li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call  gdb_test(55)</li><li>quit：简记为 q ，退出gdb</li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul><li>break n （简写b n）:在第n行处设置断点<pre><code>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</code></pre></li><li>b fn1 if a＞b：条件断点设置</li><li>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</li><li>delete 断点号n：删除第n个断点</li><li>disable 断点号n：暂停第n个断点</li><li>enable 断点号n：开启第n个断点</li><li>clear 行号n：清除第n行的断点</li><li>info b （info breakpoints） ：显示当前程序的断点设置情况</li><li>delete breakpoints：清除所有断点：</li></ul><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><ul><li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li><li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li><li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li></ul><h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><ul><li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li><li>print a：将显示整数 a 的值</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li><li>whatis ：查询变量或函数</li><li>info function： 查询函数</li><li>扩展info locals： 显示当前堆栈页的所有变量</li></ul><h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><ul><li>where/bt ：当前运行的堆栈列表；</li><li>bt backtrace 显示当前调用堆栈</li><li>up/down 改变堆栈显示的深度</li><li>set args 参数:指定运行时的参数</li><li>show args：查看设置好的参数</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li></ul><h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul><h1 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h1><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r xxx.zip  xxx.c</span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip xxx.zip</span><br></pre></td></tr></table></figure></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>.tar 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf xxx.tar xxx</span><br></pre></td></tr></table></figure></p><p>.tar 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf xxx.tar</span><br></pre></td></tr></table></figure></p><p>.tar.gz 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcvf xxx.tar.gz xxx</span><br></pre></td></tr></table></figure></p><p>.tar.gz 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf xxx.tar.gz</span><br></pre></td></tr></table></figure></p><p>.tar.bz2 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -jcvf xxx.tar.gz2 xxx</span><br></pre></td></tr></table></figure></p><p>.tar.bz2 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -jxvf xxx.tar.gz2</span><br></pre></td></tr></table></figure></p><h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><p>.rar 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rar -a xxx.rar xxx</span><br></pre></td></tr></table></figure></p><p>.rar 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rar -x xxx.rar</span><br></pre></td></tr></table></figure></p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>统计代码行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.go&quot; |wc -l</span><br><span class="line">find . -name &quot;*.go&quot; |xargs cat|wc -l</span><br><span class="line">find . -name &quot;*.go&quot; |xargs cat|grep -v ^$|wc -l</span><br></pre></td></tr></table></figure></p><h1 id="资源查看"><a href="#资源查看" class="headerlink" title="资源查看"></a>资源查看</h1><p>查看文件大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du -ah --max-depth=1</span><br></pre></td></tr></table></figure></p><p>监控系统资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1 3</span><br></pre></td></tr></table></figure></p><p>查看内存使用状况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br></pre></td></tr></table></figure><p>查看CPU</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p>判断系统位数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ file /bin/ls</span><br></pre></td></tr></table></figure><p>查看Linux系统发行版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure><h1 id="ldd-查看程序依赖库"><a href="#ldd-查看程序依赖库" class="headerlink" title="ldd 查看程序依赖库"></a>ldd 查看程序依赖库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd main</span><br></pre></td></tr></table></figure><h1 id="strace-跟踪进程调用"><a href="#strace-跟踪进程调用" class="headerlink" title="strace 跟踪进程调用"></a>strace 跟踪进程调用</h1><p>strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间  </p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</span><br><span class="line">-d 输出strace关于标准错误的调试信息.</span><br><span class="line">-f 跟踪由fork调用所产生的子进程.</span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br><span class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</span><br><span class="line">-h 输出简要的帮助信息.</span><br><span class="line">-i 输出系统调用的入口指针.</span><br><span class="line">-q 禁止输出关于脱离的消息.</span><br><span class="line">-r 打印出相对时间关于,,每一个系统调用.</span><br><span class="line">-t 在输出中的每一行前加上时间信息.</span><br><span class="line">-tt 在输出中的每一行前加上时间信息,微秒级.</span><br><span class="line">-ttt 微秒级输出,以秒了表示时间.</span><br><span class="line">-T 显示每一调用所耗的时间.</span><br><span class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</span><br><span class="line">-V 输出strace的版本信息.</span><br><span class="line">-x 以十六进制形式输出非标准字符串</span><br><span class="line">-xx 所有字符串以十六进制形式输出.</span><br><span class="line">-a column</span><br><span class="line">设置返回值的输出位置.默认 为40.</span><br><span class="line">-e expr</span><br><span class="line">指定一个表达式,用来控制如何跟踪.格式如下:</span><br><span class="line">[qualifier=][!]value1[,value2]...</span><br><span class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:</span><br><span class="line">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.</span><br><span class="line">注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</span><br><span class="line">-e trace=set</span><br><span class="line">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</span><br><span class="line">-e trace=file</span><br><span class="line">只跟踪有关文件操作的系统调用.</span><br><span class="line">-e trace=process</span><br><span class="line">只跟踪有关进程控制的系统调用.</span><br><span class="line">-e trace=network</span><br><span class="line">跟踪与网络有关的所有系统调用.</span><br><span class="line">-e strace=signal</span><br><span class="line">跟踪所有与系统信号有关的 系统调用</span><br><span class="line">-e trace=ipc</span><br><span class="line">跟踪所有与进程通讯有关的系统调用</span><br><span class="line">-e abbrev=set</span><br><span class="line">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.</span><br><span class="line">-e raw=set</span><br><span class="line">将指 定的系统调用的参数以十六进制显示.</span><br><span class="line">-e signal=set</span><br><span class="line">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</span><br><span class="line">-e read=set</span><br><span class="line">输出从指定文件中读出 的数据.例如:</span><br><span class="line">-e read=3,5</span><br><span class="line">-e write=set</span><br><span class="line">输出写入到指定文件中的数据.</span><br><span class="line">-o filename</span><br><span class="line">将strace的输出写入文件filename</span><br><span class="line">-p pid</span><br><span class="line">跟踪指定的进程pid.</span><br><span class="line">-s strsize</span><br><span class="line">指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</span><br><span class="line">-u username</span><br><span class="line">以username 的UID和GID执行被跟踪的命令</span><br></pre></td></tr></table></figure><h2 id="几个实例说明"><a href="#几个实例说明" class="headerlink" title="几个实例说明"></a>几个实例说明</h2><p>跟踪可执行程序 并输出到当前文件下 -f -F 表示同时跟踪 fork vfork出来的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strace -f -F -o ./trace.txt ./main</span><br></pre></td></tr></table></figure></p><p>跟踪服务进程,跟踪11111进程的所有系统调用，并统计时间，以及开始时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strace -o output.txt -T -tt -e trace=all -p 11111</span><br></pre></td></tr></table></figure><h1 id="lsof-一切皆文件"><a href="#lsof-一切皆文件" class="headerlink" title="lsof  一切皆文件"></a>lsof  一切皆文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lsof abc.txt //显示开启文件abc.txt的进程</span><br><span class="line">lsof -c abc  //显示abc进程现在打开的文件</span><br><span class="line">lsof -c -p  //1234 列出进程号为1234的进程所打开的文件</span><br><span class="line">lsof -g gid  //显示归属gid的进程情况</span><br><span class="line">lsof +d /usr/local/      //显示目录下被进程开启的文件</span><br><span class="line">lsof +D /usr/local/     //同上，但是会搜索目录下的目录，时间较长</span><br><span class="line">lsof -d 4 //显示使用fd为4的进程</span><br><span class="line">lsof -i //用以显示符合条件的进程情况</span><br></pre></td></tr></table></figure><h2 id="获取-IPv4流量"><a href="#获取-IPv4流量" class="headerlink" title="获取 IPv4流量"></a>获取 IPv4流量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i 4</span><br></pre></td></tr></table></figure><h2 id="仅显示TCP流量"><a href="#仅显示TCP流量" class="headerlink" title="仅显示TCP流量"></a>仅显示TCP流量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -iTCP</span><br></pre></td></tr></table></figure><h2 id="显示指定用户打开了什么"><a href="#显示指定用户打开了什么" class="headerlink" title="显示指定用户打开了什么"></a>显示指定用户打开了什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -u mysql</span><br></pre></td></tr></table></figure><h2 id="杀死指定用户所做的一切事情"><a href="#杀死指定用户所做的一切事情" class="headerlink" title="杀死指定用户所做的一切事情"></a>杀死指定用户所做的一切事情</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 `lsof -t -u nginx`</span><br></pre></td></tr></table></figure><h2 id="查看指定的命令正在使用的文件和网络连接"><a href="#查看指定的命令正在使用的文件和网络连接" class="headerlink" title="查看指定的命令正在使用的文件和网络连接"></a>查看指定的命令正在使用的文件和网络连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -c mysql</span><br></pre></td></tr></table></figure><h2 id="查看指定进程ID已打开的内容"><a href="#查看指定进程ID已打开的内容" class="headerlink" title="查看指定进程ID已打开的内容"></a>查看指定进程ID已打开的内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -p 12356</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote><p>lsof <code>which httpd</code> //那个进程在使用apache的可执行文件<br>lsof /etc/passwd //那个进程在占用/etc/passwd<br>lsof /dev/hda6 //那个进程在占用hda6<br>lsof /dev/cdrom //那个进程在占用光驱<br>lsof -c sendmail //查看sendmail进程的文件使用情况<br>lsof -c courier -u ^zahn //显示出那些文件被以courier打头的进程打开，但是并不属于用户zahn<br>lsof -p 30297 //显示那些文件被pid为30297的进程打开<br>lsof -D /tmp 显示所有在/tmp文件夹中打开的instance和文件的进程。但是symbol文件并不在列<br>lsof -u1000 //查看uid是100的用户的进程的文件使用情况<br>lsof -utony //查看用户tony的进程的文件使用情况<br>lsof -u^tony //查看不是用户tony的进程的文件使用情况(^是取反的意思)<br>lsof -i //显示所有打开的端口<br>lsof -i:80 //显示所有打开80端口的进程<br>lsof -i -U //显示所有打开的端口和UNIX domain文件<br>lsof -i UDP@[url]www.akadia.com:123 //显示那些进程打开了到www.akadia.com的UDP的123(ntp)端口的链接<br>lsof -i tcp@ohaha.ks.edu.tw:ftp -r //不断查看目前ftp连接的情况(-r，lsof会永远不断的执行，直到收到中断信号,+r，lsof会一直执行，直到没有档案被显示,缺省是15s刷新)<br>lsof -i tcp@ohaha.ks.edu.tw:ftp -n //lsof -n 不将IP转换为hostname，缺省是不加上-n参数  </p></blockquote><h1 id="进程间通信ipcs"><a href="#进程间通信ipcs" class="headerlink" title="进程间通信ipcs"></a>进程间通信ipcs</h1><p>ipcs是Linux下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息  </p><p>查看 XSI IPC 3种形式的限定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linux系统</span><br><span class="line">$ ipcs -l</span><br><span class="line">FreeBSD系统</span><br><span class="line">$ ipcs -T</span><br><span class="line">Solaris系统</span><br><span class="line">$ sysdef -y</span><br></pre></td></tr></table></figure></p><h1 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h1><p>System Activity Reporter（系统活动情况报告）</p><h1 id="readelf-elf文件分析"><a href="#readelf-elf文件分析" class="headerlink" title="readelf elf文件分析"></a>readelf elf文件分析</h1><p>显示文件头信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h main| grep Machine</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vagrant@ubuntu-xenial:~/php-dev/demo$ readelf -h main.out</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Intel 80386</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x8048310</span><br><span class="line">  Start of program headers:          52 (bytes into file)</span><br><span class="line">  Start of section headers:          6984 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           32 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         36</span><br><span class="line">  Section header string table index: 33</span><br></pre></td></tr></table></figure><h2 id="几个使用方法"><a href="#几个使用方法" class="headerlink" title="几个使用方法"></a>几个使用方法</h2><p>查看应用程序在编译的时候是否加了 -g 选项  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S main| grep debug</span><br></pre></td></tr></table></figure><p>完整输出  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -all main</span><br></pre></td></tr></table></figure><h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>tcpdump抓包工具使用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any tcp port 9501</span><br></pre></td></tr></table></figure><ul><li>-i 绑定的网卡，any表示全部网卡 lo 表示本地的</li><li>tcp 只监听tcp协议</li><li>port 指定端口</li></ul><h2 id="没了"><a href="#没了" class="headerlink" title="没了"></a>没了</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用命令和工具&quot;&gt;&lt;a href=&quot;#常用命令和工具&quot; class=&quot;headerlink&quot; title=&quot;常用命令和工具&quot;&gt;&lt;/a&gt;常用命令和工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;gdb&lt;/li&gt;
&lt;li&gt;zip tar&lt;/li&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;ldd&lt;/li&gt;
&lt;li&gt;lsof&lt;/li&gt;
&lt;li&gt;ps &lt;/li&gt;
&lt;li&gt;pstack&lt;/li&gt;
&lt;li&gt;strace&lt;/li&gt;
&lt;li&gt;ipcs&lt;/li&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;free&lt;/li&gt;
&lt;li&gt;vmstat&lt;/li&gt;
&lt;li&gt;iostat&lt;/li&gt;
&lt;li&gt;sar&lt;/li&gt;
&lt;li&gt;readelf&lt;/li&gt;
&lt;li&gt;objdump&lt;/li&gt;
&lt;li&gt;nm&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux命令" scheme="https://joewt.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://joewt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>进程环境(七)</title>
    <link href="https://joewt.com/2018/02/08/Progress-env/"/>
    <id>https://joewt.com/2018/02/08/Progress-env/</id>
    <published>2018-02-08T11:41:49.000Z</published>
    <updated>2018-11-12T10:58:31.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><p>主要介绍了如下内容:</p><ul><li>当程序执行时，其main函数是如何被调用的；</li><li>命令行参数是如何传递给应用程序的；</li><li>典型的存储空间布局是什么样式；</li><li>如何分配另外的存储空间；</li><li>进程如何使用环境变量；</li><li>进程的各种不同终止方式等</li></ul><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><p>main函数:  </p><p> c语言总是从main函数启动的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br></pre></td></tr></table></figure><p> 参数:  </p><ul><li><code>argc</code>: 命令行参数数目</li><li><p><code>argv</code>: 指向各个指针构成的数组  </p><p>当内核执行C语言程序时，在调用main函数前先调用一个特殊的启动例程<br>启动例程:<br>如果目标文件是由C代码编译生成的，用gcc做链接就没错了，整个程序的入口点是crt1.o中提供的_start，它首先做一些初始化工作（以下称为启动例程，Startup Routine），然后调用C代码中提供的main函数。所以，以前我们说main函数是程序的入口点其实不准确，<code>_start</code>才是真正的入口点，而main函数是被_start调用的。</p></li></ul></li></ol><ol><li><p>进程终止</p><p> 有8种方式使进程终止，其中5种是正常终止:</p><ul><li>从main函数返回</li><li>调用exit</li><li>调用_exit和_Exit</li><li>最后一个线程从其启动例程返回</li><li><p>从最后一个线程调用pthread_exit  </p><p>异常终止有3种:</p></li><li>调用abort</li><li>接到一个信号</li><li>最后一个线程对取消请求做出相应</li></ul><ol><li><p>退出函数<br>3个函数用于正常终止一个程序,<code>_exit</code>和_Exit立即进入内核，exit则先执行一些清理处理，然后返回内核。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void exit(int status);</span><br><span class="line">void _Exit(int status);</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure><p>由于历史原因，exit函数总是执行一个标准I/O库的清理关闭操作:对于所有打开流调用fclose函数<br>3个退出函数都带一个整形参数，称为终止状态(退出状态，exit status)</p></li><li><p>atexit函数<br>按照ISO C的规定，一个进程可以登记多至32个函数，这些函数将由exit自动调用。我们称这些函数为终止处理程序(exit handler),并调用atexit函数来登记这些函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int atexit(void (*func)(void));</span><br></pre></td></tr></table></figure><p>返回值:  </p></li></ol><ul><li>成功: 返回0</li><li><p>出错: 返回非0<br>atexit的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回一个值。exit调用这些函数的顺序刚好相反  </p><p>下图说明了一个c语言程序是如何启动和停止的<br><img src="http://img.hnitoj.cn/figure7.2.png" alt=""><br>内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显示或隐式地（通过调用exit）调用_exit或_Exit；进程也可以非自愿地由一个信号终止(如SINGUP、SINGINT等)<br>如下程序说明如何使用atexit函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">static void my_exit1(void);</span><br><span class="line">static void my_exit2(void);</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (atexit(my_exit2) != 0)</span><br><span class="line">        err_sys(&quot;不能注册my_exit2&quot;);</span><br><span class="line">    if (atexit(my_exit1) != 0)</span><br><span class="line">        err_sys(&quot;不能注册my_exit1&quot;);</span><br><span class="line">    if (atexit(my_exit1) != 0)</span><br><span class="line">        err_sys(&quot;不能注册my_exit1&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;main is done\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">static void my_exit1(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;first exit handler\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static void my_exit2(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;second exit handler\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下<br><img src="http://img.hnitoj.cn/figure7.3.png" alt=""></p></li></ul></li></ol><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时，调用exec的进程可将命令行参数传递给该新程序。这是UNIX shell的一部分操作。<br>如下程序将其所有命令行参数都回显到标准输出上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(int argc, char *artv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    for (i=0;i&lt;argc;i++)</span><br><span class="line">        printf(&quot;argv[%d]: %s\n&quot;,i,argv[i]);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://img.hnitoj.cn/figure7.4.png" alt=""></p><h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一个环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的C字符串的地址。全局变量environ包含了该指针数组的地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern char **environ</span><br></pre></td></tr></table></figure></p><p>如果该环境包含5个字符串，那么它看起来就像如下图所示。其中，每个字符串的结尾处都显式地有一个null字符。我们称environ为环境指针，指针数组为环境表，其中个指针指向的字符串为环境字符串。<br><img src="http://img.hnitoj.cn/figure7.5.png" alt=""></p><h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>C程序一直由下列几部分组成:</p><ul><li>正文段。这是由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序(如文本编辑器、C编辑器和shell等)在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外而修改指令。</li><li><p>初始化数据段。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何函数外的声明:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int max = 99;</span><br></pre></td></tr></table></figure><p>  使此变量以其初值存放在初始化数据段中。</p></li><li><p>未初始化数据段。通常将此段称为bss段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”(block started by symbol)，在程序开始执行前，内核将此段中的数据初始化为0或空指针。函数外的声明:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long sum[100];</span><br></pre></td></tr></table></figure><p>  将此变量存放在非初始化数据段中。</p></li><li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息(如某些机器的寄存器的值)都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。通常以这种使用栈，C递归函数可以工作。递归函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量不会影响另一次函数调用实例中的变量。</li><li><p>堆。通常在堆中进行动态存储分配。由于历史上形式惯例，堆位于未初始化数据段h额栈之间。</p><p>  下图显示了一种典型的存储空间安排<br>  <img src="http://img.hnitoj.cn/figure7.6.png" alt=""><br>  对于32位Intelx86处理器上的Linux，正文段从0x08048000单元开始，栈底则在0xC0000000之下开始(在这种特定的结构中，栈从高地址向低地址方向增长)。堆顶和栈顶之间未用的虚拟空间很大  </p><ul><li>a.out中还有若干其他类型的段，如包含符号表的段、包含调试信息的段以及包含动态共享库链接表的段等。这些部分并不装载到进程执行的程序映像中。</li></ul></li></ul><p>size命令报告正文段、数据段和bss段的长度(以字节为单位)，例如<br><img src="http://img.hnitoj.cn/figure7-6.1.png" alt=""></p><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得可执行文件中不在包含公用的库函数，而只需在所有进程都可引用的存储区中保持这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方式将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑(假定参数的数目和类型都没有发生改变)</p><h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数。</p><ol><li>malloc，分配指定字节数的存储区。此存储区中的初始值不确定。</li><li>calloc，为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0。</li><li>realloc，增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void *malloc(size_t size);</span><br><span class="line">void *calloc(size_t mobj, size_t size);</span><br><span class="line">void *realloc(void *ptr, size_t newsize);</span><br><span class="line">// 成功返回非空指针；出错返回NULL</span><br><span class="line"></span><br><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure><ul><li>这3个分配函数返回的指针一定是适当对齐的，使其可用于任何数据对象。例如，在一个特定的系统上，如果最苛刻的对齐要求是，double必须在8的倍数地址单元处开始，那么这3个函数返回的指针都应该这样对齐。</li><li>因为这3个alloc函数都返回通用指针<code>void *</code>,所以如果在程序中包括了#include <stdlib.h>(以获得函数原型)，那么当我们将这些函数返回的指针赋予一个不同类型的指针时，就不需要显式执行强制类型转换。未声明函数的默认返回值为int，所以使用没有正确函数声明的强制类型转换可能会隐藏系统错误，因为int类型的长度与函数返回类型值的长度不同(本例中是指针)。</stdlib.h></li><li>函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池，以后，可在调用上述3个分配函数时再分配。</li><li>realloc函数使我们可以增、减以前分配存储区的长度。  </li><li>这些分配例程通常用sbrk系统调用实现。该系统调用扩充(或缩小)进程的堆</li><li>虽然sbrk可以扩充或缩小进程的存储空间，但是大多数malloc和free的实现都不减少进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核</li><li>如若一个进程调用malloc函数，但却忘记调用free函数，那么该进程占用的存储空间就会连续增加，这被称为泄露</li><li>因为存储空间分配出错很难跟踪，所以某些系统提供了这些函数的另一个实现版本。每次调用这3个分配函数中的任意一个或free时，它们都进行附加的检错。</li></ul><h3 id="替代的存储空间分配函数"><a href="#替代的存储空间分配函数" class="headerlink" title="替代的存储空间分配函数"></a>替代的存储空间分配函数</h3><p>有很多可替代malloc和free的函数。某些系统已经提供替代存储空间分配函数的库。另一些系统只提供标准的存储空间分配程序。如果需要，软件开发者可以下载替代函数。下面讨论某些替代函数和库</p><ol><li>libmalloc<br> 基于SVR4的UNIX系统，如Solaries，包含了libmalloc库，它提供了一套与ISO C存储空间分配函数相匹配的接口。libmalloc库包含mallopt函数，它使进程可以设置一些变量，并用它们来控制存储空间分配程序的操作。还可使用另一个名为mallinfo的函数，以对存储空间分配程序的操作进行统计。</li><li>vmalloc<br> Vo说明一种存储空间分配程序，它允许进程对于不同的存储区使用不同的技术。除了一些vmalloc特有的函数外，该库也提供了ISO C存储空间分配函数的仿真器</li><li><p>quick-fit<br> 历史上所使用的标准malloc算法是最佳适配或首次适配存储分配。quick-fit(快速适配)算法比上述两种算法快，但可能使用较多的存储空间Weinstock和Wulf对该算法进行了描述，该算法基于将存储空间分裂成各种长度的缓冲区，并将未使用的缓冲区按其长度组成不同的空闲区列表。现在许多分配程序都基于快速适配。</p></li><li><p>jemalloc<br> jemalloc函数实现是FreeBSD8.0中默认的存储空间分配程序，它是库函数malloc族在FreeBSD中的实现。它的设计具有良好的扩展性，可用于多处理器系统中使用多线程的应用程序。<a href="https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf" target="_blank" rel="noopener">Evans</a>说明了具体实现及其性能评估。</p></li><li><p>TCMalloc<br> TCMalloc函数用于替代malloc函数族以提供高性能、高扩展性和高存储效率。从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中时，它使用线程-本地高速缓存来避免锁开销。它还有内置的堆检查程序和堆分析程序帮助调试和分析动态存储的使用。</p></li><li><p>函数alloca<br> 还有一个函数，它的调用序列与malloc相同，但是他是在当前函数的栈帧上分配存储空间，而不是在堆中。其优点是：当函数返回时，自动释放它所使用的栈帧，所以不必再为释放空间而费心。其缺点是：alloca函数增加了栈帧的长度，而某些系统在函数已被调用后不能增加栈帧长度，于是也就不能支持alloca函数。尽管如此，很多软件包还是使用alloca函数，也有很多系统实现了该函数。(本系统中的4个平台都提供了)</p></li></ol><p>(未更新完)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程环境&quot;&gt;&lt;a href=&quot;#进程环境&quot; class=&quot;headerlink&quot; title=&quot;进程环境&quot;&gt;&lt;/a&gt;进程环境&lt;/h2&gt;&lt;p&gt;主要介绍了如下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当程序执行时，其main函数是如何被调用的；&lt;/li&gt;
&lt;li&gt;命令行参数是如何传递给应用程序的；&lt;/li&gt;
&lt;li&gt;典型的存储空间布局是什么样式；&lt;/li&gt;
&lt;li&gt;如何分配另外的存储空间；&lt;/li&gt;
&lt;li&gt;进程如何使用环境变量；&lt;/li&gt;
&lt;li&gt;进程的各种不同终止方式等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>标准I/O库(五)</title>
    <link href="https://joewt.com/2018/02/04/std-IO/"/>
    <id>https://joewt.com/2018/02/04/std-IO/</id>
    <published>2018-02-04T09:18:44.000Z</published>
    <updated>2018-02-14T12:35:48.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UNIX一切皆文件，掌握文件的操作尤其重要。以下的内容主要是apue上面第五章内容，介绍了标准I/O库的一些内容。</p><hr><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>标准I/O库，他们的操作都是围绕流进行的<br>字符分为单字节和多字节，流的定向决定了是所读、写的字符是单字节还是多字节的。当一个流被创建时，并没有定向。使用多字节I/O函数，流的定向就被设置为宽定向，单字节同理。只有两个函数可以改变流的定向，freopen和fwide  </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;wchar.h&gt;</span><br><span class="line">int fwide(FILE *fp, int mode);</span><br><span class="line">//若流是宽定向的，返回正值；若流是单字节定向的返回负值，流未定向，返回0</span><br></pre></td></tr></table></figure><p>mode参数的说明  </p><ul><li>mode为负，fwide将使指定的流是单字节定向的</li><li>mode为正，fwide将使指定的流是宽定向的</li><li>mode为0，不设置流的定向，但返回标识该流定向的值</li></ul><hr><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少read和write的调用。<br>标准I/O提供了3种缓冲</p><ol><li>全缓冲。只有填满标准I/O缓冲区后才进行实际的I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作是，相关I/O函数通常调用malloc获得需要的缓冲。</li><li>行缓冲。当在输入输出中遇到换行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(fputc),但只有在写了一行之后才进行实际的I/O操作。当涉及一个终端时(如标准输入和标准输出)，通常使用行缓冲。</li><li>不带缓冲。标准I/O库不对字符进行缓冲存储。例如，若用标准I/O函数fputs写15个字符到不带缓冲的流中，我们就期望这15个字符能立即输出，就很有可能使用write函数将这些字符写到相关联的打开文件中。</li></ol><p>标准错误流stderr通常是不带缓冲的。<br>ISO C要求下列缓冲特征</p><ul><li>当且仅当标准输入和标准输出并不指向交互设备时，他们才是全缓冲的</li><li>标准错误绝不是全缓冲的</li></ul><p>很多系统默认使用下列类型的缓冲</p><ul><li>标准错误是不带缓冲的</li><li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的</li></ul><p>如果不喜欢系统默认的可使用下列两个函数中的一个更改缓冲类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdiio.h&gt;</span><br><span class="line">void setbuf(FILE *restrict fp, char *restrict buf);</span><br><span class="line">int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);</span><br></pre></td></tr></table></figure><p>在任何时候都可以强制冲洗一个流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fflush(FILE *fp);</span><br><span class="line">//成功返回0，失败返回EOF</span><br></pre></td></tr></table></figure></p><hr><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>下列3个函数打开一个标准I/O流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *fopen(const char *restrict pathname, const char *restrict type);</span><br><span class="line">FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);</span><br><span class="line">FILE *fdopen(int fd, const char *type);</span><br><span class="line">//成功返回文件指针，失败返回NULL</span><br></pre></td></tr></table></figure></p><p>这3个函数区别如下</p><ol><li>fopen函数打开路径名为pathname的一个指定的文件</li><li>freopen函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若流已经定向，则使用freopen清除定向。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准错误</li><li>fdopen函数取一个已有的文件描述符(我们可能从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到此文件描述符)，并使一个标准I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。因为这些特殊类型文件不能使用标准I/O函数fopen打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准I/O流与该描述符相结合。</li></ol><p>fdopn是 POSIX.1 具有的</p><p>type参数说明如下</p><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">说明</th><th style="text-align:left">open(2)标志</th></tr></thead><tbody><tr><td style="text-align:left">r或rb</td><td style="text-align:left">为读而打开</td><td style="text-align:left">O_RDONLY</td></tr><tr><td style="text-align:left">w或wb</td><td style="text-align:left">把文件截断至0长，或为写而创建</td><td style="text-align:left">O_WRONLY</td><td>O_CREAT</td><td>O_TRUNC</td></tr><tr><td style="text-align:left">a或ab</td><td style="text-align:left">追加；为在文件尾而写打开，或为写而创建</td><td style="text-align:left">O_WRONLY</td><td>O_CREAT</td><td>O_APPEND</td></tr><tr><td style="text-align:left">r+或r+b或rb+</td><td style="text-align:left">为读和写打开</td><td style="text-align:left">O_RDWR</td></tr><tr><td style="text-align:left">w+或w+b或w+</td><td style="text-align:left">把文件截断为0长，或为读和写而打开</td><td style="text-align:left">O_RDWR</td><td>O_CREAT</td><td>O_TRUNC</td></tr><tr><td style="text-align:left">a+或a+b或ab+</td><td style="text-align:left">为在文件尾读和写而打开或创建</td><td style="text-align:left">O_RDWR</td><td>O_CREAT</td><td>O_APPEND</td></tr></tbody></table><hr><h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>一旦打开了流，则可在3种不同类型的非格式化I/O中进行选择，对其进行读、写操作  </p><ol><li>每次一个字符的I/O。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。</li><li>每次一行的I/O。如果想要一次读或写一行，则使用fgets和fputs。每行都以一个换行符终止。当调用fgets时，应说明能处理的最大行长。</li><li>直接I/O。fread和fwrite函数支持这种类型的I/O。每次I/O操作读或写某种数量对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。</li></ol><h4 id="1-输入函数"><a href="#1-输入函数" class="headerlink" title="1. 输入函数"></a>1. 输入函数</h4><p>以下三个函数可用于一次读一个字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int getc(FILE *fp);</span><br><span class="line">int fgetc(FILE *fp);</span><br><span class="line">int getchar(void);</span><br><span class="line">//成功返回下一个字符，失败或到达文件末尾，返回EOF</span><br></pre></td></tr></table></figure></p><p>函数getchar()等同于 getc(stdin)。getc可被实现为宏，fgetc不能。意味着以下几点</p><ol><li>getc的参数不应当是具有副作用的表达式，因此它可能会被计算多次</li><li>因为fgetc一定是一个函数，所以它可以得到地址。这就允许将fgetc的地址作为一个参数传递给另一个函数</li><li>调用fgetc所需时间很可能比调用getc要长，因为调用函数所需时间通常长于调用宏</li></ol><p>不管是出错还是到达文件尾端，这3个函数都返回同样的值。为了区分这两种不同的情况，必须调用ferror或feof。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int ferror(FILE *fp);</span><br><span class="line">int feof(FILE *fp);</span><br><span class="line">//两个函数的返回值，若成功返回非0(真)；否则返回0(假)</span><br><span class="line">void clearerr(FILE *fp);</span><br></pre></td></tr></table></figure></p><p>在大多数实现中，为每个流在FILE对象中维护了两个标志:</p><ul><li>出错标志</li><li>文件结束标志</li></ul><p>调用clearerr可以清除这两个标志。<br>从流中读取数据以后，可以调用ungetc将字符再压送回流中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdiio.h&gt;</span><br><span class="line">int ungetc(int c,FILE *fp);</span><br><span class="line">//成功返回c，出错返回EOF</span><br></pre></td></tr></table></figure></p><h4 id="2-输出函数"><a href="#2-输出函数" class="headerlink" title="2. 输出函数"></a>2. 输出函数</h4><p>对应上面每个输入函数都有一个输出函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int putc(int c, FILE *fp);</span><br><span class="line">int fputc(int c, FILE *fp);</span><br><span class="line">int putchar(int c);</span><br><span class="line">//成功返回c，出错返回EOF</span><br></pre></td></tr></table></figure></p><hr><h2 id="每次一行I-O"><a href="#每次一行I-O" class="headerlink" title="每次一行I/O"></a>每次一行I/O</h2><p>下面两个函数提供每次输入一行的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *fgets(char *restrict buf, int n, FILE *restrict fp);</span><br><span class="line">char *gets(char *buf);</span><br><span class="line">//成功返回buf；若已到达文件尾端或出错，返回NULL</span><br></pre></td></tr></table></figure></p><p>推荐使用fgets<br>每个输入都有对应的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fputs(const char* restrict str, FILE *restrict fp);</span><br><span class="line">int puts(const char *str);</span><br><span class="line">//成功返回非负值，失败返回EOF</span><br></pre></td></tr></table></figure></p><hr><h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>系统提供了以下函数执行二进制I/O操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</span><br><span class="line">size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</span><br><span class="line">//两个函数的返回值：读或写的对象数</span><br></pre></td></tr></table></figure></p><hr><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><p>有3种方式定位标准I/O流  </p><ol><li>ftell和fseek函数。这俩函数都是假定文件的位置可以存放在一个长整数中</li><li>ftellofseeko函数。Single UNIX Specification引入了这两个函数，使文件偏移量可以不必一定使用长整形。他们使用off_t数据类型替代了长整形</li><li>fgetpos和fsetpos函数。这两个函数是由ISO C引入的。他们使用一个抽象数据类型fpos_t记录文件位置。这种数据类型可以根据需要定义一个足够大的数，用以记录文件位置。</li></ol><p>需要移植到非UNIX系统上需要使用fgetpos和fsetpos函数</p><hr><h2 id="格式化I-O"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h2><p>格式化输出是由5个printf函数处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int printf(const char* restrict format, ...);</span><br><span class="line">int fprintf(FIFE *restrict fp, const char* restrict format, ...);</span><br><span class="line">int dprintf(int fd, const char* restrict format, ...);</span><br><span class="line">//若成功返回输出字符数。出错返回负值</span><br><span class="line">int sprintf(char* restrict buf, const char* restrict format, ...);</span><br><span class="line">//成功返回存入数组的字符数，若编码出错返回负值</span><br><span class="line">int snprintf(char* restrict buf, size_t n, const char* restrict format, ...);</span><br><span class="line">若缓冲区足够大，返回将要存入数组的字符数，若编码出错返回负值</span><br></pre></td></tr></table></figure></p><p>printf将格式化的数据写到标准输出，fprintf写至指定的流，dprintf写至指定的文件描述符，sprintf将格式化的字符送入数组buf中。sprintf在该数组的尾端自动加一个null字节，但该字符不包括在返回值中。  </p><h4 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#incude &lt;stdio.h&gt;</span><br><span class="line">int scanf(const char* restrict format, ...);</span><br><span class="line">int fscanf(FIFE *restrict fp, const char* restrict format, ...);</span><br><span class="line">int sscanf(const char* restrict buf, const char* restrict format, ...);</span><br><span class="line">//3个函数的返回值，赋值的输入项数，若出错或任一转换前已到达文件尾端，返回EOF</span><br></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>ISO C标准I/O库提供了两个函数以帮助创建临时文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdiio.h&gt;</span><br><span class="line">char *tmpnam(char *ptr);</span><br><span class="line">FILE *tmpfile(void);</span><br><span class="line">//成功返回文件指针，出错返回null</span><br></pre></td></tr></table></figure></p><p>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时，都产生一个不同的路径名，最多调用次数是TMP_MAX(定义在<stdio.h>在mac系统该值为308915776)<br>若ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。后续调用tmpnam时，会重写该静态区(这意味着，如果我们调用此函数多次，而且想保存路径名，则我们应该保存该文件的副本，而不是指针的副本)。如若ptr不是NULL，则认为它应该是指向长度至少是L_tmpnam个字符的数组(L_tmpnam定义在<stdio.h>中mac下为1024)。所产生的路径名存放在该数组中，ptr也作为函数值返回。<br>tmpfile创建一个临时二进制文件(类型wb+)，在关闭该文件或程序结束时将自动删除这种文件。注意，UNIX对二进制文件不进行特殊区分。  </stdio.h></stdio.h></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;UNIX一切皆文件，掌握文件的操作尤其重要。以下的内容主要是apue上面第五章内容，介绍了标准I/O库的一些内容。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;流和FILE对象&quot;&gt;&lt;a href=&quot;#流和FILE对象&quot; class=&quot;headerlink&quot; title=&quot;流和FILE对象&quot;&gt;&lt;/a&gt;流和FILE对象&lt;/h2&gt;&lt;p&gt;标准I/O库，他们的操作都是围绕流进行的&lt;br&gt;字符分为单字节和多字节，流的定向决定了是所读、写的字符是单字节还是多字节的。当一个流被创建时，并没有定向。使用多字节I/O函数，流的定向就被设置为宽定向，单字节同理。只有两个函数可以改变流的定向，freopen和fwide  &lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python-mysql</title>
    <link href="https://joewt.com/2018/02/03/python-mysql/"/>
    <id>https://joewt.com/2018/02/03/python-mysql/</id>
    <published>2018-02-03T13:54:28.000Z</published>
    <updated>2018-02-04T14:26:11.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Python-安装mysql出问题"><a href="#Python-安装mysql出问题" class="headerlink" title="Python 安装mysql出问题"></a>Python 安装mysql出问题</h4><ol><li>使用的是mamp 用的里面的mysql 当我使用pip install mysql-python安装的时候出现 mysql_config没有找到的错误.<br>解决办法：环境变量添加 export PATH=”/Application/MAMP/Library/bin:$PATH”</li><li>通过 brew install mysql-connector-c  pip install mysql-python 安装出现IndexError:string index out of range<a id="more"></a>解决办法：By finding out the information that mysql-connector-cmight come to the conclusion that the configuration by brew installation may be incorrect , open the /usr/local/bin/mysql_config script to modify some of the contents of it:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Create options</span><br><span class="line">Libs = &quot;-L $ pkglibdir &quot;</span><br><span class="line">Libs = &quot; $ libs   -l&quot;</span><br></pre></td></tr></table></figure></li></ol><p>change into:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Create options</span><br><span class="line">Libs = &quot;- L $ pkglibdir&quot;</span><br><span class="line">Libs = &quot;$ libs -lmysqlclient -lssl -lcrypto&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Python-安装mysql出问题&quot;&gt;&lt;a href=&quot;#Python-安装mysql出问题&quot; class=&quot;headerlink&quot; title=&quot;Python 安装mysql出问题&quot;&gt;&lt;/a&gt;Python 安装mysql出问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用的是mamp 用的里面的mysql 当我使用pip install mysql-python安装的时候出现 mysql_config没有找到的错误.&lt;br&gt;解决办法：环境变量添加 export PATH=”/Application/MAMP/Library/bin:$PATH”&lt;/li&gt;
&lt;li&gt;通过 brew install mysql-connector-c  pip install mysql-python 安装出现IndexError:string index out of range
    
    </summary>
    
    
      <category term="python" scheme="https://joewt.com/tags/python/"/>
    
      <category term="mysql" scheme="https://joewt.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>apue配置</title>
    <link href="https://joewt.com/2018/02/03/apue-deploy/"/>
    <id>https://joewt.com/2018/02/03/apue-deploy/</id>
    <published>2018-02-03T00:55:00.000Z</published>
    <updated>2018-02-04T14:30:16.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="apue-配置问题"><a href="#apue-配置问题" class="headerlink" title="apue 配置问题"></a>apue 配置问题</h3><h5 id="mac-系统配置"><a href="#mac-系统配置" class="headerlink" title="mac 系统配置"></a>mac 系统配置</h5><p>执行 make all</p><p>将 ./apue.3e/include/下的  apue.h 复制到 /usr/local/include/下<br>将 ./apue.3e/lib/下的 error.c 复制到 /usr/local/include/ 下<br>然后修改 apue.h文件  在最后添加 #include “error.c”<br><a id="more"></a></p><h5 id="Linux-系统的配置如上"><a href="#Linux-系统的配置如上" class="headerlink" title="Linux 系统的配置如上"></a>Linux 系统的配置如上</h5><p>使用的是centos7 系统 编译源码的时候发现如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -ansi -I../include -Wall -DLINUX -D_GNU_SOURCE  barrier.c -o barrier  -L../lib -lapue -pthread -lrt -lbsd</span><br><span class="line">/tmp/ccF6O2ef.o: In function `thr_fn&apos;:</span><br><span class="line">barrier.c:(.text+0x80): undefined reference to `heapsort&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[1]: *** [barrier] Error 1</span><br><span class="line">make[1]: Leaving directory `/home/learnApue/apue.3e/threads&apos;</span><br><span class="line">make: *** [all] Error 1</span><br></pre></td></tr></table></figure></p><p>解决办法 <a href="https://pkgs.org/" target="_blank" rel="noopener">这里</a> 下载两个包<br>按照顺序安装<br>安装方法 rpm -Uvh xxxx.rpm  </p><p>这样就可以使用了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;apue-配置问题&quot;&gt;&lt;a href=&quot;#apue-配置问题&quot; class=&quot;headerlink&quot; title=&quot;apue 配置问题&quot;&gt;&lt;/a&gt;apue 配置问题&lt;/h3&gt;&lt;h5 id=&quot;mac-系统配置&quot;&gt;&lt;a href=&quot;#mac-系统配置&quot; class=&quot;headerlink&quot; title=&quot;mac 系统配置&quot;&gt;&lt;/a&gt;mac 系统配置&lt;/h5&gt;&lt;p&gt;执行 make all&lt;/p&gt;
&lt;p&gt;将 ./apue.3e/include/下的  apue.h 复制到 /usr/local/include/下&lt;br&gt;将 ./apue.3e/lib/下的 error.c 复制到 /usr/local/include/ 下&lt;br&gt;然后修改 apue.h文件  在最后添加 #include “error.c”&lt;br&gt;
    
    </summary>
    
      <category term="UNIX" scheme="https://joewt.com/categories/UNIX/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
</feed>
