<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JOE&#39;S BLOG</title>
  <icon>https://www.gravatar.com/avatar/4d7b6eb90ff6162c577a0163e274b344</icon>
  <subtitle>好记性不如烂键盘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joewt.com/"/>
  <updated>2018-05-06T04:25:20.867Z</updated>
  <id>https://joewt.com/</id>
  
  <author>
    <name>JOE</name>
    <email>joewttx@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何真正消化一本书？</title>
    <link href="https://joewt.com/2018/05/06/ReadingBooks/"/>
    <id>https://joewt.com/2018/05/06/ReadingBooks/</id>
    <published>2018-05-06T04:02:31.000Z</published>
    <updated>2018-05-06T04:25:20.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是李笑来正在预售的《七年就是一辈子》中的内容，略经 36 氪编辑。作者李笑来的微信公众号为 “学习学习再学习（xiaolai-xuexi）”。</p></blockquote><p>书大抵上分为两种：虚构类（Fiction），非虚构类（Non-Fiction）。读非虚构类的书籍，是为了获取新知识，并应用到生活中，让自己获得进步；就我个人而言，我更喜欢看非虚构类的书籍，从中获得的愉悦，感觉更大，因为那种愉悦通常有更为坚实的支撑 —— 进步。而虚构类的书籍，在大学毕业之后已经很少读了，可能是因为我自己在那里很难体会到太多的乐趣，更可能的另外一个原因是我已经彻底把获取那种愉悦的途径转移到了影视作品上。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="(一)"></a>(一)</h2><p>我读书很快，也因此读得很多，但我从来不强调自己的阅读速度 —— 甚至，我坚持认为“阅读速度” 是个伪概念，在我眼里，只有 “理解速度”，理解速度快，才能有效提高阅读量。</p><p>曾经有一段时间，我阅读英文书籍的时候，干脆是在电脑上用键盘敲，边敲边读…… 因为那个时候我发现自己的理解速度甚至跟不上手指头敲键盘的速度。别说遇到生词需要去查了，甚至常常出现的情况是，手指已经将一句话敲完了，却发现自己的脑子竟然不能理解这句话的确切意思……</p><p>没多久，理解速度开始提高，我也没啥兴趣拿着一本书 “一目十行” 地读。遇到好书，我会抽时间朗读完，一本二十万字左右的书朗读完，也不过十几个小时，中间断断续续，也能一个星期内搞定。更多的时候，时间花在那些需要停下来认真思考的部分，需要停下来心平气和地开开脑洞的部分，需要反复搜索寻找更多资料与关联的部分……反正，眼球快速移动本身，没有任何意义。</p><blockquote><p>阅读，是为了理解，而理解这事儿，慢，即是快；快，便是无。</p></blockquote><h2 id="二"><a href="#二" class="headerlink" title="(二)"></a>(二)</h2><p><strong><strong> 大多数情况下，我的阅读并没有功利性。完整性阅读，是没办法有功利性的，因为其实完全没办法知道所读、所学的东西究竟什么时候才能真正发挥它的核能量。</strong></strong> 还有另外一层原因是，还没读完（输入），还没消化完（处理），当然也完全没有开始行动（实践），所以，别说发挥核能量了，连发挥一点能量的可能性都很少。</p><p>另外一种阅读，我称之为检索性阅读。这种阅读本身就是功利性的，比如为了支持某个论点去搜索更为精彩、更为经典的事例；又比如为了思考得更为全面，去翻翻不同属性的人群是如何看待某个问题的；再比如，为了以上同样的目的去检索自己已读过的书库……</p><p>我总觉得阅读是构成自己生命的最重要组成部分之一，所以当然很舍不得降低它的质量。在信息泛滥的时代里（注意，不是知识泛滥），有个小技巧特别管用：<strong>标题党的文章直接不看了——说实话，即便错过什么了，也没什么可惜。</strong>这个小技巧真的不知道帮我节约了多少时间，提高了多少生活质量。</p><p>我从来都懒得接受 “碎片化 xx” 之类的概念，比如，碎片化阅读，碎片化思考，碎片化时间什么的，谁爱碎谁自己碎去，我才不想要一个碎片化的生活呢。</p><p>信息这东西，必须系统才有价值。碎片化的信息也许有用，但就算完全忽略，也不至于致命。舍了就舍了，没啥。这种勇气其实不少人都有，巴菲特就是其中之一。害怕错过什么，是一种情绪，来自于空虚的情绪：因为什么都没有，所以就渴望有一点什么，所以就特别害怕错过任何机会。充实的人，是不怕错过什么的，因为已经充实，错过点什么，真的无所谓，机会有的是，错过一大把又如何，反正因为充实而能够相信自己确实有实力终归抓到至少一个适合自己的机会。</p><p>所以，一定要读书，而不是把本来只不过是获得知识的辅助手段而已的杂志、文摘、新闻等等当做唯一主要手段。买好书，读好书，读懂好书，然后用知识改变自己的生活。</p><h2 id="三"><a href="#三" class="headerlink" title="(三)"></a>(三)</h2><p><strong>别人是不可能帮你吃饭的。同样的道理，别人其实是完全没办法帮你读书的。</strong>虽然我们在学校的时候，总是习惯了由老师带着、逼着读完整本书。</p><p>我一直觉得现在的学校其实是一种特别诡异的存在：一个学期好几个月，好几个老师就带着学生们完整地读完那么几本书，然后有些老师其实还讲不明白，大部分学生还学不明白…… 于是，生命就那么被浪费了。</p><p>从另外一个角度望过去，这几乎是在刻意把学生们变傻、变笨。这是在潜移默化地告诉学生们，“这东西好难的！难到什么地步呢？难到一届又一届的学生，都要花很长时间学，然后大部分还学不会、学不好呢！”</p><p>最要命的还不是拉长原本可以很短的理解时间，而是让学生们学啊学啊学啊学，就不让学生们用！这是什么道理？你看多少人，小学六年，初中三年，高中三年，大学本科四年，加起来都十六年了，学了十六年英语，然后竟然从来没用过……</p><p>说来说去，总结起来就是：别被他们骗了，你本来没那么傻……</p><h2 id="四"><a href="#四" class="headerlink" title="(四)"></a>(四)</h2><p><strong>拿来一本书，就好像要打一场仗，打仗之前最好先考察一下地形吧？</strong>同样的道理，拿来一本书，不应该是抓起来就从第一个字开始读起，一直读到最后……应该先看看目录，再看看附录，仔细读读前言，也不妨在网上先扫扫书评……要先大致对这本书有个了解，然后再开始行动比较好。</p><p>不同的作者有不同的组织方式，但大体上都是差不多的。总是要分章节。每一章其实都是在着重讲解一个概念，它的应用，它的方法论。而陆续的章节，通常是必须理解上一个概念之后才能进一步理解的概念，及其应用与方法论。所以，一头扎入内容之前，最好把这些概念大致过一遍，不理解没关系，哪怕先记住那些概念的名字和先后关系都很有帮助。</p><p><strong>在读的过程中，不断整理这些概念与方法论之间的关系，其实是 “消化” 的必要过程。</strong>有些人从小就学会了并且早就习惯这么做，而大多数人一辈子不会这么干 —— 这就是为什么最终绝大多数人只具备读半本杂志，看个豆腐块文章的能力，而不大可能真正独立消化一整本书的根本原因。</p><h2 id="五"><a href="#五" class="headerlink" title="(五)"></a>(五)</h2><p><strong>在阅读的过程中，要不断向后总结，向前预期 </strong>—— 这是最基本的理解技巧。在阅读的过程中，要不断总结刚才输入的东西都有什么，它们之间是什么样的关系；与此同时，还要不断预期下一步的内容是什么……这是一个不断循环的输入处理的过程。很多人懂得向后总结，却不懂得也应该同时不断向前预期，于是他们只有输入与处理这两个部分。当然绝大多数人除了输入之外什么都没有，连处理都没有。最终只有少数人的阅读理解过程是不断循环地 “输入、处理、输出” 的过程，尽管这里的 “输出” 某种意义上不过是 “伪输出”……</p><p>向前预期，常常相当于为 “跳读、略读” 提供一个安全机制。读着读着，发现作者提出了一个自己已经深入了解过的论点，再往下扫一眼，发现论据也是自己之前了解的，那这一部分就可以安全地跳过了。又由于一直保持着一个预期，再往下读的时候，发现 “嗯？怎么回事儿？跟我想的不一样呢？” 那就要折回去认真找原因……反之，要是一样，说明自己的跨越是正确的么。</p><p>所以说，在良好的阅读习惯下，理解速度会不断积累，最终不断加快 —— 因为所有的知识都有共同点：它们不一定能用在哪里，它们早晚必然融会贯通。所以，理解过的东西越多，理解新的东西就越快。说穿了，理解能力差，无非就是见识少，仅此而已。</p><h2 id="六"><a href="#六" class="headerlink" title="(六)"></a>(六)</h2><p>一旦遇到需要分享 “如何读书” 的场合，我总是会提起这句话：</p><blockquote><p>我有一个奇怪的本领：就是，把一本书拿过来，我即便读不懂，我也能读得完。</p></blockquote><p>这句话总是引来哄堂大笑，可实际上，首先我是认真的；其次，却也更为重要的是，觉得这事儿荒谬恰恰是大多数人其实不懂如何读书的表现。</p><p>读不懂怎么办？没关系，只有一个办法靠谱：硬着头皮读完，然后反复读很多遍。这是一个特别重要的本领，很多人不知道。其实，重要的知识，从来都是通过反复学习才能获得的。一下就能学会得东西，通常上价值不大。</p><p>有一点弄不明白就放弃，那能学会什么呢？</p><p>还有一个常见现象：有些书籍就是难懂，因为它的内容结构并不完全线性，也就是说，第二章的内容需要第五章的知识才能理解彻底…… 所以，最终，只有我们这种不怕暂时读不懂，能硬着头皮读完，然后再反复来过的人才能消化这种书籍。</p><h2 id="七"><a href="#七" class="headerlink" title="(七)"></a>(七)</h2><p>一定要用起来。很多有用的东西，之所以最终没用，是因为压根没用过。知识无用，这是二货思维，所有的知识都是有用的，哪怕巫术都有用，更何况知识。可是不用的东西，没用起来的东西，还不如虚无 —— 因为读过、学过，时间与精力已经耗费了，这可是最宝贵的不可逆不可回收不可再生资源！</p><p>2000 年，我突击考了 TOEFL、GRE，就跑去新东方应聘出国留学培训教师职位；2005 年开始前后写了两年多，终于觉得自己能用文字讲明白道理了，就写了《把时间当作朋友》；2012 年我学了 Ruby On Rails，就和李路和沙欣哲一起搞出来了一个 Knewone；2014 年我学会了使用 Sketch，就用它设计了若干个 APP 的原型，顺带逼着几个程序员也变成了设计师；2015 年上半年，我读了许多本关于社区建设的书（其中包括那本著名的 The Art of Community: Building the New Age of Participation， <a href="http://www.artofcommunityonline.org），你看我正在打造社群……" target="_blank" rel="noopener">http://www.artofcommunityonline.org），你看我正在打造社群……</a> 不仅如此，我还帮很多人打造社群。</p><p>不用，学它干嘛？这与我读书的原则也是相通的：不用认真读的书，读它干嘛？这与我对生活的态度也是一样的，既然活着，就要活好，活得精彩。</p><h2 id="八"><a href="#八" class="headerlink" title="(八)"></a>(八)</h2><p>暂时用不起来怎么办？教！我总是重复这句话：</p><blockquote><p>教是最好的学习方法。</p></blockquote><p>把你学到的，总结好的，琢磨清楚的那些知识（不是胡说八道的那些东西）传递出去，分享给你身边的人。“教”，不一定非要像老师一样在课堂上给一帮学生讲（还不允许他们打断）……“教” 可以有很多种形式，比如，“分享”，就是 “教” 的一种形式。在饭桌上都可以进行：</p><p>“我最近读到一个新的概念，特震撼：三度影响力…… 原来肥胖症居然在某种程度上是可以传染的！”</p><p>如果你的朋友对此感兴趣，那你就要再仔细一点说明其机理，其作用，甚至用更多的来自自己身边的例子去讲解。在一来二去的交谈中，你会发现自己也还有很多没弄明白的地方，还有很多地方需要更准确的陈述，需要更精彩、更令人信服、惊叹的论据…… 怎么办？回来改进呗，下次在另外一个饭桌上再演练一次……</p><p>所以，我也总是分享这个道理：</p><blockquote><p>分享，不仅需要能力支撑，也是培养能力的最重要手段。知识分享，没有成本，只有收益 —— 双方都有的收益。</p></blockquote><p>分享的技巧很简单：</p><blockquote><ol><li>真诚，只分享自己确实觉得好的东西；</li><li>也是真诚，绝对不能居高临下地装蛋；</li><li>还是真诚，对方完全有可能不理解你。</li></ol></blockquote><h2 id="九"><a href="#九" class="headerlink" title="(九)"></a>(九)</h2><p>还没完！别忘了问自己这个最重要的问题：</p><p>这个概念、这个方法论、这个道理、这个知识，还可以用在什么地方？</p><p>这是让你真正培养融会贯通能力的方式。所谓的聪明就是这么来的：脑子里有足够多清晰正确的概念与方法论，然后它们之间还有正确应有的关联…… 所以聪明的操作系统总是有更多的想法、更多的方案、更多的可能性。</p><p>万一想到了可以 “出其不意” 地使用的场景，那就赚大了，因为同样的东西到了你的手里却发挥了不一样的作用，你当然与众不同，也只能与众不同。</p><h2 id="十"><a href="#十" class="headerlink" title="(十)"></a>(十)</h2><p><strong>与喜欢学习的人泡在一起</strong> —— 这一点真的特别重要(当然跟喜欢的人在一起共同学习提高了啦(手动艾特某人))。潜移默化的力量是非常大的，与喜欢学习的人在一起，正面的影响力很大；与不喜欢学习的人在一起，负面的影响力不仅很大也很可怕。</p><p>寻找那些终生学习的人，把他们当作朋友，把他们当作榜样。</p><p>网络时代有个好处，这种人虽然身边并不多见，但网络上却很常见。为什么呢？网络消灭了地域的限制，甚至消灭了语言的限制。我就有个很长期的榜样：Bruce Eckel。我根本不认识他，也没有过任何传统意义上的交往，连 email 往来都没有。他是 Thinking In C++ 的作者。十多年前，他在网上发布 Thinking In C++ 第一版的写作计划，然后以极快的速度更新完成…… 毫无疑问，见识到有人这样，就成了后来我写书的时候 “雷厉风行” 的根本原因和动力。再反过来说，人家写书都可以这样，我们读书怎么可以拖拖拉拉呢？</p><blockquote><p>转载: <a href="https://www.ycjcl.cc/" target="_blank" rel="noopener">信鑫-King’s Blog</a>&gt;&gt;<a href="https://www.ycjcl.cc/2016/01/22/ru-he-zhen-zheng-xiao-hua-ben-shu-zhuan-zi-36kr/" target="_blank" rel="noopener">如何真正消化一本书？(转自36Kr)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是李笑来正在预售的《七年就是一辈子》中的内容，略经 36 氪编辑。作者李笑来的微信公众号为 “学习学习再学习（xiaolai-xuexi）”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书大抵上分为两种：虚构类（Fiction），非虚构类（Non-Fiction）。读非虚构类的书籍，是为了获取新知识，并应用到生活中，让自己获得进步；就我个人而言，我更喜欢看非虚构类的书籍，从中获得的愉悦，感觉更大，因为那种愉悦通常有更为坚实的支撑 —— 进步。而虚构类的书籍，在大学毕业之后已经很少读了，可能是因为我自己在那里很难体会到太多的乐趣，更可能的另外一个原因是我已经彻底把获取那种愉悦的途径转移到了影视作品上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="book" scheme="https://joewt.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>swoole安装</title>
    <link href="https://joewt.com/2018/04/13/swoole-install/"/>
    <id>https://joewt.com/2018/04/13/swoole-install/</id>
    <published>2018-04-13T02:08:51.000Z</published>
    <updated>2018-04-13T02:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>各个环境下有所区别，我使用的是mac系统，首先说的是mac系统下的安装  </p><p>mac系统 自带的有php，这里并不用自带的。使用mamp,php的目录在如下的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/mamp/bin/php</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="noopener">swoole</a></p><p>下载最新的版本即可</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完解压后，目录下会有一个make.sh 这是个简易的安装脚本<br>需要改下phpize，改成mamp下的phpize，在<code>/Applicatons/mamp/bin/php/php7.xxx/bin/</code>目录下<br>./configure 有一些编译参数，根据自己的情况而定<br><a href="https://wiki.swoole.com/wiki/page/437.html" target="_blank" rel="noopener">这里查看</a></p><p>之后执行脚本即可</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装成功后，修改php.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=swoole.so</span><br></pre></td></tr></table></figure></p><p>之后通过php -m 查看扩展是否安装成功,使用mamp下的php命令</p><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><p>一个官方的案例–创建TCP服务器<br>server.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建Server对象，监听 127.0.0.1:9501端口</span><br><span class="line">$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501); </span><br><span class="line"></span><br><span class="line">//监听连接进入事件</span><br><span class="line">$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123;  </span><br><span class="line">    echo &quot;Client: Connect.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听数据接收事件</span><br><span class="line">$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123;</span><br><span class="line">    $serv-&gt;send($fd, &quot;Server: &quot;.$data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听连接关闭事件</span><br><span class="line">$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123;</span><br><span class="line">    echo &quot;Client: Close.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//启动服务器</span><br><span class="line">$serv-&gt;start();</span><br></pre></td></tr></table></figure></p><p><img src="http://ojg7pw3bl.bkt.clouddn.com/swoole-install-finish.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;各个环境下有所区别，我使用的是mac系统，首先说的是mac系统下的安装  &lt;/p&gt;
&lt;p&gt;mac系统 自带的有php，这里并不用自带的。使用mamp,php的目录在如下的目录下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/Applications/mamp/bin/php&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="swoole" scheme="https://joewt.com/tags/swoole/"/>
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局</title>
    <link href="https://joewt.com/2018/03/07/css-layout/"/>
    <id>https://joewt.com/2018/03/07/css-layout/</id>
    <published>2018-03-07T14:06:10.000Z</published>
    <updated>2018-03-07T14:09:52.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h3><ul><li>CSS知识体系的重中之重</li><li>早期以table为主（简单）  </li><li>后来以技巧性布局为主（难）</li><li>现在有flexbox/grid（偏简单）</li><li>响应式布局是必备知识</li></ul><h3 id="常用布局方法"><a href="#常用布局方法" class="headerlink" title="常用布局方法"></a>常用布局方法</h3><ul><li>table 表格布局</li><li>float 浮动+margin</li><li>inline-block 布局</li><li>flexbox 布局</li></ul><a id="more"></a><h3 id="布局属性"><a href="#布局属性" class="headerlink" title="布局属性"></a>布局属性</h3><p>盒子模型<br><img src="http://ojg7pw3bl.bkt.clouddn.com/hz.png" alt=""> </p><h4 id="设置布局的两个基本属性-display-position"><a href="#设置布局的两个基本属性-display-position" class="headerlink" title="设置布局的两个基本属性 display/position"></a>设置布局的两个基本属性 display/position</h4><ul><li>确定元素的显示类型<ul><li>block(块级元素)/inline(内联元素或者叫行内元素)/inline-block(行内块级元素)</li></ul></li><li>确定元素位置<ul><li>static/relative/absolute/fixed</li></ul></li></ul><p>position:   </p><ul><li>relative: 根据元素原来的位置进行偏移</li><li>absolute: 脱离文档流，不会对其他元素造成影响 相对于最近的 absolute或relative进行偏移</li><li>fixed: 脱离文档流，是相对于屏幕 可视区域 固定的</li></ul><p>z-index: 定义层级 设置谁显示在最上方，越大就越在最上，对设置了relative,absolute,fixed的有用</p><h3 id="flexbox布局"><a href="#flexbox布局" class="headerlink" title="flexbox布局"></a>flexbox布局</h3><ul><li>弹性盒子</li><li>盒子本来就是并列的</li><li>指定宽度即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.flex &#123;</span><br><span class="line">  flex: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果想设置固定的宽度</span><br><span class="line">.xxx &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  flex: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;flex&quot;&gt;</span><br><span class="line">      xxxx</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h3><ul><li>元素浮动</li><li>脱离文档流</li><li>但不会脱离文本流</li></ul><h5 id="float"><a href="#float" class="headerlink" title="float"></a>float</h5><ul><li><p>对自身的影响</p><ul><li>形成“块” （BFC）</li><li>位置尽量靠上</li><li>位置尽量靠左(右) 在靠上的前提下</li></ul></li><li><p>对兄弟的影响</p><ul><li>上面贴非float元素</li><li>旁边贴float元素</li><li>不影响其他块级元素位置</li><li>影响其他块级元素内部文本</li></ul></li><li><p>对父级元素的影响</p><ul><li>从布局上“消失”</li><li>高度塌陷</li></ul></li><li><p>清除浮动</p><ul><li>overflow: hidden(auto)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container2::after&#123;</span><br><span class="line">           content: &apos;ffff&apos;;</span><br><span class="line">           clear: both;</span><br><span class="line">           display: block;</span><br><span class="line">           height: 0;</span><br><span class="line">           visibility: hidden;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2栏布局"><a href="#2栏布局" class="headerlink" title="2栏布局"></a>2栏布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: 800px;</span><br><span class="line">            height: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: blue;</span><br><span class="line">            float: left;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: 200px;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">            left</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">            right</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="3栏布局"><a href="#3栏布局" class="headerlink" title="3栏布局"></a>3栏布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .container&#123;</span><br><span class="line">        width: 800px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        background: blue;</span><br><span class="line">        float: left;</span><br><span class="line">        height: 100%;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        background: red;</span><br><span class="line">        float: right;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .middle&#123;</span><br><span class="line">        margin-left: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">        left</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">            right</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        middle</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h2&gt;&lt;h3 id=&quot;CSS-布局&quot;&gt;&lt;a href=&quot;#CSS-布局&quot; class=&quot;headerlink&quot; title=&quot;CSS 布局&quot;&gt;&lt;/a&gt;CSS 布局&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CSS知识体系的重中之重&lt;/li&gt;
&lt;li&gt;早期以table为主（简单）  &lt;/li&gt;
&lt;li&gt;后来以技巧性布局为主（难）&lt;/li&gt;
&lt;li&gt;现在有flexbox/grid（偏简单）&lt;/li&gt;
&lt;li&gt;响应式布局是必备知识&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用布局方法&quot;&gt;&lt;a href=&quot;#常用布局方法&quot; class=&quot;headerlink&quot; title=&quot;常用布局方法&quot;&gt;&lt;/a&gt;常用布局方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;table 表格布局&lt;/li&gt;
&lt;li&gt;float 浮动+margin&lt;/li&gt;
&lt;li&gt;inline-block 布局&lt;/li&gt;
&lt;li&gt;flexbox 布局&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS学习" scheme="https://joewt.com/categories/CSS%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="https://joewt.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>指针和数组</title>
    <link href="https://joewt.com/2018/02/27/pointer-and-array/"/>
    <id>https://joewt.com/2018/02/27/pointer-and-array/</id>
    <published>2018-02-27T12:46:49.000Z</published>
    <updated>2018-02-27T13:16:51.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针和数组的爱恨情仇"><a href="#指针和数组的爱恨情仇" class="headerlink" title="指针和数组的爱恨情仇"></a>指针和数组的爱恨情仇</h1><p>指针和数组他们之间没有任何关系  </p><ul><li>指针就是指针，指针变量在32位系统下，永远占4个byte，其值为某一个内存的地址。指针可以指向任何地方，但是不是任何地方你都能通过这个指针变量访问到。</li><li>数组就是数组，其大小与元素的类型和个数有关。定义数组时必须指定其元素的类型和个数。数组可以存放任何类型的数据，但不能存函数。  </li></ul><h2 id="如何分辨数组指针和指针数组"><a href="#如何分辨数组指针和指针数组" class="headerlink" title="如何分辨数组指针和指针数组"></a>如何分辨数组指针和指针数组</h2><ul><li>指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“存储指针的数组”的简称</li><li>数组指针：首先它是一个指针，他指向一个数组。在32位系统下永远是占4个字节，至于它指向的数组占多少个字节，不知道。它是“指向数组的指针”的简称<a id="more"></a>考虑下，下面2个哪个是指针数组，哪个是数组指针<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A). int *p1[10];</span><br><span class="line">B). int (*p2)[10];</span><br></pre></td></tr></table></figure></li></ul><p>根据右左法则，先找到未定义标识符，p1右边是[]因为[]比<code>*</code>的优先级高，p1先与[]结合，所以它是一个数组。<code>int *</code>修饰的是数组的内容。<br>再看p2，因为”()”比”[]”优先级高，所以<code>(*p2)</code>表示这是一个指针，指针变量名为p2,int修饰的数组内容，即数组的每个元素。数组在这里没有名字，是匿名数组。所以p2是一个数组指针，指向一个包含10个int类型数据的数组。</p><h2 id="多维数组和多级指针"><a href="#多维数组和多级指针" class="headerlink" title="多维数组和多级指针"></a>多维数组和多级指针</h2><p>考虑下面一个例子<br>&amp;p[4][2]-&amp;a[4][2]的值为多少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5][5];</span><br><span class="line">    int (*p)[4];</span><br><span class="line">    p = a;</span><br><span class="line">    printf(&quot;a_ptr=%#p,p_ptr=%#p\n&quot;,&amp;a[4][2],&amp;p[4][2]);</span><br><span class="line">    printf(&quot;%p,%d\n&quot;,&amp;p[4][2]-&amp;a[4][2],&amp;p[4][2]-&amp;a[4][2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="http://ojg7pw3bl.bkt.clouddn.com/7AB30FB4610D9CD6E007B4CE48D73270.png" alt=""><br>文字解析，不如看图来的好<br><img src="http://ojg7pw3bl.bkt.clouddn.com/D28B21B0082E0FBB411BBCEFA515B45E.png" alt="">  </p><h2 id="数组参数与指针参数"><a href="#数组参数与指针参数" class="headerlink" title="数组参数与指针参数"></a>数组参数与指针参数</h2><h3 id="一维数组参数"><a href="#一维数组参数" class="headerlink" title="一维数组参数"></a>一维数组参数</h3><h4 id="能否向函数传递一个数组？"><a href="#能否向函数传递一个数组？" class="headerlink" title="能否向函数传递一个数组？"></a>能否向函数传递一个数组？</h4><p>考虑以下程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun(char a[10])</span><br><span class="line">&#123;</span><br><span class="line">    char c = a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    fun(b[10]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的调用，fun(b[10]);将b[10]这个数组传递到fun函数。这样显然不对。<br>b[0]代表是数组的一个元素，那么b[10]也是，只是这里越界了。但在编译阶段，编译器并不会真正计算b[10]的地址并取值，所在在编译阶段不会报错，但是编译器会给出警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在我的Mac上编译出现这个</span><br><span class="line">warning: incompatible integer to pointer conversion passing &apos;char&apos; to parameter of type &apos;char *&apos;; take the address with &amp; [-Wint-conversion]  </span><br><span class="line">warning: array index 10 is past the end of the array (which contains 10 elements) [-Warray-bounds]</span><br><span class="line">//在作者的电脑上给出的警告是这样的  </span><br><span class="line">warning C4047: &apos;function&apos; : &apos;char *&apos; differs in levels of indirection from &apos;char &apos;</span><br><span class="line">warning C4024: &apos;fun&apos; : different types for formal and actual parameter 1</span><br></pre></td></tr></table></figure></p><p>虽然编译没问题，但运行肯定有问题。<br>具体分析如下:  </p><ol><li>b[10]并不存在，在编译的时候由于没有去实际地址取值，所以没有出错，但是在运行时，将计算b[10]的实际地址，并且取值。这时发生越界错误</li><li>编译器的警告已经告诉我们编译器需要的是一个char*类型的参数，而传递过去的是一个char类型的参数，这时候fun函数会将传入的char类型的数据当地址处理，同样会发生错误</li><li>对第二个错误的理解，fun函数明明传递的是一个数组啊，编译器怎么会说是char*类型呢？  </li></ol><p>将fun(b[10])改为fun(b)，编译后不会出现警告了。</p><h4 id="无法向函数传递一个数组"><a href="#无法向函数传递一个数组" class="headerlink" title="无法向函数传递一个数组"></a>无法向函数传递一个数组</h4><p>可以简单验证下，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun(char a[10])</span><br><span class="line">&#123;</span><br><span class="line">    int i=sizeof(a);</span><br><span class="line">    printf(&quot;i:%d\n&quot;,i);</span><br><span class="line">    char c=a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    int j = sizeof(b);</span><br><span class="line">    printf(&quot;j:%d\n&quot;,j);</span><br><span class="line">    fun(b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ojg7pw3bl.bkt.clouddn.com/FC89DCB14091449DBE1B2B8A345E07EA.png" alt=""><br>如果数组b真正传递到函数内部，那么i的值应该为10，但我测试后发现i的值为8(作者测的值为4)。造成这样的原因是这样一条规则:   </p><ul><li>C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针</li></ul><blockquote><p>这么做是有原因的。在 C 语言中，所有非数组形式的数据实参均以传值形式（对实参<br>做一份拷贝并传递给被调用的函数，函数不能修改作为实参的实际变量的值，而只能修改<br>传递给它的那份拷贝）调用。然而，如果要拷贝整个数组，无论在空间上还是在时间上，<br>其开销都是非常大的。更重要的是，在绝大部分情况下，你其实并不需要整个数组的拷贝，<br>你只想告诉函数在那一刻对哪个特定的数组感兴趣。这样的话，为了节省时间和空间，提<br>高程序运行的效率，于是就有了上述的规则。同样的，函数的返回值也不能是一个数组，<br>而只能是指针。这里要明确的一个概念就是：函数本身是没有类型的，只有函数的返回值<br>才有类型。很多书都把这点弄错了，甚至出现“XXX 类型的函数”这种说法。简直是荒唐<br>至极！</p></blockquote><p>所以我们写代码的时候，可以写成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void fun(char a[])</span><br><span class="line">&#123;</span><br><span class="line">    char c=a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    fun(b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fun(char *p)</span><br><span class="line">&#123;</span><br><span class="line">    char c=p[3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;指针和数组的爱恨情仇&quot;&gt;&lt;a href=&quot;#指针和数组的爱恨情仇&quot; class=&quot;headerlink&quot; title=&quot;指针和数组的爱恨情仇&quot;&gt;&lt;/a&gt;指针和数组的爱恨情仇&lt;/h1&gt;&lt;p&gt;指针和数组他们之间没有任何关系  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指针就是指针，指针变量在32位系统下，永远占4个byte，其值为某一个内存的地址。指针可以指向任何地方，但是不是任何地方你都能通过这个指针变量访问到。&lt;/li&gt;
&lt;li&gt;数组就是数组，其大小与元素的类型和个数有关。定义数组时必须指定其元素的类型和个数。数组可以存放任何类型的数据，但不能存函数。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何分辨数组指针和指针数组&quot;&gt;&lt;a href=&quot;#如何分辨数组指针和指针数组&quot; class=&quot;headerlink&quot; title=&quot;如何分辨数组指针和指针数组&quot;&gt;&lt;/a&gt;如何分辨数组指针和指针数组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“存储指针的数组”的简称&lt;/li&gt;
&lt;li&gt;数组指针：首先它是一个指针，他指向一个数组。在32位系统下永远是占4个字节，至于它指向的数组占多少个字节，不知道。它是“指向数组的指针”的简称
    
    </summary>
    
      <category term="C语言" scheme="https://joewt.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C语言深度解剖" scheme="https://joewt.com/categories/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96/"/>
    
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>进程控制(八)</title>
    <link href="https://joewt.com/2018/02/12/progress-control/"/>
    <id>https://joewt.com/2018/02/12/progress-control/</id>
    <published>2018-02-12T13:44:44.000Z</published>
    <updated>2018-02-19T03:44:34.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本章主要介绍了UNIX系统的进程控制</p><ul><li>创建新进程、执行程序和进程终止</li><li>进程属性的各种ID，他们如何受到进程控制原语的影响</li><li>解释器文件和system函数</li><li>进程会计机制</li></ul><a id="more"></a><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整数表示的唯一进程ID，该ID唯一，但进程ID是可以复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。防止将新进程误认为是使用同一ID的某个已终止的先前进程。<br>一些专用进程  </p><ul><li>ID为0，通常是调度进程，也被称为交换进程。</li><li>ID为1，通常是init进程，在自举过程结束时由内核调用。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件(/etc/rc*或/etc/inittab或/etc/init.d文件)。并将系统引导到一个状态(如多用户)。init进程决不会终止。它是一个普通的用户进程(不是内核中的系统进程)，但是它以超级用户特权运行。</li><li>某些UNIX的虚拟存储器实现中，进程ID2是页守护进程(page daemon)，此进程负责支持虚拟存储器系统的分页操作。</li></ul><p>除了进程ID，每个进程还有一些其他标识符。下列函数返回这些标识符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t getpid(void);     //调用进程的进程ID</span><br><span class="line">pid_t getppid(void);    //调用进程的父进程ID</span><br><span class="line">pid_t getuid(void);     //调用进程的实际用户ID</span><br><span class="line">pid_t geteuid(void);    //调用进程的有效用户ID</span><br><span class="line">pid_t getgid(void);     //调用进程的实际组ID</span><br><span class="line">pid_t getegid(void);    //调用进程的有效组ID</span><br></pre></td></tr></table></figure></p><h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有的进程可以调用fork函数创建一个新进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">//返回值：子进程返回0，父进程返回子进程ID；若出错返回-1</span><br></pre></td></tr></table></figure></p><p>由fork创建的新进程被称为子进程(child process)。fork函数被调用一次，但返回两次。子进程返回0，父进程返回子进程的进程ID。   </p><p>父进程返回子进程的ID的原因：  </p><ul><li>因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。  </li></ul><p>子进程返回0的原因：</p><ul><li>一个进程只会有一个父进程，所以子进程总是可以调用getppid以获取其父进程的进程ID(进程ID0总是由内核交换程序使用，所以一个子进程的进程ID不可能为0)  </li></ul><p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间。父进程和子进程共享正文段<br>由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全副本。作为替代，使用了写时复制技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int globvar = 6;</span><br><span class="line">char buf[] = &quot;a write to stdout\n&quot;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int     var;</span><br><span class="line">    pid_t   pid;</span><br><span class="line"></span><br><span class="line">    var = 99;</span><br><span class="line">    if (write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)</span><br><span class="line">        err_sys(&quot;write error&quot;);</span><br><span class="line">    printf(&quot;before fork\n&quot;);</span><br><span class="line">    if((pid = fork())&lt;0) &#123;</span><br><span class="line">        err_sys(&quot;fork error&quot;);</span><br><span class="line">    &#125; else if(pid == 0) &#123;</span><br><span class="line">        printf(&quot;这是子进程:\n&quot;);</span><br><span class="line">        globvar++;</span><br><span class="line">        var++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;这是父进程:\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;pid = %ld, glob = %d, var = %d\n&quot;, (long)getpid(), globvar, var);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ojg7pw3bl.bkt.clouddn.com/figure8.1.png" alt="figure8.1"><br>一般来说子进程和父进程的执行顺序是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程间通信。在上面的程序中父进程使进程休眠2s，以使子进程先执行。但不保证2s足够，第二次 的结果父进程并没有休眠2s。父进程先执行了。在10章将会说明在fork之后如何使用信号使父进程和子进程同步。<br>当写标准输出时，我们将buf长度减1作为输出字节数，这是为了避免将终止null字节写出。strlen计算不包含终止null字节的字符串长度，而sizeof计算包括终止null字节的缓冲区长度。两者之间的另一个区别是，使用strlen需进行一次函数调用，而对于sizeof而言，因为缓冲区已用已知字符串进行初始化，其长度是固定的，所以sizeof是在编译时计算缓冲区长度。  </p><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>对图中程序注意的另一点是：在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了dup函数。父进程和子进程每个相同的打开描述符共享一个文件表项(如下图所示)。<br><img src="http://ojg7pw3bl.bkt.clouddn.com/figure3.9.png" alt=""><br>考虑下述情况，一个进程具有3个不同的打开文件，它们是标准输入、标准输出和标准错误。在从fork返回时，我们有了如下图中所示的结构。<br><img src="http://ojg7pw3bl.bkt.clouddn.com/figure8.2.png" alt=""><br>父进程和子进程共享同一个文件偏移量。考虑如下情况:  </p><ul><li>一个进程fork了一个子进程，然后等待子进程终止。假定，作为普通处理的一部分，父进程和子进程都向标准输出进行写操作。如果父进程的标准输出已重定向(很可能是由shell实现的)，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。在这个例子中，当父进程等待子进程时，子进程写到标准输出；而在子进程终止后，父进程也写到标准输出上，并且知道其输出会追加在子进程所写数据之后。如果父进程和子进程不共享同一文件偏移量，要实现这种形式的交互就要困难很多，可能需要父进程显示地动作。</li><li>如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步(如使父进程等待子进程)，那么他们的输出就会相互混合(假定所用的描述符是在fork之前打开的)。虽然这种情况是可能发生的，但这并不是常见的操作模式。  </li></ul><p>在fork之后处理文件描述符有以下两种常见的情况。</p><ol><li>父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新。</li><li><p>父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，父进程和子进程各自关闭它们不需要使用的文件描述符，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程经常使用的。<br> 除了打开文件之外，父进程的很多其他属性也有子进程继承，包括:</p><ul><li>实际用户ID、实际组ID、有效用户ID、有效组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>终端控制</li><li>设置用户ID标志和设置组ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>信号屏蔽和安排</li><li>对任一打开描述符的执行时关闭(close-on-exec)标志</li><li>环境</li><li>连接的共享存储段</li><li>存储映像</li><li><p>资源限制  </p><p>父进程和子进程之间的具体区别如下:</p></li><li>fork的返回值不同</li><li>进程ID不同</li><li>这两个进程的父进程ID不同:子进程的父进程ID是创建它的进程的ID，而父进程的父进程ID则不变</li><li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0(在下面的小结中介绍)</li><li>子进程不继承父进程设置的文件锁</li><li>子进程的未处理闹钟被清除</li><li>子进程的未处理信号集设置为空集</li></ul></li></ol><p>使fork失败的两个主要原因是:</p><ol><li>系统中已经有了太多的进程(通常意味着某个方面出了问题)</li><li>该实际用户ID的进程总数超过了系统限制(CHAILD_MAX规定了每个实际用户ID在任意时刻可拥有的最大进程数)  </li></ol><p>fork有以下两种用法  </p><ol><li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的—父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程批处理此请求。父进程则继续等待下一个服务请求</li><li>一个进程要执行一个不同的程序。这对shell是最常见的。在这种情况下，子进程从fork返回后立即调用exec  </li></ol><p>某些系统将第二种用法中的两个操作(fork之后执行exec)组合成一个操作，称为spawn。UNIX系统将这两个操作分开，因为在很多场合需要单独使用fork，其后并不跟随exec。另外，将这两个操作分开，使得子进程在fork和exec之间可以更改自己的属性，如I/O重定向、用户ID。信号安排等。在第15章有更多的例子。  </p><h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同，但两者的语义不同。  </p><ul><li>可移植的应用程序不应该使用这个函数</li></ul><p>vfork和fork的区别:  </p><ul><li>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec(或exit)，于是也就不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。这种优化工作方式在某些UNIX系统中提高了工作效率，但如果子进程修改数据、进行函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果。  </li><li>vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。(如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁)  </li></ul><h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>如第7章所述，进程有5种正常终止及3种异常终止方式。<br>5种正常终止方式具体如下:</p><ol><li>在main函数内执行return函数。等效于exit</li><li>调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序(终止处理程序在调用atexit函数时登记)，然后关闭所有标准I/O流等。因为ISO C并不处理文件描述符、多进程以及作业控制，所以这一定义对UNIX系统而言是不完整的。</li><li>调用_exit或_Exit函数。ISO C定义_Exit,其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗，这取决于实现。在UNIX系统中，<code>_Exit</code>和<code>_exit</code>是同义的，并不冲洗标准I/O流。<code>_exit</code>函数由<code>exit</code>调用。<code>_exit</code>函数由<code>exit</code>调用，它处理UNIX系统特定的细节。<code>_exit</code>是由POSIX.1说明的。  </li><li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。</li><li>进程的最后一个线程调用pthread_exit函数，在这种状态下，进程终止状态总是0，这与传递给pthread_exit的参数无关。</li></ol><p>3种异常终止具体如下:</p><ol><li>调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例。</li><li>当进程接收到某种信号时。信号可由进程自身(如调用abort函数)、其他进程或内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生相应的信号。</li><li>最后一个线程对“取消”请求作出响应。默认情况下，“取消”以延迟方式发生:一个线程要求取消另一个线程，若干时间之后，目标线程终止  </li></ol><p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。对于上述任意一种终止情形，我们希望终止进程能够通知其父进程它是如何终止的:  </p><ul><li>对于3个终止函数(exit,<code>_exit</code>,<code>_Exit</code>),实现这一点的方法是，将其退出状态(exit status)作为参数传递给函数。</li><li>在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的终止状态。</li><li>在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态  </li></ul><p>如果父进程在子进程之前终止:</p><ul><li>对于父进程已经终止的所有进程，它们的父进程都改为init进程。我们称这些进程由init进程收养。其操作过程:<ul><li>在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1.这种处理方法保证了每个进程有有一个父进程。</li></ul></li></ul><p>如果子进程在父进程之前终止:</p><ul><li>内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。</li></ul><p>一个由init进程收养的进程终止时会发生什么:</p><ul><li>init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。防止了在系统中塞满僵尸进程。</li></ul><h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。子进程终止是一个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。<br>调用wait或waitpid会发生什么:  </p><ol><li>如果其所有子进程都还在运行，则阻塞。</li><li>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li><li>如果它没有任何子进程，则立即出错返回。</li></ol><p>如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在随机时间点调用wait，则进程可能会阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">pid_t wait(int *statloc);</span><br><span class="line">pid_t waitpid(pid_t pid, int *statloc, int options);</span><br><span class="line">//成功，返回进程ID；出错返回0或-1</span><br></pre></td></tr></table></figure></p><p>两个函数的区别:</p><ul><li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞。</li><li>waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。  </li><li>如果子进程已经终止，并且是一个僵尸进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。</li><li>如调用者阻塞而且它有多个子进程，则在其某一个进程终止时，wait就立即返回。</li><li>因为wait返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。</li></ul><p>对于statloc参数:</p><ul><li>statloc是一个整形指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将参数指定为空指针。</li></ul><p>POSIX.1 定义了waitpid函数,函数中pid参数说明如下:</p><ul><li>pid == -1   等待任一子进程。此种情况下，waitpid与wait等效</li><li>pid &gt; 0     等待进程ID与pid相等的子进程</li><li>pid == 0    等待组ID等于调用进程组ID的任一子进程</li><li>pid &lt; -1    等待组ID等于pid绝对值的任一子进程  </li></ul><p>waitpid和wait出错返回</p><ul><li>waitpid函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由statloc指向的存储单元中。对于wait。</li><li>wait，其唯一的出错是调用进程没有子进程。而waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错。</li></ul><p>options参数或者是0，或者是如下图中常量按位或运算的结果:  </p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">WCONTINUED</td><td style="text-align:left">若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态(POSIX.1的XSI扩展)</td></tr><tr><td style="text-align:left">WNOHANG</td><td style="text-align:left">若由pid指定的子进程并不是理解可用的，则waitpid不阻塞，此时其返回值为0</td></tr><tr><td style="text-align:left">WUNTRACED</td><td style="text-align:left">若某实现支持作业控制，而由pid指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应于一个停止的子进程</td></tr></tbody></table><p>waitpid函数提供了wait函数没有提供的3个功能。  </p><ol><li>waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。</li><li>waitpid提供了一个wait的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞</li><li>waitpid通过WUNTRACED和WCONTINUED选项支持作业控制</li></ol><p>fork两次避免僵尸进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    if ((pid = fork())&lt;0)&#123;</span><br><span class="line">        err_sys(&quot;fork error&quot;);</span><br><span class="line">    &#125; else if (pid == 0)&#123;</span><br><span class="line">        //子进程</span><br><span class="line">        if ((pid = fork()) &lt; 0)</span><br><span class="line">            err_sys(&quot;fork error&quot;);</span><br><span class="line">        else if (pid &gt; 0)  //子进程 或 孙进程的父进程</span><br><span class="line">            exit(0);</span><br><span class="line"></span><br><span class="line">        //孙进程</span><br><span class="line">        sleep(2);</span><br><span class="line">        //打印孙进程的 父ID</span><br><span class="line">        printf(&quot;second child, parent pid = %ld\n&quot;,(long)getppid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //父进程</span><br><span class="line">    if (waitpid(pid, NULL, 0) != pid)</span><br><span class="line">        err_sys(&quot;waitpid error&quot;);</span><br><span class="line"></span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ojg7pw3bl.bkt.clouddn.com/figure8.8.png" alt=""><br>孙进程(用了更加形象的描述，原书中是第二个子进程)调用sleep以保证在打印其父ID时子进程已终止。在fork之后，父进程和子进程都可继续执行，并且我们无法预知哪一个会先执行。在fork之后，如果不使孙进程休眠，那么它可能比其父进程(也就是子进程)先执行，于是它打印的父进程ID将是创建它的父进程，而不是init进程(进程ID1)。  </p><h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>waitid类似于waitpid，但更加灵活<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</span><br><span class="line">//成功，返回0；出错，返回-1</span><br></pre></td></tr></table></figure></p><p>该函数与waitpid类似，waitid允许一个进程指定要等待的子进程。<br>id参数的作用与idtype的值相关，idtype类型在下表中  </p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">P_PID</td><td style="text-align:left">等待一特定进程：id包含要等待子进程的进程ID</td></tr><tr><td style="text-align:left">P_PGID</td><td style="text-align:left">等待一特定进程组的任一子进程：id包含要等待子进程的进程组ID</td></tr><tr><td style="text-align:left">P_ALL</td><td style="text-align:left">等待任一子进程：忽略id</td></tr></tbody></table><p>options参数是如下图中个标志的按位或运算  </p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">WCONTINUED</td><td style="text-align:left">等待一进程，它以前曾被停止，此后又继续，但其状态尚未报告</td></tr><tr><td style="text-align:left">WEXITED</td><td style="text-align:left">等待已退出的进程</td></tr><tr><td style="text-align:left">WNOHANG</td><td style="text-align:left">如无可用的子进程退出状态，立即返回而非阻塞</td></tr><tr><td style="text-align:left">WNOWAIT</td><td style="text-align:left">不破坏子进程退出状态。该子进程退出状态可由后续的wait、waitid或waitpid调用取得</td></tr><tr><td style="text-align:left">WSTOPPED</td><td style="text-align:left">等待一进程，它已经停止，但其状态尚未报告</td></tr></tbody></table><p>infop参数是指向siginfo结构的指针。该结构包含了造成子进程状态改变有关信号的详细信息。  </p><h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>这俩函数比上面3个函数提供的功能多一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line">pid_t wait3(int *statloc, int options, struct rusage *rusage);</span><br><span class="line">pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);</span><br><span class="line">//成功，返回进程ID；失败，返回-1</span><br></pre></td></tr></table></figure></p><p>返回的信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。  </p><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>竞争发生的原因：当多个进程都企图对共享数据进行某种处理，而最后结果又取决于进程运行的顺序时。<br>在上一小节中的程序。当孙进程打印其父ID时，有一个潜在的竞争条件:  </p><ul><li>如果孙进程在子进程之前运行，孙进程的父进程就是子进程。但是如果子进程先运行，并有足够的时间到达并执行exit，则孙进程的父进程就是init。</li></ul><p>如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止，则可使用下列形式的循环  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (getppid() != 1)</span><br><span class="line">    sleep(1);</span><br></pre></td></tr></table></figure><p>这种形式的循环称为轮询(polling),它的问题是浪费CPU时间，因为调用者每隔1S都被唤醒，然后进行条件测试。<br>为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制(第10章会介绍),进程间通信在15、17章介绍。  </p><h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。  </p><p>7种不同的exec函数原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);</span><br><span class="line">int execv(const char *pathname, char *const argv[]);</span><br><span class="line">int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */);</span><br><span class="line">int execve(const char *pathname, char *const argv[], char *const envp[]);</span><br><span class="line">int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);</span><br><span class="line">int execvp(const char *filename, char *const argv[]);</span><br><span class="line">int fexecve(int fd, char *const argv[], char *const envp[]);</span><br><span class="line">//出错返回-1，成功不返回</span><br></pre></td></tr></table></figure><p>这些函数的区别如下:</p><ul><li>前4个函数取路径名作为参数，后2个函数取文件名作为参数，最后一个取文件描述符作为参数。当指定filename作为参数时<ul><li>如果filename 中包含 /, 则就将其视为路径名</li><li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件</li></ul></li><li>PATH变量包含了一张目录表，如下所示:最后的路径前缀.表示当前目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/bin:/usr/bin:/usr/local/bin:.</span><br></pre></td></tr></table></figure></li></ul><p>出于安全性考虑在搜索路径中决不要包括当前目录  </p><ul><li>如果execlp或execvp使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的机器可执行文件，则就认为该文件是一个可执行文件，于是试着调用/bin/sh,并以该filename作为shell的输入</li><li>fexecve函数依赖调用进程，调用进程可以使用文件描述符验证所需要的文件并且无竞争地执行该文件</li></ul><p>另一个区别与参数表有关:  </p><ul><li>函数execl、execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数(execv,execvp,execve和fexecve),则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数。</li></ul><p>最后一个区别</p><ul><li>以e结尾的3个函数(execle、execve和fexecve)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境。通常，一个进程允许将其环境传播给其子进程，但有时也有这种情况，进程想要为子进程指定某一个确定的变量。例如，在初始化一个新登录shell时，login程序通常创建一个只定义少数几个变量的特殊环境，而我们在登录时，可以通过shell启动文件，将其他变量加到环境中。  <ul><li>在ISO C原型中，所有命令行参数、空指针和envp指针都用省略号(…)表示</li></ul></li></ul><p>POSIX.1 要求在exec时关闭打开目录流。这通常是由opendir函数实现的，它调用fcntl函数为对应于打开目录流的描述符设置执行时关闭标志。<br>在很多UNIX实现中，这7个函数中只有execve是内核的系统调用。其他6个只是函数库，他们最终都要调用该系统调用  </p><hr><h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中，特权以及访问控制，是基于用户ID和组ID的。所以我们需要合适的权限访问资源<br>setuid函数设置实际用户ID和有效用户ID,setgid函数设置实际组ID和有效组ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int setuid(uid_t uid);</span><br><span class="line">int setgid(gid_t gid);</span><br><span class="line">//成功返回0，出错返回-1</span><br></pre></td></tr></table></figure></p><ul><li>若进程具有超级用户权限，则setuid函数将实际用户ID，有效用户ID以及保存的设置用户ID(saved set-user-ID)设置为uid。</li><li>若进程没有超级用后权限，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID</li><li>如果都不满足，则errno设置为EPERM，并返回-1  </li></ul><p>(未完待续)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本章主要介绍了UNIX系统的进程控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建新进程、执行程序和进程终止&lt;/li&gt;
&lt;li&gt;进程属性的各种ID，他们如何受到进程控制原语的影响&lt;/li&gt;
&lt;li&gt;解释器文件和system函数&lt;/li&gt;
&lt;li&gt;进程会计机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>常用的命令总结</title>
    <link href="https://joewt.com/2018/02/11/decompression/"/>
    <id>https://joewt.com/2018/02/11/decompression/</id>
    <published>2018-02-11T12:48:31.000Z</published>
    <updated>2018-04-13T02:24:10.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用解压缩命令"><a href="#常用解压缩命令" class="headerlink" title="常用解压缩命令"></a>常用解压缩命令</h1><p>平常下个压缩文件 .zip .tar.gz可能居多。也就熟练了unzip、tar -zxvf 的使用，但碰到个其他格式的，很少用到的，还要去google(记性不好,虽然 -h 就有帮助)。索性自己写个吧   </p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r xxx.zip  xxx.c</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip xxx.zip</span><br></pre></td></tr></table></figure></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>.tar 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf xxx.tar xxx</span><br></pre></td></tr></table></figure></p><p>.tar 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf xxx.tar</span><br></pre></td></tr></table></figure></p><p>.tar.gz 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcvf xxx.tar.gz xxx</span><br></pre></td></tr></table></figure></p><p>.tar.gz 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf xxx.tar.gz</span><br></pre></td></tr></table></figure></p><p>.tar.bz2 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -jcvf xxx.tar.gz2 xxx</span><br></pre></td></tr></table></figure></p><p>.tar.bz2 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -jxvf xxx.tar.gz2</span><br></pre></td></tr></table></figure></p><h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><p>.rar 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rar -a xxx.rar xxx</span><br></pre></td></tr></table></figure></p><p>.rar 解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rar -x xxx.rar</span><br></pre></td></tr></table></figure></p><h1 id="资源查看"><a href="#资源查看" class="headerlink" title="资源查看"></a>资源查看</h1><p>查看文件大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du -ah --max-depth=1</span><br></pre></td></tr></table></figure></p><p>监控系统资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1 3</span><br></pre></td></tr></table></figure></p><p>查看内存使用状况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br></pre></td></tr></table></figure><p>查看CPU</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p>判断系统位数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ file /bin/ls</span><br></pre></td></tr></table></figure><p>查看Linux系统发行版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure><p>列出当前系统打开文件的工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lsof abc.txt //显示开启文件abc.txt的进程</span><br><span class="line">lsof -c abc  //显示abc进程现在打开的文件</span><br><span class="line">lsof -c -p  //1234 列出进程号为1234的进程所打开的文件</span><br><span class="line">lsof -g gid  //显示归属gid的进程情况</span><br><span class="line">lsof +d /usr/local/      //显示目录下被进程开启的文件</span><br><span class="line">lsof +D /usr/local/     //同上，但是会搜索目录下的目录，时间较长</span><br><span class="line">lsof -d 4 //显示使用fd为4的进程</span><br><span class="line">lsof -i //用以显示符合条件的进程情况</span><br></pre></td></tr></table></figure></p><p>获取 IPv4流量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i 4</span><br></pre></td></tr></table></figure></p><p>仅显示TCP流量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -iTCP</span><br></pre></td></tr></table></figure></p><p>显示指定用户打开了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -u mysql</span><br></pre></td></tr></table></figure></p><p>杀死指定用户所做的一切事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 `lsof -t -u nginx`</span><br></pre></td></tr></table></figure><p>查看指定的命令正在使用的文件和网络连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -c mysql</span><br></pre></td></tr></table></figure><p>查看指定进程ID已打开的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -p 12356</span><br></pre></td></tr></table></figure><blockquote><p>lsof <code>which httpd</code> //那个进程在使用apache的可执行文件<br>lsof /etc/passwd //那个进程在占用/etc/passwd<br>lsof /dev/hda6 //那个进程在占用hda6<br>lsof /dev/cdrom //那个进程在占用光驱<br>lsof -c sendmail //查看sendmail进程的文件使用情况<br>lsof -c courier -u ^zahn //显示出那些文件被以courier打头的进程打开，但是并不属于用户zahn<br>lsof -p 30297 //显示那些文件被pid为30297的进程打开<br>lsof -D /tmp 显示所有在/tmp文件夹中打开的instance和文件的进程。但是symbol文件并不在列<br>lsof -u1000 //查看uid是100的用户的进程的文件使用情况<br>lsof -utony //查看用户tony的进程的文件使用情况<br>lsof -u^tony //查看不是用户tony的进程的文件使用情况(^是取反的意思)<br>lsof -i //显示所有打开的端口<br>lsof -i:80 //显示所有打开80端口的进程<br>lsof -i -U //显示所有打开的端口和UNIX domain文件<br>lsof -i UDP@[url]www.akadia.com:123 //显示那些进程打开了到www.akadia.com的UDP的123(ntp)端口的链接<br>lsof -i tcp@ohaha.ks.edu.tw:ftp -r //不断查看目前ftp连接的情况(-r，lsof会永远不断的执行，直到收到中断信号,+r，lsof会一直执行，直到没有档案被显示,缺省是15s刷新)<br>lsof -i tcp@ohaha.ks.edu.tw:ftp -n //lsof -n 不将IP转换为hostname，缺省是不加上-n参数</p></blockquote><h2 id="没了"><a href="#没了" class="headerlink" title="没了"></a>没了</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用解压缩命令&quot;&gt;&lt;a href=&quot;#常用解压缩命令&quot; class=&quot;headerlink&quot; title=&quot;常用解压缩命令&quot;&gt;&lt;/a&gt;常用解压缩命令&lt;/h1&gt;&lt;p&gt;平常下个压缩文件 .zip .tar.gz可能居多。也就熟练了unzip、tar -zxvf 的使用，但碰到个其他格式的，很少用到的，还要去google(记性不好,虽然 -h 就有帮助)。索性自己写个吧   &lt;/p&gt;
&lt;h2 id=&quot;zip&quot;&gt;&lt;a href=&quot;#zip&quot; class=&quot;headerlink&quot; title=&quot;zip&quot;&gt;&lt;/a&gt;zip&lt;/h2&gt;&lt;p&gt;压缩&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ zip -r xxx.zip  xxx.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux命令" scheme="https://joewt.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://joewt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>进程环境(七)</title>
    <link href="https://joewt.com/2018/02/08/Progress-env/"/>
    <id>https://joewt.com/2018/02/08/Progress-env/</id>
    <published>2018-02-08T11:41:49.000Z</published>
    <updated>2018-02-08T11:59:28.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><p>主要介绍了如下内容:</p><ul><li>当程序执行时，其main函数是如何被调用的；</li><li>命令行参数是如何传递给应用程序的；</li><li>典型的存储空间布局是什么样式；</li><li>如何分配另外的存储空间；</li><li>进程如何使用环境变量；</li><li>进程的各种不同终止方式等</li></ul><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><p>main函数:  </p><p> c语言总是从main函数启动的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br></pre></td></tr></table></figure><p> 参数:  </p><ul><li><code>argc</code>: 命令行参数数目</li><li><p><code>argv</code>: 指向各个指针构成的数组  </p><p>当内核执行C语言程序时，在调用main函数前先调用一个特殊的启动例程<br>启动例程:<br>如果目标文件是由C代码编译生成的，用gcc做链接就没错了，整个程序的入口点是crt1.o中提供的_start，它首先做一些初始化工作（以下称为启动例程，Startup Routine），然后调用C代码中提供的main函数。所以，以前我们说main函数是程序的入口点其实不准确，<code>_start</code>才是真正的入口点，而main函数是被_start调用的。</p></li></ul></li></ol><ol><li><p>进程终止</p><p> 有8种方式使进程终止，其中5种是正常终止:</p><ul><li>从main函数返回</li><li>调用exit</li><li>调用_exit和_Exit</li><li>最后一个线程从其启动例程返回</li><li><p>从最后一个线程调用pthread_exit  </p><p>异常终止有3种:</p></li><li>调用abort</li><li>接到一个信号</li><li>最后一个线程对取消请求做出相应</li></ul><ol><li><p>退出函数<br>3个函数用于正常终止一个程序,<code>_exit</code>和_Exit立即进入内核，exit则先执行一些清理处理，然后返回内核。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void exit(int status);</span><br><span class="line">void _Exit(int status);</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure><p>由于历史原因，exit函数总是执行一个标准I/O库的清理关闭操作:对于所有打开流调用fclose函数<br>3个退出函数都带一个整形参数，称为终止状态(退出状态，exit status)</p></li><li><p>atexit函数<br>按照ISO C的规定，一个进程可以登记多至32个函数，这些函数将由exit自动调用。我们称这些函数为终止处理程序(exit handler),并调用atexit函数来登记这些函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int atexit(void (*func)(void));</span><br></pre></td></tr></table></figure><p>返回值:  </p></li></ol><ul><li>成功: 返回0</li><li><p>出错: 返回非0<br>atexit的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回一个值。exit调用这些函数的顺序刚好相反  </p><p>下图说明了一个c语言程序是如何启动和停止的<br><img src="http://ojg7pw3bl.bkt.clouddn.com/figure7.2.png" alt=""><br>内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显示或隐式地（通过调用exit）调用_exit或_Exit；进程也可以非自愿地由一个信号终止(如SINGUP、SINGINT等)<br>如下程序说明如何使用atexit函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">static void my_exit1(void);</span><br><span class="line">static void my_exit2(void);</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (atexit(my_exit2) != 0)</span><br><span class="line">        err_sys(&quot;不能注册my_exit2&quot;);</span><br><span class="line">    if (atexit(my_exit1) != 0)</span><br><span class="line">        err_sys(&quot;不能注册my_exit1&quot;);</span><br><span class="line">    if (atexit(my_exit1) != 0)</span><br><span class="line">        err_sys(&quot;不能注册my_exit1&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;main is done\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">static void my_exit1(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;first exit handler\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static void my_exit2(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;second exit handler\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下<br><img src="http://ojg7pw3bl.bkt.clouddn.com/figure7.3.png" alt=""></p></li></ul></li></ol><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时，调用exec的进程可将命令行参数传递给该新程序。这是UNIX shell的一部分操作。<br>如下程序将其所有命令行参数都回显到标准输出上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(int argc, char *artv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    for (i=0;i&lt;argc;i++)</span><br><span class="line">        printf(&quot;argv[%d]: %s\n&quot;,i,argv[i]);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ojg7pw3bl.bkt.clouddn.com/figure7.4.png" alt=""></p><h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一个环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的C字符串的地址。全局变量environ包含了该指针数组的地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern char **environ</span><br></pre></td></tr></table></figure></p><p>如果该环境包含5个字符串，那么它看起来就像如下图所示。其中，每个字符串的结尾处都显式地有一个null字符。我们称environ为环境指针，指针数组为环境表，其中个指针指向的字符串为环境字符串。<br><img src="http://ojg7pw3bl.bkt.clouddn.com/figure7.5.png" alt=""></p><h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>C程序一直由下列几部分组成:</p><ul><li>正文段。这是由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序(如文本编辑器、C编辑器和shell等)在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外而修改指令。</li><li><p>初始化数据段。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何函数外的声明:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int max = 99;</span><br></pre></td></tr></table></figure><p>  使此变量以其初值存放在初始化数据段中。</p></li><li><p>未初始化数据段。通常将此段称为bss段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”(block started by symbol)，在程序开始执行前，内核将此段中的数据初始化为0或空指针。函数外的声明:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long sum[100];</span><br></pre></td></tr></table></figure><p>  将此变量存放在非初始化数据段中。</p></li><li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息(如某些机器的寄存器的值)都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。通常以这种使用栈，C递归函数可以工作。递归函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量不会影响另一次函数调用实例中的变量。</li><li><p>堆。通常在堆中进行动态存储分配。由于历史上形式惯例，堆位于未初始化数据段h额栈之间。</p><p>  下图显示了一种典型的存储空间安排<br>  <img src="http://ojg7pw3bl.bkt.clouddn.com/figure7.6.png" alt=""><br>  对于32位Intelx86处理器上的Linux，正文段从0x08048000单元开始，栈底则在0xC0000000之下开始(在这种特定的结构中，栈从高地址向低地址方向增长)。堆顶和栈顶之间未用的虚拟空间很大  </p><ul><li>a.out中还有若干其他类型的段，如包含符号表的段、包含调试信息的段以及包含动态共享库链接表的段等。这些部分并不装载到进程执行的程序映像中。</li></ul></li></ul><p>size命令报告正文段、数据段和bss段的长度(以字节为单位)，例如<br><img src="http://ojg7pw3bl.bkt.clouddn.com/figure7-6.1.png" alt=""></p><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得可执行文件中不在包含公用的库函数，而只需在所有进程都可引用的存储区中保持这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方式将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑(假定参数的数目和类型都没有发生改变)</p><h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数。</p><ol><li>malloc，分配指定字节数的存储区。此存储区中的初始值不确定。</li><li>calloc，为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0。</li><li>realloc，增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void *malloc(size_t size);</span><br><span class="line">void *calloc(size_t mobj, size_t size);</span><br><span class="line">void *realloc(void *ptr, size_t newsize);</span><br><span class="line">// 成功返回非空指针；出错返回NULL</span><br><span class="line"></span><br><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure><ul><li>这3个分配函数返回的指针一定是适当对齐的，使其可用于任何数据对象。例如，在一个特定的系统上，如果最苛刻的对齐要求是，double必须在8的倍数地址单元处开始，那么这3个函数返回的指针都应该这样对齐。</li><li>因为这3个alloc函数都返回通用指针<code>void *</code>,所以如果在程序中包括了#include <stdlib.h>(以获得函数原型)，那么当我们将这些函数返回的指针赋予一个不同类型的指针时，就不需要显式执行强制类型转换。未声明函数的默认返回值为int，所以使用没有正确函数声明的强制类型转换可能会隐藏系统错误，因为int类型的长度与函数返回类型值的长度不同(本例中是指针)。</stdlib.h></li><li>函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池，以后，可在调用上述3个分配函数时再分配。</li><li>realloc函数使我们可以增、减以前分配存储区的长度。  </li><li>这些分配例程通常用sbrk系统调用实现。该系统调用扩充(或缩小)进程的堆</li><li>虽然sbrk可以扩充或缩小进程的存储空间，但是大多数malloc和free的实现都不减少进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核</li><li>如若一个进程调用malloc函数，但却忘记调用free函数，那么该进程占用的存储空间就会连续增加，这被称为泄露</li><li>因为存储空间分配出错很难跟踪，所以某些系统提供了这些函数的另一个实现版本。每次调用这3个分配函数中的任意一个或free时，它们都进行附加的检错。</li></ul><h3 id="替代的存储空间分配函数"><a href="#替代的存储空间分配函数" class="headerlink" title="替代的存储空间分配函数"></a>替代的存储空间分配函数</h3><p>有很多可替代malloc和free的函数。某些系统已经提供替代存储空间分配函数的库。另一些系统只提供标准的存储空间分配程序。如果需要，软件开发者可以下载替代函数。下面讨论某些替代函数和库</p><ol><li>libmalloc<br> 基于SVR4的UNIX系统，如Solaries，包含了libmalloc库，它提供了一套与ISO C存储空间分配函数相匹配的接口。libmalloc库包含mallopt函数，它使进程可以设置一些变量，并用它们来控制存储空间分配程序的操作。还可使用另一个名为mallinfo的函数，以对存储空间分配程序的操作进行统计。</li><li>vmalloc<br> Vo说明一种存储空间分配程序，它允许进程对于不同的存储区使用不同的技术。除了一些vmalloc特有的函数外，该库也提供了ISO C存储空间分配函数的仿真器</li><li><p>quick-fit<br> 历史上所使用的标准malloc算法是最佳适配或首次适配存储分配。quick-fit(快速适配)算法比上述两种算法快，但可能使用较多的存储空间Weinstock和Wulf对该算法进行了描述，该算法基于将存储空间分裂成各种长度的缓冲区，并将未使用的缓冲区按其长度组成不同的空闲区列表。现在许多分配程序都基于快速适配。</p></li><li><p>jemalloc<br> jemalloc函数实现是FreeBSD8.0中默认的存储空间分配程序，它是库函数malloc族在FreeBSD中的实现。它的设计具有良好的扩展性，可用于多处理器系统中使用多线程的应用程序。<a href="https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf" target="_blank" rel="noopener">Evans</a>说明了具体实现及其性能评估。</p></li><li><p>TCMalloc<br> TCMalloc函数用于替代malloc函数族以提供高性能、高扩展性和高存储效率。从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中时，它使用线程-本地高速缓存来避免锁开销。它还有内置的堆检查程序和堆分析程序帮助调试和分析动态存储的使用。</p></li><li><p>函数alloca<br> 还有一个函数，它的调用序列与malloc相同，但是他是在当前函数的栈帧上分配存储空间，而不是在堆中。其优点是：当函数返回时，自动释放它所使用的栈帧，所以不必再为释放空间而费心。其缺点是：alloca函数增加了栈帧的长度，而某些系统在函数已被调用后不能增加栈帧长度，于是也就不能支持alloca函数。尽管如此，很多软件包还是使用alloca函数，也有很多系统实现了该函数。(本系统中的4个平台都提供了)</p></li></ol><p>(未更新完)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程环境&quot;&gt;&lt;a href=&quot;#进程环境&quot; class=&quot;headerlink&quot; title=&quot;进程环境&quot;&gt;&lt;/a&gt;进程环境&lt;/h2&gt;&lt;p&gt;主要介绍了如下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当程序执行时，其main函数是如何被调用的；&lt;/li&gt;
&lt;li&gt;命令行参数是如何传递给应用程序的；&lt;/li&gt;
&lt;li&gt;典型的存储空间布局是什么样式；&lt;/li&gt;
&lt;li&gt;如何分配另外的存储空间；&lt;/li&gt;
&lt;li&gt;进程如何使用环境变量；&lt;/li&gt;
&lt;li&gt;进程的各种不同终止方式等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>标准I/O库(五)</title>
    <link href="https://joewt.com/2018/02/04/std-IO/"/>
    <id>https://joewt.com/2018/02/04/std-IO/</id>
    <published>2018-02-04T09:18:44.000Z</published>
    <updated>2018-02-14T12:35:48.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UNIX一切皆文件，掌握文件的操作尤其重要。以下的内容主要是apue上面第五章内容，介绍了标准I/O库的一些内容。</p><hr><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>标准I/O库，他们的操作都是围绕流进行的<br>字符分为单字节和多字节，流的定向决定了是所读、写的字符是单字节还是多字节的。当一个流被创建时，并没有定向。使用多字节I/O函数，流的定向就被设置为宽定向，单字节同理。只有两个函数可以改变流的定向，freopen和fwide  </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;wchar.h&gt;</span><br><span class="line">int fwide(FILE *fp, int mode);</span><br><span class="line">//若流是宽定向的，返回正值；若流是单字节定向的返回负值，流未定向，返回0</span><br></pre></td></tr></table></figure><p>mode参数的说明  </p><ul><li>mode为负，fwide将使指定的流是单字节定向的</li><li>mode为正，fwide将使指定的流是宽定向的</li><li>mode为0，不设置流的定向，但返回标识该流定向的值</li></ul><hr><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少read和write的调用。<br>标准I/O提供了3种缓冲</p><ol><li>全缓冲。只有填满标准I/O缓冲区后才进行实际的I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作是，相关I/O函数通常调用malloc获得需要的缓冲。</li><li>行缓冲。当在输入输出中遇到换行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(fputc),但只有在写了一行之后才进行实际的I/O操作。当涉及一个终端时(如标准输入和标准输出)，通常使用行缓冲。</li><li>不带缓冲。标准I/O库不对字符进行缓冲存储。例如，若用标准I/O函数fputs写15个字符到不带缓冲的流中，我们就期望这15个字符能立即输出，就很有可能使用write函数将这些字符写到相关联的打开文件中。</li></ol><p>标准错误流stderr通常是不带缓冲的。<br>ISO C要求下列缓冲特征</p><ul><li>当且仅当标准输入和标准输出并不指向交互设备时，他们才是全缓冲的</li><li>标准错误绝不是全缓冲的</li></ul><p>很多系统默认使用下列类型的缓冲</p><ul><li>标准错误是不带缓冲的</li><li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的</li></ul><p>如果不喜欢系统默认的可使用下列两个函数中的一个更改缓冲类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdiio.h&gt;</span><br><span class="line">void setbuf(FILE *restrict fp, char *restrict buf);</span><br><span class="line">int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);</span><br></pre></td></tr></table></figure><p>在任何时候都可以强制冲洗一个流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fflush(FILE *fp);</span><br><span class="line">//成功返回0，失败返回EOF</span><br></pre></td></tr></table></figure></p><hr><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>下列3个函数打开一个标准I/O流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *fopen(const char *restrict pathname, const char *restrict type);</span><br><span class="line">FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);</span><br><span class="line">FILE *fdopen(int fd, const char *type);</span><br><span class="line">//成功返回文件指针，失败返回NULL</span><br></pre></td></tr></table></figure></p><p>这3个函数区别如下</p><ol><li>fopen函数打开路径名为pathname的一个指定的文件</li><li>freopen函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若流已经定向，则使用freopen清除定向。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准错误</li><li>fdopen函数取一个已有的文件描述符(我们可能从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到此文件描述符)，并使一个标准I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。因为这些特殊类型文件不能使用标准I/O函数fopen打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准I/O流与该描述符相结合。</li></ol><p>fdopn是 POSIX.1 具有的</p><p>type参数说明如下</p><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">说明</th><th style="text-align:left">open(2)标志</th></tr></thead><tbody><tr><td style="text-align:left">r或rb</td><td style="text-align:left">为读而打开</td><td style="text-align:left">O_RDONLY</td></tr><tr><td style="text-align:left">w或wb</td><td style="text-align:left">把文件截断至0长，或为写而创建</td><td style="text-align:left">O_WRONLY</td><td>O_CREAT</td><td>O_TRUNC</td></tr><tr><td style="text-align:left">a或ab</td><td style="text-align:left">追加；为在文件尾而写打开，或为写而创建</td><td style="text-align:left">O_WRONLY</td><td>O_CREAT</td><td>O_APPEND</td></tr><tr><td style="text-align:left">r+或r+b或rb+</td><td style="text-align:left">为读和写打开</td><td style="text-align:left">O_RDWR</td></tr><tr><td style="text-align:left">w+或w+b或w+</td><td style="text-align:left">把文件截断为0长，或为读和写而打开</td><td style="text-align:left">O_RDWR</td><td>O_CREAT</td><td>O_TRUNC</td></tr><tr><td style="text-align:left">a+或a+b或ab+</td><td style="text-align:left">为在文件尾读和写而打开或创建</td><td style="text-align:left">O_RDWR</td><td>O_CREAT</td><td>O_APPEND</td></tr></tbody></table><hr><h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>一旦打开了流，则可在3种不同类型的非格式化I/O中进行选择，对其进行读、写操作  </p><ol><li>每次一个字符的I/O。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。</li><li>每次一行的I/O。如果想要一次读或写一行，则使用fgets和fputs。每行都以一个换行符终止。当调用fgets时，应说明能处理的最大行长。</li><li>直接I/O。fread和fwrite函数支持这种类型的I/O。每次I/O操作读或写某种数量对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。</li></ol><h4 id="1-输入函数"><a href="#1-输入函数" class="headerlink" title="1. 输入函数"></a>1. 输入函数</h4><p>以下三个函数可用于一次读一个字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int getc(FILE *fp);</span><br><span class="line">int fgetc(FILE *fp);</span><br><span class="line">int getchar(void);</span><br><span class="line">//成功返回下一个字符，失败或到达文件末尾，返回EOF</span><br></pre></td></tr></table></figure></p><p>函数getchar()等同于 getc(stdin)。getc可被实现为宏，fgetc不能。意味着以下几点</p><ol><li>getc的参数不应当是具有副作用的表达式，因此它可能会被计算多次</li><li>因为fgetc一定是一个函数，所以它可以得到地址。这就允许将fgetc的地址作为一个参数传递给另一个函数</li><li>调用fgetc所需时间很可能比调用getc要长，因为调用函数所需时间通常长于调用宏</li></ol><p>不管是出错还是到达文件尾端，这3个函数都返回同样的值。为了区分这两种不同的情况，必须调用ferror或feof。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int ferror(FILE *fp);</span><br><span class="line">int feof(FILE *fp);</span><br><span class="line">//两个函数的返回值，若成功返回非0(真)；否则返回0(假)</span><br><span class="line">void clearerr(FILE *fp);</span><br></pre></td></tr></table></figure></p><p>在大多数实现中，为每个流在FILE对象中维护了两个标志:</p><ul><li>出错标志</li><li>文件结束标志</li></ul><p>调用clearerr可以清除这两个标志。<br>从流中读取数据以后，可以调用ungetc将字符再压送回流中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdiio.h&gt;</span><br><span class="line">int ungetc(int c,FILE *fp);</span><br><span class="line">//成功返回c，出错返回EOF</span><br></pre></td></tr></table></figure></p><h4 id="2-输出函数"><a href="#2-输出函数" class="headerlink" title="2. 输出函数"></a>2. 输出函数</h4><p>对应上面每个输入函数都有一个输出函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int putc(int c, FILE *fp);</span><br><span class="line">int fputc(int c, FILE *fp);</span><br><span class="line">int putchar(int c);</span><br><span class="line">//成功返回c，出错返回EOF</span><br></pre></td></tr></table></figure></p><hr><h2 id="每次一行I-O"><a href="#每次一行I-O" class="headerlink" title="每次一行I/O"></a>每次一行I/O</h2><p>下面两个函数提供每次输入一行的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *fgets(char *restrict buf, int n, FILE *restrict fp);</span><br><span class="line">char *gets(char *buf);</span><br><span class="line">//成功返回buf；若已到达文件尾端或出错，返回NULL</span><br></pre></td></tr></table></figure></p><p>推荐使用fgets<br>每个输入都有对应的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fputs(const char* restrict str, FILE *restrict fp);</span><br><span class="line">int puts(const char *str);</span><br><span class="line">//成功返回非负值，失败返回EOF</span><br></pre></td></tr></table></figure></p><hr><h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>系统提供了以下函数执行二进制I/O操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</span><br><span class="line">size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</span><br><span class="line">//两个函数的返回值：读或写的对象数</span><br></pre></td></tr></table></figure></p><hr><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><p>有3种方式定位标准I/O流  </p><ol><li>ftell和fseek函数。这俩函数都是假定文件的位置可以存放在一个长整数中</li><li>ftellofseeko函数。Single UNIX Specification引入了这两个函数，使文件偏移量可以不必一定使用长整形。他们使用off_t数据类型替代了长整形</li><li>fgetpos和fsetpos函数。这两个函数是由ISO C引入的。他们使用一个抽象数据类型fpos_t记录文件位置。这种数据类型可以根据需要定义一个足够大的数，用以记录文件位置。</li></ol><p>需要移植到非UNIX系统上需要使用fgetpos和fsetpos函数</p><hr><h2 id="格式化I-O"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h2><p>格式化输出是由5个printf函数处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int printf(const char* restrict format, ...);</span><br><span class="line">int fprintf(FIFE *restrict fp, const char* restrict format, ...);</span><br><span class="line">int dprintf(int fd, const char* restrict format, ...);</span><br><span class="line">//若成功返回输出字符数。出错返回负值</span><br><span class="line">int sprintf(char* restrict buf, const char* restrict format, ...);</span><br><span class="line">//成功返回存入数组的字符数，若编码出错返回负值</span><br><span class="line">int snprintf(char* restrict buf, size_t n, const char* restrict format, ...);</span><br><span class="line">若缓冲区足够大，返回将要存入数组的字符数，若编码出错返回负值</span><br></pre></td></tr></table></figure></p><p>printf将格式化的数据写到标准输出，fprintf写至指定的流，dprintf写至指定的文件描述符，sprintf将格式化的字符送入数组buf中。sprintf在该数组的尾端自动加一个null字节，但该字符不包括在返回值中。  </p><h4 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#incude &lt;stdio.h&gt;</span><br><span class="line">int scanf(const char* restrict format, ...);</span><br><span class="line">int fscanf(FIFE *restrict fp, const char* restrict format, ...);</span><br><span class="line">int sscanf(const char* restrict buf, const char* restrict format, ...);</span><br><span class="line">//3个函数的返回值，赋值的输入项数，若出错或任一转换前已到达文件尾端，返回EOF</span><br></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>ISO C标准I/O库提供了两个函数以帮助创建临时文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdiio.h&gt;</span><br><span class="line">char *tmpnam(char *ptr);</span><br><span class="line">FILE *tmpfile(void);</span><br><span class="line">//成功返回文件指针，出错返回null</span><br></pre></td></tr></table></figure></p><p>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时，都产生一个不同的路径名，最多调用次数是TMP_MAX(定义在<stdio.h>在mac系统该值为308915776)<br>若ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。后续调用tmpnam时，会重写该静态区(这意味着，如果我们调用此函数多次，而且想保存路径名，则我们应该保存该文件的副本，而不是指针的副本)。如若ptr不是NULL，则认为它应该是指向长度至少是L_tmpnam个字符的数组(L_tmpnam定义在<stdio.h>中mac下为1024)。所产生的路径名存放在该数组中，ptr也作为函数值返回。<br>tmpfile创建一个临时二进制文件(类型wb+)，在关闭该文件或程序结束时将自动删除这种文件。注意，UNIX对二进制文件不进行特殊区分。  </stdio.h></stdio.h></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;UNIX一切皆文件，掌握文件的操作尤其重要。以下的内容主要是apue上面第五章内容，介绍了标准I/O库的一些内容。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;流和FILE对象&quot;&gt;&lt;a href=&quot;#流和FILE对象&quot; class=&quot;headerlink&quot; title=&quot;流和FILE对象&quot;&gt;&lt;/a&gt;流和FILE对象&lt;/h2&gt;&lt;p&gt;标准I/O库，他们的操作都是围绕流进行的&lt;br&gt;字符分为单字节和多字节，流的定向决定了是所读、写的字符是单字节还是多字节的。当一个流被创建时，并没有定向。使用多字节I/O函数，流的定向就被设置为宽定向，单字节同理。只有两个函数可以改变流的定向，freopen和fwide  &lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python-mysql</title>
    <link href="https://joewt.com/2018/02/03/python-mysql/"/>
    <id>https://joewt.com/2018/02/03/python-mysql/</id>
    <published>2018-02-03T13:54:28.000Z</published>
    <updated>2018-02-04T14:26:11.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Python-安装mysql出问题"><a href="#Python-安装mysql出问题" class="headerlink" title="Python 安装mysql出问题"></a>Python 安装mysql出问题</h4><ol><li>使用的是mamp 用的里面的mysql 当我使用pip install mysql-python安装的时候出现 mysql_config没有找到的错误.<br>解决办法：环境变量添加 export PATH=”/Application/MAMP/Library/bin:$PATH”</li><li>通过 brew install mysql-connector-c  pip install mysql-python 安装出现IndexError:string index out of range<a id="more"></a>解决办法：By finding out the information that mysql-connector-cmight come to the conclusion that the configuration by brew installation may be incorrect , open the /usr/local/bin/mysql_config script to modify some of the contents of it:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Create options</span><br><span class="line">Libs = &quot;-L $ pkglibdir &quot;</span><br><span class="line">Libs = &quot; $ libs   -l&quot;</span><br></pre></td></tr></table></figure></li></ol><p>change into:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Create options</span><br><span class="line">Libs = &quot;- L $ pkglibdir&quot;</span><br><span class="line">Libs = &quot;$ libs -lmysqlclient -lssl -lcrypto&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Python-安装mysql出问题&quot;&gt;&lt;a href=&quot;#Python-安装mysql出问题&quot; class=&quot;headerlink&quot; title=&quot;Python 安装mysql出问题&quot;&gt;&lt;/a&gt;Python 安装mysql出问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用的是mamp 用的里面的mysql 当我使用pip install mysql-python安装的时候出现 mysql_config没有找到的错误.&lt;br&gt;解决办法：环境变量添加 export PATH=”/Application/MAMP/Library/bin:$PATH”&lt;/li&gt;
&lt;li&gt;通过 brew install mysql-connector-c  pip install mysql-python 安装出现IndexError:string index out of range
    
    </summary>
    
    
      <category term="python" scheme="https://joewt.com/tags/python/"/>
    
      <category term="mysql" scheme="https://joewt.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>apue配置</title>
    <link href="https://joewt.com/2018/02/03/apue-deploy/"/>
    <id>https://joewt.com/2018/02/03/apue-deploy/</id>
    <published>2018-02-03T00:55:00.000Z</published>
    <updated>2018-02-04T14:30:16.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="apue-配置问题"><a href="#apue-配置问题" class="headerlink" title="apue 配置问题"></a>apue 配置问题</h3><h5 id="mac-系统配置"><a href="#mac-系统配置" class="headerlink" title="mac 系统配置"></a>mac 系统配置</h5><p>执行 make all</p><p>将 ./apue.3e/include/下的  apue.h 复制到 /usr/local/include/下<br>将 ./apue.3e/lib/下的 error.c 复制到 /usr/local/include/ 下<br>然后修改 apue.h文件  在最后添加 #include “error.c”<br><a id="more"></a></p><h5 id="Linux-系统的配置如上"><a href="#Linux-系统的配置如上" class="headerlink" title="Linux 系统的配置如上"></a>Linux 系统的配置如上</h5><p>使用的是centos7 系统 编译源码的时候发现如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -ansi -I../include -Wall -DLINUX -D_GNU_SOURCE  barrier.c -o barrier  -L../lib -lapue -pthread -lrt -lbsd</span><br><span class="line">/tmp/ccF6O2ef.o: In function `thr_fn&apos;:</span><br><span class="line">barrier.c:(.text+0x80): undefined reference to `heapsort&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[1]: *** [barrier] Error 1</span><br><span class="line">make[1]: Leaving directory `/home/learnApue/apue.3e/threads&apos;</span><br><span class="line">make: *** [all] Error 1</span><br></pre></td></tr></table></figure></p><p>解决办法 <a href="https://pkgs.org/" target="_blank" rel="noopener">这里</a> 下载两个包<br>按照顺序安装<br>安装方法 rpm -Uvh xxxx.rpm  </p><p>这样就可以使用了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;apue-配置问题&quot;&gt;&lt;a href=&quot;#apue-配置问题&quot; class=&quot;headerlink&quot; title=&quot;apue 配置问题&quot;&gt;&lt;/a&gt;apue 配置问题&lt;/h3&gt;&lt;h5 id=&quot;mac-系统配置&quot;&gt;&lt;a href=&quot;#mac-系统配置&quot; class=&quot;headerlink&quot; title=&quot;mac 系统配置&quot;&gt;&lt;/a&gt;mac 系统配置&lt;/h5&gt;&lt;p&gt;执行 make all&lt;/p&gt;
&lt;p&gt;将 ./apue.3e/include/下的  apue.h 复制到 /usr/local/include/下&lt;br&gt;将 ./apue.3e/lib/下的 error.c 复制到 /usr/local/include/ 下&lt;br&gt;然后修改 apue.h文件  在最后添加 #include “error.c”&lt;br&gt;
    
    </summary>
    
      <category term="UNIX" scheme="https://joewt.com/categories/UNIX/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
</feed>
