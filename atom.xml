<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JOE&#39;S BLOG</title>
  <icon>https://www.gravatar.com/avatar/4d7b6eb90ff6162c577a0163e274b344</icon>
  <subtitle>好记性不如烂键盘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joewt.com/"/>
  <updated>2020-05-10T07:06:10.533Z</updated>
  <id>https://joewt.com/</id>
  
  <author>
    <name>JOE</name>
    <email>joewttx@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GO语言测试&amp;文档&amp;调试</title>
    <link href="https://joewt.com/2020/05/11/go-test-doc-debug/"/>
    <id>https://joewt.com/2020/05/11/go-test-doc-debug/</id>
    <published>2020-05-11T04:00:00.000Z</published>
    <updated>2020-05-10T07:06:10.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>多做测试 少做调试</p><p>传统测试 vs 表格驱动测试   </p><h3 id="传统测试"><a href="#传统测试" class="headerlink" title="传统测试"></a>传统测试</h3><ul><li>测试数据和测试逻辑混在一起 </li><li>出错信息不明确</li><li>一旦一个数据出错测试全部结束   </li></ul><h3 id="表格驱动测试"><a href="#表格驱动测试" class="headerlink" title="表格驱动测试"></a>表格驱动测试</h3><ul><li>分离测试数据和测试逻辑</li><li>明确的出错信息</li><li>可以部分失败</li></ul><p>go语言 测试文件跟与要测试的文件同目录，文件名规则如下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_test.go</span><br></pre></td></tr></table></figure><p>命令行运行测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test .</span><br></pre></td></tr></table></figure></p><p>测试用例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">tests := []struct &#123;a, b, c int&#125;&#123;</span><br><span class="line">&#123;1,2,3&#125;,</span><br><span class="line">&#123;2,3,5&#125;,</span><br><span class="line">&#123;4,6,10&#125;,</span><br><span class="line">&#123;3,4,0&#125;,</span><br><span class="line">&#123;19,1,20&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, tt := range tests &#123;</span><br><span class="line">if actual := add(tt.a, tt.b); actual != tt.c &#123;</span><br><span class="line">t.Errorf(&quot;add(%d,%d); &quot;+&quot;got %d; expected %d&quot;,tt.a,tt.b,actual,tt.c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h4><p>命令行运行<br>go test -coverprofile=c.out  </p><p>一般生成的文件很难理解  </p><p>使用一个工具</p><p>go tool cover -html=c.out</p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>可以使用命令行<br>go test -bench .</p><p>func BenchmarkSubstr(b *testing.B) {<br>    a := 19999<br>    c := 123123<br>    for i := 0; i &lt; b.N; i++ {<br>        add(a, c)<br>    }<br>}</p><p>进行性能调优  </p><p>生成一个文件<br>go test -bench . -cpuprofile=cpu.out</p><p>运行这个<br>go tool pprof cpu.out<br>有很多功能 使用最简单的 web</p><p>如果想用web的话需要安装一个包<br><a href="http://graphviz.org/download/" target="_blank" rel="noopener">Download</a><br>然后查看是哪一步占用的时间多</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>godoc -http :6060<br>在本地生成一个文档，有go语言的文档，也有自己的写的代码的文档   </p><p>go语言注释可以随意写<br>go doc fmt.Println<br>打印文档注释  </p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>go build -gcflags “-N -l” gdbfile.go</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h1&gt;&lt;p&gt;多做测试 少做调试&lt;/p&gt;
&lt;p&gt;传统测试 vs 表格驱动测试   &lt;/p&gt;
&lt;h3 id=&quot;传统测试&quot;&gt;&lt;a href=&quot;#传统测试&quot; class=&quot;headerlink&quot; title=&quot;传统测试&quot;&gt;&lt;/a&gt;传统测试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;测试数据和测试逻辑混在一起 &lt;/li&gt;
&lt;li&gt;出错信息不明确&lt;/li&gt;
&lt;li&gt;一旦一个数据出错测试全部结束   &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;表格驱动测试&quot;&gt;&lt;a href=&quot;#表格驱动测试&quot; class=&quot;headerlink&quot; title=&quot;表格驱动测试&quot;&gt;&lt;/a&gt;表格驱动测试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分离测试数据和测试逻辑&lt;/li&gt;
&lt;li&gt;明确的出错信息&lt;/li&gt;
&lt;li&gt;可以部分失败&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go语言 测试文件跟与要测试的文件同目录，文件名规则如下  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;add_test.go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;命令行运行测试用例&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;go test .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;测试用例代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &amp;quot;testing&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func TestAdd(t *testing.T) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tests := []struct &amp;#123;a, b, c int&amp;#125;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;1,2,3&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;2,3,5&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;4,6,10&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;3,4,0&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;19,1,20&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for _, tt := range tests &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if actual := add(tt.a, tt.b); actual != tt.c &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			t.Errorf(&amp;quot;add(%d,%d); &amp;quot;+&amp;quot;got %d; expected %d&amp;quot;,tt.a,tt.b,actual,tt.c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Golang编程" scheme="https://joewt.com/categories/Golang%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Golang" scheme="https://joewt.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>GO语言并发编程</title>
    <link href="https://joewt.com/2020/05/10/go-goroutine/"/>
    <id>https://joewt.com/2020/05/10/go-goroutine/</id>
    <published>2020-05-10T12:00:00.000Z</published>
    <updated>2020-05-10T06:49:57.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go语言并发编程"><a href="#go语言并发编程" class="headerlink" title="go语言并发编程"></a>go语言并发编程</h2><p>goroutine  </p><p>轻量级 线程<br>非抢占式多任务处理，由协程主动交出控制权<br>编译器/解释器/虚拟机层面的多任务</p><p>使用go关键字  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//检测数据冲突</span><br><span class="line">go run -race main.go</span><br></pre></td></tr></table></figure><p>channel<br>goroutine之间通信<br>不要通过共享内存来通信；通过通信来共享内存  </p><p>chan&lt;- int 表示只发送不能接收<br>&lt;-chan int 表示只接收不能发送  </p><p>所有的并发问题 都可以用一致的、简单的既定的模式来规避。所有可能的话，将变量限定在goroutine内部，如果是多个goroutine都需要访问的变量，使用互斥条件来访问   </p><p>go的调度器，当一个goroutine调用了time.Sleep等 阻塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一个goroutine。这种调度不需要进入内核的上下文，所以比线程的代价低  </p><a id="more"></a><h3 id="几个-runtime包中处理goruntine的函数"><a href="#几个-runtime包中处理goruntine的函数" class="headerlink" title="几个 runtime包中处理goruntine的函数"></a>几个 runtime包中处理goruntine的函数</h3><p>Goexit</p><p>退出当前执行的goroutine，但是defer函数还会继续调用</p><p>Gosched</p><p>让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p><p>NumCPU</p><p>返回 CPU 核数量</p><p>NumGoroutine</p><p>返回正在执行和排队的任务总数</p><p>GOMAXPROCS</p><p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>chan 的方向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">pings := make(chan string, 1)</span><br><span class="line">pongs := make(chan string, 1)</span><br><span class="line">ping(pings, &quot;password message&quot;)</span><br><span class="line">pong(pings, pongs)</span><br><span class="line">fmt.Println(&lt;-pongs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//pings 只能用来发送channel</span><br><span class="line">func ping(pings chan&lt;- string, msg string) &#123;</span><br><span class="line">pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//pings 只能用来接收channel</span><br><span class="line">func pong(pings &lt;-chan string, pongs chan&lt;- string) &#123;</span><br><span class="line">msg := &lt;-pings</span><br><span class="line">pongs &lt;- msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>select<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">c1 := make(chan string)</span><br><span class="line">c2 := make(chan string)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">c1 &lt;- &quot;one&quot;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">c2 &lt;- &quot;two&quot;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case msg1 := &lt;-c1:</span><br><span class="line">fmt.Println(&quot;received&quot;, msg1)</span><br><span class="line">case msg2 := &lt;-c2:</span><br><span class="line">fmt.Println(&quot;received&quot;, msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;go语言并发编程&quot;&gt;&lt;a href=&quot;#go语言并发编程&quot; class=&quot;headerlink&quot; title=&quot;go语言并发编程&quot;&gt;&lt;/a&gt;go语言并发编程&lt;/h2&gt;&lt;p&gt;goroutine  &lt;/p&gt;
&lt;p&gt;轻量级 线程&lt;br&gt;非抢占式多任务处理，由协程主动交出控制权&lt;br&gt;编译器/解释器/虚拟机层面的多任务&lt;/p&gt;
&lt;p&gt;使用go关键字  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//检测数据冲突&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;go run -race main.go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;channel&lt;br&gt;goroutine之间通信&lt;br&gt;不要通过共享内存来通信；通过通信来共享内存  &lt;/p&gt;
&lt;p&gt;chan&amp;lt;- int 表示只发送不能接收&lt;br&gt;&amp;lt;-chan int 表示只接收不能发送  &lt;/p&gt;
&lt;p&gt;所有的并发问题 都可以用一致的、简单的既定的模式来规避。所有可能的话，将变量限定在goroutine内部，如果是多个goroutine都需要访问的变量，使用互斥条件来访问   &lt;/p&gt;
&lt;p&gt;go的调度器，当一个goroutine调用了time.Sleep等 阻塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一个goroutine。这种调度不需要进入内核的上下文，所以比线程的代价低  &lt;/p&gt;
    
    </summary>
    
      <category term="Golang编程" scheme="https://joewt.com/categories/Golang%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Golang" scheme="https://joewt.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>GO语言基础</title>
    <link href="https://joewt.com/2020/05/10/go-base/"/>
    <id>https://joewt.com/2020/05/10/go-base/</id>
    <published>2020-05-10T04:00:00.000Z</published>
    <updated>2020-05-10T06:39:15.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-amp-使用"><a href="#安装-amp-使用" class="headerlink" title="安装&amp;使用"></a>安装&amp;使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载源码包到你想放置的目录,然后设置环境变量  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=$HOME/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line">export GOPATH=/data/work</span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>有2种方式运行程序  </p><p>解释性语言的常用运行方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></p><p>先编译成二进制,然后运行  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o main main.go &amp; ./main</span><br></pre></td></tr></table></figure><p>跨平台编译, 编译完后把二进制包以及必要的资源文件copy到需要使用的机器上，无需安装环境即可使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOOS=darwin GOARCH=amd64 go build -o main main.go  </span><br><span class="line">GOOS=windows GOARCH=amd64 go build -o main main.go  </span><br><span class="line">GOOS=linux GOARCH=amd64 go build -o main main.go</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="go语言组成"><a href="#go语言组成" class="headerlink" title="go语言组成"></a>go语言组成</h2><p>go语言一共有25个关键字,基本上把这25个关键字“掌握”就能写go语言程序了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure></p><p>go语言内置的数据类型标识符(20个)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">数值(16)</span><br><span class="line">* 整型(12)</span><br><span class="line">  byte int int8 int16 int32 int64  </span><br><span class="line">  uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line">* 浮点型(2)</span><br><span class="line">  float32 float64</span><br><span class="line">* 复数型(2)</span><br><span class="line">  complex64 complex128</span><br><span class="line"></span><br><span class="line">字符和字符串型(2)</span><br><span class="line">  string rune</span><br><span class="line"></span><br><span class="line">接口型(1)</span><br><span class="line">  error</span><br><span class="line"></span><br><span class="line">布尔型(1)</span><br><span class="line">  bool</span><br></pre></td></tr></table></figure></p><p>go语言内置函数(15个)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make new len cap append copy delete panic recover close complex real image print println</span><br></pre></td></tr></table></figure></p><p>常量标识符(4个)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true false</span><br><span class="line">iota</span><br><span class="line">nil</span><br></pre></td></tr></table></figure></p><p>空白标识符(1个)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ 一般用在引入包和变量返回时使用，只是引入包的时候以及忽略变量返回值的时候使用</span><br></pre></td></tr></table></figure></p><p>go语言的操作符(47个)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ &amp; += &amp;= &amp;&amp; == != ( )</span><br><span class="line">- | -= |= || &lt; &lt;=  [ ]</span><br><span class="line">* ^ *= ^= &lt;- &gt; &gt;=  &#123; &#125;</span><br><span class="line">/ &lt;&lt; /= &lt;&lt;= ++ = := , ;</span><br><span class="line">% &gt;&gt; %= &gt;&gt;= -- ! ... . :</span><br><span class="line">&amp;^ &amp;^=</span><br></pre></td></tr></table></figure></p><p>一个go语言程序的组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  fmt.Println(&quot;hello world!!!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package import func</span><br></pre></td></tr></table></figure></p><p>标识符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main fmt Println</span><br></pre></td></tr></table></figure></p><p>字面量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;fmt&quot; &quot;hello world!!&quot;</span><br></pre></td></tr></table></figure></p><p>操作符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ) &#123; &#125; .</span><br></pre></td></tr></table></figure></p><p>送给所有学习go的小伙伴的几句话  </p><p>Don’t think you have to know everything to be useful<br>Even senior Go Developers don’t know it all<br>Just get stuck in, we’ll help if we can<br>Don’t obsess over performance of code, obsess over making it clear<br>Have fun  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装-amp-使用&quot;&gt;&lt;a href=&quot;#安装-amp-使用&quot; class=&quot;headerlink&quot; title=&quot;安装&amp;amp;使用&quot;&gt;&lt;/a&gt;安装&amp;amp;使用&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;下载源码包到你想放置的目录,然后设置环境变量  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export GOROOT=$HOME/go&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$PATH:$GOROOT/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export GOPATH=/data/work&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$PATH:$GOPATH/bin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;p&gt;有2种方式运行程序  &lt;/p&gt;
&lt;p&gt;解释性语言的常用运行方式&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;go run main.go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先编译成二进制,然后运行  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;go build -o main main.go &amp;amp; ./main&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;跨平台编译, 编译完后把二进制包以及必要的资源文件copy到需要使用的机器上，无需安装环境即可使用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GOOS=darwin GOARCH=amd64 go build -o main main.go  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GOOS=windows GOARCH=amd64 go build -o main main.go  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GOOS=linux GOARCH=amd64 go build -o main main.go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Golang编程" scheme="https://joewt.com/categories/Golang%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Golang" scheme="https://joewt.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>乔酱的检讨</title>
    <link href="https://joewt.com/2019/10/13/self-criticism-2/"/>
    <id>https://joewt.com/2019/10/13/self-criticism-2/</id>
    <published>2019-10-13T04:34:32.000Z</published>
    <updated>2019-10-13T07:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="乔酱的检讨"><a href="#乔酱的检讨" class="headerlink" title="乔酱的检讨"></a>乔酱的检讨</h2><p>大半年了，终于有点稳定了。二鱼在学校有没有好好吃饭呀，二鱼要乖乖的哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;乔酱的检讨&quot;&gt;&lt;a href=&quot;#乔酱的检讨&quot; class=&quot;headerlink&quot; title=&quot;乔酱的检讨&quot;&gt;&lt;/a&gt;乔酱的检讨&lt;/h2&gt;&lt;p&gt;大半年了，终于有点稳定了。二鱼在学校有没有好好吃饭呀，二鱼要乖乖的哦。&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://joewt.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>HGOJ使用说明</title>
    <link href="https://joewt.com/2019/06/09/usehgoj/"/>
    <id>https://joewt.com/2019/06/09/usehgoj/</id>
    <published>2019-06-09T12:21:40.000Z</published>
    <updated>2019-06-09T14:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HGOJ安装和使用说明"><a href="#HGOJ安装和使用说明" class="headerlink" title="HGOJ安装和使用说明"></a>HGOJ安装和使用说明</h3><p>湖南工学院在线判题系统，使用Golang进行了重构，现在正式开放出来给湖工ACM竞赛队的同学使用。</p><a id="more"></a><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>HGOJ使用Docker进行部署，所以只需要系统安装有Docker和Docker-Compose即可<br>对于mac环境只要下载Docker并安装即可(比较简单)<br>Linux环境的安装如下(以Ubuntu为例):  </p><ul><li>安装依赖  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get update &amp;&amp; sudo apt-get install -y vim  curl git</span><br></pre></td></tr></table></figure><ul><li>安装Docker&amp;&amp;Docker-Compose</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"># sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"># sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>Win环境有兴趣的可以试试</p><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ul><li>找到一个磁盘比较充足的盘，运行如下命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git clone -b master https://github.com/yinrenxin/HGOJ-Deploy.git &amp;&amp; cd HGOJ-Deploy</span><br></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>系统运行后会发现运行不起来，是因为还没有数据库，需要手动建立数据库(以后再改),打开8080端口，进入到phpmyadmin，然后建立hgoj命名的数据库，之后再重新启动hgoj容器即可。<br>经过以上步骤，HGOJ就安装好了。默认的首页为index，第一个注册用户为管理员。之后就能愉快的使用了。<br>如果是正式部署使用的话推荐把phpmyadmin容器给停掉，需要操作数据的时候再临时启动，并且更改.env里的mysql密码,然后更改hgoj连接数据库的密码。<br>如果上面的步骤出了问题可以找我来解决(咕咕咕)</p><h3 id="HGOJ系统的使用"><a href="#HGOJ系统的使用" class="headerlink" title="HGOJ系统的使用"></a>HGOJ系统的使用</h3><ol><li>测试数据<br>主要说明下测试数据的规范，测试数据需要本地做好后打包成zip压缩包，可以搞多组测试数据，输入文件以.in为结尾，输出文件以.out结尾，把测试数据放到一起进行压缩(切记不要把数据放到一个目录下，然后对这个目录进行压缩)。压缩好后的文件命名必须为data.zip。  </li><li><p>创建题目<br>创建题目的时候测试数据使用这个压缩包上传。因为使用了markdown，所以题目描述、输入、输出描述要根据markdown语法来进行填写。</p></li><li><p>创建比赛<br>比赛创建，根据需要添加比赛开始和结束时间，比赛描述同样需要使用markdown语法。添加题目这里，用逗号分隔。权限和用户这里功能还未开发完毕不用管，默认都是公开的。</p></li></ol><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul><li>Github:<a href="https://github.com/yinrenxin/hgoj" target="_blank" rel="noopener">HGOJ</a></li><li>HGOJ开发QQ群:245461736</li><li>湖工ACM交流群:662688178</li><li>湖工ACM对外小分队:663690027</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>因为时间仓促，很多功能还没有实现。因为要兼容以前的OJ系统的数据(以前的OJ系统使用了hustoj)，所以功能上先保证以前有的，HGOJ上也有，判题使用了hustoj的判题，未来的终极目标是使用go重写判题机。如果有小伙伴对go和oj有兴趣，欢迎来一起维护。为啥使用go呢，因为再用PHP写就没意思了(逃) : )</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HGOJ安装和使用说明&quot;&gt;&lt;a href=&quot;#HGOJ安装和使用说明&quot; class=&quot;headerlink&quot; title=&quot;HGOJ安装和使用说明&quot;&gt;&lt;/a&gt;HGOJ安装和使用说明&lt;/h3&gt;&lt;p&gt;湖南工学院在线判题系统，使用Golang进行了重构，现在正式开放出来给湖工ACM竞赛队的同学使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://joewt.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>乔酱的圣诞宣言</title>
    <link href="https://joewt.com/2018/12/24/joeanderyu/"/>
    <id>https://joewt.com/2018/12/24/joeanderyu/</id>
    <published>2018-12-24T14:27:56.000Z</published>
    <updated>2018-12-24T14:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>乔酱永远属于二鱼</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;乔酱永远属于二鱼&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="生活" scheme="https://joewt.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>乔酱的检讨</title>
    <link href="https://joewt.com/2018/12/14/self-criticism/"/>
    <id>https://joewt.com/2018/12/14/self-criticism/</id>
    <published>2018-12-14T13:34:32.000Z</published>
    <updated>2018-12-14T14:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="乔酱认真的检讨"><a href="#乔酱认真的检讨" class="headerlink" title="乔酱认真的检讨"></a>乔酱认真的检讨</h2><p>乔酱爱二鱼，乔酱喜欢二鱼，在乔酱不在的日子，二鱼要记得按时吃饭，多吃肉，多跑步，二鱼记得晚上不要随便出门，出门也要跟室友一起。乔酱不在身边二鱼会不会想乔酱啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;乔酱认真的检讨&quot;&gt;&lt;a href=&quot;#乔酱认真的检讨&quot; class=&quot;headerlink&quot; title=&quot;乔酱认真的检讨&quot;&gt;&lt;/a&gt;乔酱认真的检讨&lt;/h2&gt;&lt;p&gt;乔酱爱二鱼，乔酱喜欢二鱼，在乔酱不在的日子，二鱼要记得按时吃饭，多吃肉，多跑步，二鱼记得晚上不要随便
      
    
    </summary>
    
      <category term="生活" scheme="https://joewt.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP编译选项和常见错误</title>
    <link href="https://joewt.com/2018/12/07/php-compile/"/>
    <id>https://joewt.com/2018/12/07/php-compile/</id>
    <published>2018-12-07T13:06:48.000Z</published>
    <updated>2018-12-07T15:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录了PHP各个版本的源码编译选项以及编译过程中出现的错误和解决办法</p></blockquote><p>以下为每个版本的PHP的编译错误，以及可能会出现的问题  </p><a id="more"></a><h2 id="PHP7-3-0"><a href="#PHP7-3-0" class="headerlink" title="PHP7.3.0"></a>PHP7.3.0</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/Users/joe/php-7.3.0 \</span><br><span class="line">--with-config-file-path=/Users/joe/php-7.3.0 \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--with-fpm-user=www \</span><br><span class="line">--with-fpm-group=www \</span><br><span class="line">--enable-mysqlnd \</span><br><span class="line">--with-mysqli=mysqlnd \</span><br><span class="line">--with-pdo-mysql=mysqlnd \</span><br><span class="line">--enable-mysqlnd-compression-support \</span><br><span class="line">--with-iconv-dir \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-libxml-dir \</span><br><span class="line">--enable-xml \</span><br><span class="line">--disable-rpath \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--with-curl \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-intl \</span><br><span class="line">--with-mcrypt \</span><br><span class="line">--with-libmbfl \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--with-gd \</span><br><span class="line">--enable-gd-native-ttf \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-mhash \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--enable-zip \</span><br><span class="line">--enable-soap \</span><br><span class="line">--with-gettext \</span><br><span class="line">--disable-fileinfo \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--with-pear \</span><br><span class="line">--enable-maintainer-zts \</span><br><span class="line">--with-ldap=shared \</span><br><span class="line">--without-gdbm \</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configure: error: Cannot locate header file libintl.h</span><br><span class="line"></span><br><span class="line">在mac上运行</span><br><span class="line">brew install gettext</span><br><span class="line">之后编辑configure文件找到(大概在3.8w行左右)$PHP_GETTEXT /usr/local /usr</span><br><span class="line">并在后面添加/usr/local/opt/gettext</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">configure: error: Unable to detect ICU prefix or no failed. Please verify ICU install prefix and make sure icu-config works.</span><br><span class="line">在mac上运行</span><br><span class="line">brew install icu4c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/icu4c/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/icu4c/include&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录了PHP各个版本的源码编译选项以及编译过程中出现的错误和解决办法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下为每个版本的PHP的编译错误，以及可能会出现的问题  &lt;/p&gt;
    
    </summary>
    
      <category term="PHP扩展开发" scheme="https://joewt.com/categories/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>积极养鱼</title>
    <link href="https://joewt.com/2018/11/12/yu/"/>
    <id>https://joewt.com/2018/11/12/yu/</id>
    <published>2018-11-12T11:00:31.000Z</published>
    <updated>2018-11-12T11:00:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>养鱼 养鱼 养鱼 养一条傻傻的二鱼</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;养鱼 养鱼 养鱼 养一条傻傻的二鱼&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://joewt.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://joewt.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>C语言中几个基本概念</title>
    <link href="https://joewt.com/2018/10/24/c-advanced/"/>
    <id>https://joewt.com/2018/10/24/c-advanced/</id>
    <published>2018-10-24T04:08:43.000Z</published>
    <updated>2018-11-14T03:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分清以下几个概念"><a href="#分清以下几个概念" class="headerlink" title="分清以下几个概念"></a>分清以下几个概念</h2><ol><li>指针数组 数组指针</li><li>指针函数 函数指针</li><li>指针常量 常量指针</li><li>typedef</li><li>#define</li><li>可变参数</li><li>字符串常量</li></ol><blockquote><p>内容主要来自《C专家编程》《C陷阱和缺陷》《C和指针》 </p></blockquote><a id="more"></a><h2 id="常量和指针"><a href="#常量和指针" class="headerlink" title="常量和指针"></a>常量和指针</h2><p>首先看比较容易理解的常量指针和指针常量  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int const a;</span><br><span class="line">const int a;</span><br></pre></td></tr></table></figure><p>首先看如上声明,const 在前还是在后表示的意思都是一样的，表示a是一个常量 类型为int，a的值初始化后就不能修改了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int const *pi;</span><br><span class="line">const int *pi;</span><br></pre></td></tr></table></figure><p>常量指针有2种表示方法意思都是一样的, 以上2个都表示常量指针,<br>可以修改指针的值但不能修改指针指向的值,这个在函数库的原型里可以见到比如printf和scanf,<br>后面的…表示可变参数后面会讲到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int printf(const char * __restrict, ...) </span><br><span class="line">int scanf(const char * __restrict, ...)</span><br></pre></td></tr></table></figure></p><p>再来看看指针常量的声明,一般只有一种表示方法<br>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * const pi;</span><br></pre></td></tr></table></figure></p><p>表示pi 这个指针是常量，pi的值不能修改,但是pi指向的值是可以修改的  </p><p>如果既不想改变指针的值也不想改变指针指向的值，可以声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int const * const pi;</span><br></pre></td></tr></table></figure></p><h2 id="指针和数组的爱恨情仇"><a href="#指针和数组的爱恨情仇" class="headerlink" title="指针和数组的爱恨情仇"></a>指针和数组的爱恨情仇</h2><p>指针和数组他们之间没有任何关系  </p><ul><li>指针就是指针，指针变量在32位系统下，永远占4个byte，其值为某一个内存的地址。指针可以指向任何地方，但是不是任何地方你都能通过这个指针变量访问到。</li><li>数组就是数组，其大小与元素的类型和个数有关。定义数组时必须指定其元素的类型和个数。数组可以存放任何类型的数据，但不能存函数。  </li></ul><h3 id="如何分辨数组指针和指针数组"><a href="#如何分辨数组指针和指针数组" class="headerlink" title="如何分辨数组指针和指针数组"></a>如何分辨数组指针和指针数组</h3><ul><li>指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“存储指针的数组”的简称</li><li>数组指针：首先它是一个指针，他指向一个数组。在32位系统下永远是占4个字节，至于它指向的数组占多少个字节，不知道。它是“指向数组的指针”的简称<!--More-->考虑下，下面2个哪个是指针数组，哪个是数组指针<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A). int *p1[10];</span><br><span class="line">B). int (*p2)[10];</span><br></pre></td></tr></table></figure></li></ul><p>根据右左法则，先找到未定义标识符，p1右边是[]因为[]比<code>*</code>的优先级高，p1先与[]结合，所以它是一个数组。<code>int *</code>修饰的是数组的内容。<br>再看p2，因为”()”比”[]”优先级高，所以<code>(*p2)</code>表示这是一个指针，指针变量名为p2,int修饰的数组内容，即数组的每个元素。数组在这里没有名字，是匿名数组。所以p2是一个数组指针，指向一个包含10个int类型数据的数组。</p><h3 id="多维数组和多级指针"><a href="#多维数组和多级指针" class="headerlink" title="多维数组和多级指针"></a>多维数组和多级指针</h3><p>考虑下面一个例子<br>&amp;p[4][2]-&amp;a[4][2]的值为多少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5][5];</span><br><span class="line">    int (*p)[4];</span><br><span class="line">    p = a;</span><br><span class="line">    printf(&quot;a_ptr=%#p,p_ptr=%#p\n&quot;,&amp;a[4][2],&amp;p[4][2]);</span><br><span class="line">    printf(&quot;%p,%d\n&quot;,&amp;p[4][2]-&amp;a[4][2],&amp;p[4][2]-&amp;a[4][2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="http://img.hnitoj.cn/7AB30FB4610D9CD6E007B4CE48D73270.png" alt=""><br>文字解析，不如看图来的好<br><img src="http://img.hnitoj.cn/D28B21B0082E0FBB411BBCEFA515B45E.png" alt="">  </p><h3 id="数组参数与指针参数"><a href="#数组参数与指针参数" class="headerlink" title="数组参数与指针参数"></a>数组参数与指针参数</h3><h4 id="一维数组参数"><a href="#一维数组参数" class="headerlink" title="一维数组参数"></a>一维数组参数</h4><h5 id="能否向函数传递一个数组？"><a href="#能否向函数传递一个数组？" class="headerlink" title="能否向函数传递一个数组？"></a>能否向函数传递一个数组？</h5><p>考虑以下程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun(char a[10])</span><br><span class="line">&#123;</span><br><span class="line">    char c = a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    fun(b[10]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的调用，fun(b[10]);将b[10]这个数组传递到fun函数。这样显然不对。<br>b[0]代表是数组的一个元素，那么b[10]也是，只是这里越界了。但在编译阶段，编译器并不会真正计算b[10]的地址并取值，所在在编译阶段不会报错，但是编译器会给出警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在我的Mac上编译出现这个</span><br><span class="line">warning: incompatible integer to pointer conversion passing &apos;char&apos; to parameter of type &apos;char *&apos;; take the address with &amp; [-Wint-conversion]  </span><br><span class="line">warning: array index 10 is past the end of the array (which contains 10 elements) [-Warray-bounds]</span><br><span class="line">//在作者的电脑上给出的警告是这样的  </span><br><span class="line">warning C4047: &apos;function&apos; : &apos;char *&apos; differs in levels of indirection from &apos;char &apos;</span><br><span class="line">warning C4024: &apos;fun&apos; : different types for formal and actual parameter 1</span><br></pre></td></tr></table></figure></p><p>虽然编译没问题，但运行肯定有问题。<br>具体分析如下:  </p><ol><li>b[10]并不存在，在编译的时候由于没有去实际地址取值，所以没有出错，但是在运行时，将计算b[10]的实际地址，并且取值。这时发生越界错误</li><li>编译器的警告已经告诉我们编译器需要的是一个char*类型的参数，而传递过去的是一个char类型的参数，这时候fun函数会将传入的char类型的数据当地址处理，同样会发生错误</li><li>对第二个错误的理解，fun函数明明传递的是一个数组啊，编译器怎么会说是char*类型呢？  </li></ol><p>将fun(b[10])改为fun(b)，编译后不会出现警告了。</p><h5 id="无法向函数传递一个数组"><a href="#无法向函数传递一个数组" class="headerlink" title="无法向函数传递一个数组"></a>无法向函数传递一个数组</h5><p>可以简单验证下，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun(char a[10])</span><br><span class="line">&#123;</span><br><span class="line">    int i=sizeof(a);</span><br><span class="line">    printf(&quot;i:%d\n&quot;,i);</span><br><span class="line">    char c=a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    int j = sizeof(b);</span><br><span class="line">    printf(&quot;j:%d\n&quot;,j);</span><br><span class="line">    fun(b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://img.hnitoj.cn/FC89DCB14091449DBE1B2B8A345E07EA.png" alt=""><br>如果数组b真正传递到函数内部，那么i的值应该为10，但我测试后发现i的值为8(作者测的值为4)。造成这样的原因是这样一条规则:   </p><ul><li>C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针</li></ul><blockquote><p>这么做是有原因的。在 C 语言中，所有非数组形式的数据实参均以传值形式（对实参<br>做一份拷贝并传递给被调用的函数，函数不能修改作为实参的实际变量的值，而只能修改<br>传递给它的那份拷贝）调用。然而，如果要拷贝整个数组，无论在空间上还是在时间上，<br>其开销都是非常大的。更重要的是，在绝大部分情况下，你其实并不需要整个数组的拷贝，<br>你只想告诉函数在那一刻对哪个特定的数组感兴趣。这样的话，为了节省时间和空间，提<br>高程序运行的效率，于是就有了上述的规则。同样的，函数的返回值也不能是一个数组，<br>而只能是指针。这里要明确的一个概念就是：函数本身是没有类型的，只有函数的返回值<br>才有类型。很多书都把这点弄错了，甚至出现“XXX 类型的函数”这种说法。简直是荒唐<br>至极！</p></blockquote><p>所以我们写代码的时候，可以写成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void fun(char a[])</span><br><span class="line">&#123;</span><br><span class="line">    char c=a[3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char b[10] = &quot;abcdefg&quot;;</span><br><span class="line">    fun(b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fun(char *p)</span><br><span class="line">&#123;</span><br><span class="line">    char c=p[3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2><p>指针函数首先是一个函数，返回的类型是一个指针形式的<br>函数指针是一个指针，指向的是一个函数  </p><p>首先看下函数声明<br>任何C变量的声明都由两部分组成:</p><ul><li>类型以及一组类似表达式的声明符(declarator)。声明符从表面上看与表达式有些类似，对它求值应该返回一个声明中给定类型的结果</li></ul><p>最简单的声明符就是单个变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f, g;</span><br></pre></td></tr></table></figure></p><p>这个声明的含义:</p><ul><li>当对其求值时，表达式f和g的类型为浮点数类型(float)。</li></ul><p>因为声明符与表达式的相似，所以我们也可以在声明符中任意使用括号:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float ((f));</span><br></pre></td></tr></table></figure></p><p>这个声明的含义是:</p><ul><li>当对其求值时，((f))的类型为浮点型，由此可以推知，f也是浮点类型。</li></ul><p>同样的逻辑也适合用于函数和指针类型的声明，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float ff();</span><br></pre></td></tr></table></figure></p><p>这个声明的含义是:</p><ul><li>表达式ff()求值结果是一个浮点数，也就是说，ff是一个返回值为浮点数类型的函数。</li></ul><p>类似的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float *pf;</span><br></pre></td></tr></table></figure></p><ul><li>这个声明的含义是*pf是一个浮点数，也就是说，pf是一个指向浮点数的指针</li></ul><p>以上形式组合起来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float *g(), (*h)();</span><br></pre></td></tr></table></figure></p><ul><li>表示<code>*g()</code>与<code>(*h)()</code>是浮点表达式。因为()结合优先级高于<em>,`</em>g()`也就是*(g()): g是一个函数，该函数的返回值类型为指向浮点数的指针。同理，h是一个函数指针，h所指向函数的返回值为浮点类型。</li></ul><p>有了以上的说明 函数指针 指针函数也就能明白了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *func(int a, int b);</span><br></pre></td></tr></table></figure><p>表示 func是一个函数 其返回值是int *，所以是指针函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*func)(int a, intb);</span><br></pre></td></tr></table></figure><p>首先 func是一个指针 该指针指向一个函数 返回值是int 类型的，在使用的时候需要把一个函数的地址传给他  </p><p>函数指针的使用经常用于回调函数<br>下面就是一个简单的回调函数使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">typedef int (*callback)(char *p);</span><br><span class="line"></span><br><span class="line">int fun1(char *str)&#123;</span><br><span class="line">    printf(&quot;回调 func1: %s\n&quot;,str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fun2(char *str)&#123;</span><br><span class="line">    printf(&quot;回调 func2: %s\n&quot;,str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int t1(callback p_callback, char *str)&#123;</span><br><span class="line">    p_callback(str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char *str = &quot;hi!&quot;;</span><br><span class="line">    t1(fun1, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="typedef的使用"><a href="#typedef的使用" class="headerlink" title="typedef的使用"></a>typedef的使用</h2><p>typedef 常常用于为类型创建一个新的别名<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef char Line[12];</span><br><span class="line">Line text; // 这行的意思就是 char text[12];</span><br></pre></td></tr></table></figure></p><p>使用typedef 主要是简化代码比如上面的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*callback)(char *p)</span><br></pre></td></tr></table></figure></p><p>使用的时候就可是使用如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback call;</span><br></pre></td></tr></table></figure></p><p>typedef的另外一个用处就是定义机器无关的类型，促进跨平台</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>宏只是简单的字符串替换<br>通过使用 -E 参数查看宏展开后的结果  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure><p>比如如下代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MALLOC(size,type) ((type*)malloc(sizeof(type) * (size)))</span><br><span class="line">#define PRINT(FORMAT,VALUE)\</span><br><span class="line">printf(&quot;The value of&quot;#VALUE&quot;is &quot; FORMAT&quot;\n&quot;,VALUE)</span><br><span class="line">#define M 10</span><br><span class="line">#define SQ(x) ((x)*(x))</span><br><span class="line">#define DEBUG printf(&quot;FIle %s line %d :&quot;\</span><br><span class="line">                    &quot;x = %d, y = %d \n&quot;,\</span><br><span class="line">                    __FILE__, __LINE__,10,20)</span><br><span class="line">#define MAX(a,b) ((a)&gt;(b)?(a):(b))</span><br><span class="line">#define ERROR_LOG(module)   fprintf(stderr,&quot;error: &quot;module&quot;\n&quot;)</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = M;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);</span><br><span class="line">    DEBUG;</span><br><span class="line">    int b = 121/SQ(2);</span><br><span class="line">    printf(&quot;%d\n&quot;,b);</span><br><span class="line">    int *p = MALLOC(10,int);</span><br><span class="line">    int a = 0;</span><br><span class="line">    int c = 1;</span><br><span class="line">    int d = MAX(a++,c++);</span><br><span class="line">    int x = 1;</span><br><span class="line">    PRINT(&quot;%d&quot;,x+20);</span><br><span class="line">    ERROR_LOG(&quot;add&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么展开后的结果如下</span><br><span class="line">省略一大段</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 10;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);</span><br><span class="line">    printf(&quot;FIle %s line %d :&quot; &quot;x = %d, y = %d \n&quot;, &quot;main.c&quot;, 17,10,20);</span><br><span class="line">    int b = 121/((2)*(2));</span><br><span class="line">    printf(&quot;%d\n&quot;,b);</span><br><span class="line">    int *p = ((int*)malloc(sizeof(int) * (10)));</span><br><span class="line">    int a = 0;</span><br><span class="line">    int c = 1;</span><br><span class="line">    int d = ((a++)&gt;(c++)?(a++):(c++));</span><br><span class="line">    int x = 1;</span><br><span class="line">    printf(&quot;The value of&quot;&quot;x+20&quot;&quot;is &quot; &quot;%d&quot;&quot;\n&quot;,x+20);</span><br><span class="line">    fprintf(__stderrp,&quot;error: &quot;&quot;add&quot;&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">int fun(int n, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list var_arg;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    va_start(var_arg, n); </span><br><span class="line">    for(i = 0; i &lt; n; i+=1)</span><br><span class="line">    &#123;   </span><br><span class="line">        sum += va_arg(var_arg, int);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    va_end(var_arg);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n = 5;</span><br><span class="line">    int sum = fun(n,1,2,3,4,5);</span><br><span class="line">    printf(&quot;%d\n&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串常量用于表达式中，为指针常量<br>对于如下的程序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char *str = &quot;hello&quot;+1;</span><br><span class="line">    printf(&quot;%c\n&quot;,*str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是 e<br>字符串常量实际上是个指针,加1的话结果是个指针，指向第二个字符,所以结果是e</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分清以下几个概念&quot;&gt;&lt;a href=&quot;#分清以下几个概念&quot; class=&quot;headerlink&quot; title=&quot;分清以下几个概念&quot;&gt;&lt;/a&gt;分清以下几个概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;指针数组 数组指针&lt;/li&gt;
&lt;li&gt;指针函数 函数指针&lt;/li&gt;
&lt;li&gt;指针常量 常量指针&lt;/li&gt;
&lt;li&gt;typedef&lt;/li&gt;
&lt;li&gt;#define&lt;/li&gt;
&lt;li&gt;可变参数&lt;/li&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;内容主要来自《C专家编程》《C陷阱和缺陷》《C和指针》 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://joewt.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>PHP的基本变量</title>
    <link href="https://joewt.com/2018/09/11/php-extension-2.1/"/>
    <id>https://joewt.com/2018/09/11/php-extension-2.1/</id>
    <published>2018-09-10T16:08:43.000Z</published>
    <updated>2018-10-17T15:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zval"><a href="#zval" class="headerlink" title="zval"></a>zval</h2><p>PHP在内核中是通过zval这个结构体来存储变量的，PHP的变量是弱类型的，首先来看看PHP5的zval设计   </p><h3 id="PHP5的zval"><a href="#PHP5的zval" class="headerlink" title="PHP5的zval"></a>PHP5的zval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 考虑到结构体对齐 大小为24字节</span><br><span class="line">*/</span><br><span class="line">struct _zval_struct&#123;</span><br><span class="line">/*变量信息*/</span><br><span class="line">zvalue_value value;     // 16字节</span><br><span class="line">zend_uint refcount__gc;  // 4字节</span><br><span class="line">zend_uchar type;         /* 类型   1字节*/</span><br><span class="line">zend_uchar is_ref__gc;   // 1字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 以下说的大小是在 x86-64下</span><br><span class="line"> 在内存对齐的情况下_zvalue_value的大小为16字节</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">long lval;    // 8字节</span><br><span class="line">double dval;  // 8字节</span><br><span class="line">struct&#123;</span><br><span class="line">char *val;</span><br><span class="line">int len;</span><br><span class="line">&#125; str;        // 12字节</span><br><span class="line">HashTable *ht;       /*HashTable 数组  8字节*/</span><br><span class="line">zend_object_value obj;   // 12字节</span><br><span class="line">zend_ast *ast;     // 8字节</span><br><span class="line">&#125;zvalue_value;</span><br></pre></td></tr></table></figure><p>PHP5的zval核心由一个zvalue_value类型的联合体和zend_uchar类型的type组成，<br><code>refcount__gc</code>是用来进行垃圾回收的，<code>is_ref__gc</code> 表示是否是引用类型<br>PHP5.3 为了解决循环引用实际申请的结构体为<code>_zval_gc_info</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">该大小为 32字节</span><br><span class="line">*/</span><br><span class="line">typedef struct _zval_gc_info &#123;</span><br><span class="line">zval z;</span><br><span class="line">union &#123;</span><br><span class="line">gc_root_buffer     *buffered;</span><br><span class="line">struct _zval_gc_info *next;</span><br><span class="line">&#125; u;    // 4字节</span><br><span class="line">&#125;zval_gc_info;</span><br></pre></td></tr></table></figure><p>zval_gc_info 在内存池中分配，内存池会为每个zval_gc_info额外申请一个大小为16字节的zend_mm_block结构体，用来存放内存相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_mm_block_info &#123;</span><br><span class="line">size_t _size;</span><br><span class="line">size_t _prev;</span><br><span class="line">&#125; zend_mm_block_info;</span><br><span class="line"></span><br><span class="line">typedef struct _zend_mm_block&#123;</span><br><span class="line">zend_mm_block_info info;</span><br><span class="line">&#125; zend_mm_block;</span><br></pre></td></tr></table></figure><p>最终一个变量在PHP5中占48字节  </p><h3 id="PHP7的zval"><a href="#PHP7的zval" class="headerlink" title="PHP7的zval"></a>PHP7的zval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef union _zend_value &#123;</span><br><span class="line">zend_long         lval;             /* 整形 */</span><br><span class="line">double            dval;             /* 浮点型 */</span><br><span class="line">zend_refcounted  *counted;          /* 引用计数 */</span><br><span class="line">zend_string      *str;              /* 字符串类型 */</span><br><span class="line">zend_array       *arr;              /* 数组类型 */</span><br><span class="line">zend_object      *obj;              /* 对象类型 */</span><br><span class="line">zend_resource    *res;              /* 资源类型 *</span><br><span class="line">zend_reference   *ref;              /* 引用类型 */</span><br><span class="line">zend_ast_ref     *ast;              /* 抽象语法树 */</span><br><span class="line">zval             *zv;               /* zval类型 */</span><br><span class="line">void             *ptr;              /* 指针类型 */</span><br><span class="line">zend_class_entry *ce;               /* class类型 */</span><br><span class="line">zend_function    *func;             /* function类型 */</span><br><span class="line">struct &#123;</span><br><span class="line">uint32_t w1;</span><br><span class="line">uint32_t w2;</span><br><span class="line">&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">zend_value        value;/* value */</span><br><span class="line">union &#123;</span><br><span class="line">struct &#123;</span><br><span class="line">ZEND_ENDIAN_LOHI_4(</span><br><span class="line">zend_uchar    type,/* zval类型 */</span><br><span class="line">zend_uchar    type_flags,</span><br><span class="line">zend_uchar    const_flags,</span><br><span class="line">zend_uchar    reserved)    /* call info for EX(This) */</span><br><span class="line">&#125; v;</span><br><span class="line">uint32_t type_info;</span><br><span class="line">&#125; u1;</span><br><span class="line">union &#123;</span><br><span class="line">uint32_t     next;                 /* hash collision chain */</span><br><span class="line">uint32_t     cache_slot;           /* literal cache slot */</span><br><span class="line">uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">uint32_t     access_flags;         /* class constant access flags */</span><br><span class="line">uint32_t     property_guard;       /* single property guard */</span><br><span class="line">uint32_t     extra;                /* not further specified */</span><br><span class="line">&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到PHP7中zval定义的好像比较复杂但都是联合体，所以实际占用大小只有16字节<br>接下类看看各个字段的含义。  </p><p>u1字段的含义  </p><ol><li>type: 记录变量类型  </li><li>type_flag: 对应变量类型的特有的标记  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IS_TYPE_CONSTANT        /* 是常量类型 */</span><br><span class="line">IS_TYPE_IMMUTABLE       /* 不可变的类型 */</span><br><span class="line">IS_TYPE_REFCOUNTED      /* 需要引用计数的类型 */</span><br><span class="line">IS_TYPE_COLLECTABLE     /* 可能包含循环引用的类型(IS_ARRAY, IS_OBJECT) */</span><br><span class="line">IS_TYPE_COPYABLE        /* 可被复制的类型 */</span><br></pre></td></tr></table></figure><ol><li>const_flag: 常量类型的标记</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define IS_CONSTANT_UNQUALIFIED    0x010</span><br><span class="line">#define IS_CONSTANT_VISITED_MARK   0x020</span><br><span class="line">#define IS_CONSTANT_CLASS          0x080</span><br><span class="line">#define IS_CONSTANT_IN_NAMESPACE   0x100</span><br></pre></td></tr></table></figure><ol><li>reserved: 保留字段</li></ol><p>u2字段的含义，主要是辅助字段  </p><ol><li>next: 用于哈希冲突中记录下一个元素的位置</li><li>cache_slot: 运行时缓存</li><li>lineno:  文件执行的行号，应用在AST节点上</li><li>num_args: 函数调用时传入参数的个数</li><li>fe_pos:  遍历数组时的当前位置</li><li>fe_iter_idx: 与fe_pos类似，针对对象使用</li><li>access_flags: 对象类的访问标志, public protected private</li><li>property_guard: 防止类中魔术方法的循环调用</li></ol><h2 id="PHP7-变量类型"><a href="#PHP7-变量类型" class="headerlink" title="PHP7 变量类型"></a>PHP7 变量类型</h2><p>PHP7 通过定义20种宏，来u1.v.type字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* regular data types */</span><br><span class="line">#define IS_UNDEF                    0</span><br><span class="line">#define IS_NULL                     1</span><br><span class="line">#define IS_FALSE                    2</span><br><span class="line">#define IS_TRUE                     3</span><br><span class="line">#define IS_LONG                     4</span><br><span class="line">#define IS_DOUBLE                   5</span><br><span class="line">#define IS_STRING                   6</span><br><span class="line">#define IS_ARRAY                    7</span><br><span class="line">#define IS_OBJECT                   8</span><br><span class="line">#define IS_RESOURCE                 9</span><br><span class="line">#define IS_REFERENCE                10</span><br><span class="line"></span><br><span class="line">/* constant expressions */</span><br><span class="line">#define IS_CONSTANT                 11</span><br><span class="line">#define IS_CONSTANT_AST             12</span><br><span class="line"></span><br><span class="line">/* fake types */</span><br><span class="line">#define _IS_BOOL                    13</span><br><span class="line">#define IS_CALLABLE                 14</span><br><span class="line">#define IS_ITERABLE                 19</span><br><span class="line">#define IS_VOID                     18</span><br><span class="line"></span><br><span class="line">/* internal types */</span><br><span class="line">#define IS_INDIRECT                 15  /* 间接类型 */</span><br><span class="line">#define IS_PTR                      17  /* 指针类型 */</span><br><span class="line">#define _IS_ERROR                   20  /* 错误类型 *</span><br></pre></td></tr></table></figure><h3 id="整形和浮点型"><a href="#整形和浮点型" class="headerlink" title="整形和浮点型"></a>整形和浮点型</h3><p>整形和浮点型在zval是直接存储的，实现的比较简单</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串类型的结构如下共占32字节  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_string&#123;</span><br><span class="line">zend_refcounted_h gc;     // 用于引用计数 8字节</span><br><span class="line">zend_ulong        h;      // 哈希值 8字节</span><br><span class="line">size_t            len;    // 字符串长度 8字节</span><br><span class="line">char              val[1]; // 柔性数组，1字节 字符串的值存储位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct _zend_refcounted_h &#123;</span><br><span class="line">    uint32_t        refcounted; </span><br><span class="line">    union &#123;</span><br><span class="line">        struct&#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_3 (</span><br><span class="line">                zend_uchar  type,</span><br><span class="line">                zend_uchar  flags,</span><br><span class="line">                uint16_t    gc_info</span><br><span class="line">            )</span><br><span class="line">    &#125; v;</span><br><span class="line">    uint32_t type_info;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125;zend_refcounted_h;</span><br><span class="line">```  </span><br><span class="line">#### 字段说明  </span><br><span class="line">gc   </span><br><span class="line">gc字段主要存放引用计数等信息。flags存放类别信息，type存放变量类别  </span><br><span class="line"></span><br><span class="line">h  </span><br><span class="line">h字段的作用是缓存字符串的哈希值  </span><br><span class="line"></span><br><span class="line">val  </span><br><span class="line">val字段存储字符串值  </span><br><span class="line"></span><br><span class="line">len  </span><br><span class="line">字符串长度  </span><br><span class="line"></span><br><span class="line">PHP中的字符串是二进制安全的，在遇到\0的时候并不认为结束了，读取的时候以len的值为准  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 几个常用字符串的操作  </span><br><span class="line">echo 输出一个或多个字符串  </span><br><span class="line">在Zend/zend_vm_execute.h下</span><br></pre></td></tr></table></figure><p>static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>    USE_OPLINE</p><pre><code>zval *z;SAVE_OPLINE();z = EX_CONSTANT(opline-&gt;op1); //获取变量if (Z_TYPE_P(z) == IS_STRING) { // 判断是否是字符串 是的或就直接输出    zend_string *str = Z_STR_P(z);     if (ZSTR_LEN(str) != 0) {        zend_write(ZSTR_VAL(str), ZSTR_LEN(str));  //将字符串写入到标准输出    }} else {    zend_string *str = _zval_get_string_func(z);  //强制转换    if (ZSTR_LEN(str) != 0) {        zend_write(ZSTR_VAL(str), ZSTR_LEN(str));   //写入到标准输出    } else if (IS_CONST == IS_CV &amp;&amp; UNEXPECTED(Z_TYPE_P(z) == IS_UNDEF)) {        GET_OP1_UNDEF_CV(z, BP_VAR_R);    }    zend_string_release(str);}ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();</code></pre><p>}</p><p>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;zval&quot;&gt;&lt;a href=&quot;#zval&quot; class=&quot;headerlink&quot; title=&quot;zval&quot;&gt;&lt;/a&gt;zval&lt;/h2&gt;&lt;p&gt;PHP在内核中是通过zval这个结构体来存储变量的，PHP的变量是弱类型的，首先来看看PHP5的zval设计   &lt;/p&gt;
&lt;h3 id=&quot;PHP5的zval&quot;&gt;&lt;a href=&quot;#PHP5的zval&quot; class=&quot;headerlink&quot; title=&quot;PHP5的zval&quot;&gt;&lt;/a&gt;PHP5的zval&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 考虑到结构体对齐 大小为24字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct _zval_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	/*变量信息*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zvalue_value value;     // 16字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zend_uint refcount__gc;  // 4字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zend_uchar type;         /* 类型   1字节*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	zend_uchar is_ref__gc;   // 1字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PHP扩展开发" scheme="https://joewt.com/categories/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>认识PHP的一些基本原理</title>
    <link href="https://joewt.com/2018/09/01/php-extension-1-1/"/>
    <id>https://joewt.com/2018/09/01/php-extension-1-1/</id>
    <published>2018-09-01T10:08:43.000Z</published>
    <updated>2018-10-19T07:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从PHP的执行原理开始"><a href="#从PHP的执行原理开始" class="headerlink" title="从PHP的执行原理开始"></a>从PHP的执行原理开始</h2><p>PHP是一门解释型语言,执行过程如下：<br>第一步：源码通过词法分析得到Token。Token是PHP代码被切割成的有意义的标识。在zend_language_parse.h文件中做了定义，比如echo对应的Token是T_ECHO，值为328<br>第二步：语法分析将Token和符合文法规则的代码生成抽象语法树。在PHP7中，AST是新特征<br>第三步：将AST生成对应的opcode，并被虚拟机执行。opcode是PHP定义的一组指令标识，对应相应的handler。opcodes是opcode的集合形式，是PHP执行过程的中间代码，类似Java的字节码。PHP优化中有一个常见的“开启opcache”，指的就是opcodes的缓存  </p><a id="more"></a><h2 id="PHP7内核架构"><a href="#PHP7内核架构" class="headerlink" title="PHP7内核架构"></a>PHP7内核架构</h2><p>主要来自于《PHP7底层设计与源码实现》</p><p><img src="http://img.hnitoj.cn/image/php/php7source.png" alt=""></p><ul><li><p>Zend引擎：词法/语法分析、AST编译和opcodes的执行均在Zend引擎中实现。引擎为PHP提供了基础服务，PHP的可靠性和高性能都依赖引擎的基础支撑。  </p></li><li><p>PHP层：来自外部的交互通过PHP层来处理。  </p></li><li>SAPI：SAPI(Server API),包含了常见的cli SAPI，cgi SAPI和fmpSAPI。SAPI提供了一个和外部通信的接口。  </li><li>扩展部分：Zend引擎提供了核心能力和接口规范。在此基础上进行扩展开发。</li></ul><p>以下为几种常见的SAPI  </p><ul><li>cli： PHP的命令行交互接口</li><li>fpm-fcgi: fmp全称为FastCGI Process Manager，PHP官方提供的FastCGI进程管理器。举例来说，当有http请求发送到nginx服务器，nginx按照FastCGI协议把请求交给php-fpm进程处理  </li><li>apache2handler: Apache扩展，编译后生产动态链接库，配置到Apache下，当有http请求到Apache时，根据配置会调用此动态链接库，执行PHP代码，完成与PHP的交互</li></ul><h2 id="PHP的生命周期"><a href="#PHP的生命周期" class="headerlink" title="PHP的生命周期"></a>PHP的生命周期</h2><p>在cli模式下，PHP的执行过程主要分为5大阶段：  </p><ol><li>模块初始化阶段  php_module_startup</li><li>请求初始化阶段  php_request_startup</li><li>执行阶段  php_execute_script</li><li>请求关闭阶段  php_request_shutdown</li><li>模块关闭阶段  php_module_shutdown</li></ol><p>web模式没有1或5</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从PHP的执行原理开始&quot;&gt;&lt;a href=&quot;#从PHP的执行原理开始&quot; class=&quot;headerlink&quot; title=&quot;从PHP的执行原理开始&quot;&gt;&lt;/a&gt;从PHP的执行原理开始&lt;/h2&gt;&lt;p&gt;PHP是一门解释型语言,执行过程如下：&lt;br&gt;第一步：源码通过词法分析得到Token。Token是PHP代码被切割成的有意义的标识。在zend_language_parse.h文件中做了定义，比如echo对应的Token是T_ECHO，值为328&lt;br&gt;第二步：语法分析将Token和符合文法规则的代码生成抽象语法树。在PHP7中，AST是新特征&lt;br&gt;第三步：将AST生成对应的opcode，并被虚拟机执行。opcode是PHP定义的一组指令标识，对应相应的handler。opcodes是opcode的集合形式，是PHP执行过程的中间代码，类似Java的字节码。PHP优化中有一个常见的“开启opcache”，指的就是opcodes的缓存  &lt;/p&gt;
    
    </summary>
    
      <category term="PHP扩展开发" scheme="https://joewt.com/categories/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>记一次性能优化点</title>
    <link href="https://joewt.com/2018/08/27/mysql-optimize-1/"/>
    <id>https://joewt.com/2018/08/27/mysql-optimize-1/</id>
    <published>2018-08-27T11:39:08.000Z</published>
    <updated>2018-08-27T12:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近学习了个小项目, 打算把它作为我们队的论坛系统，但部署到服务器上时发现 打开一个页面要等好久。在此记录下如何解决的，最后的处理结果也是非常简单。  </p></blockquote><a id="more"></a><p><a href="https://bbs.hnitoj.cn" target="_blank" rel="noopener">线上地址</a>  </p><p><a href="https://github.com/yinrenxin/laravel-larabbs" target="_blank" rel="noopener">项目地址</a>  </p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>这个项目是用Laravel框架，本地开发使用Homestead，开发起来非常方便。线上部署使用了<a href="http://laradock.io/introduction/" target="_blank" rel="noopener">Laradock</a>比较好用的一个Docker化的一个PHP运行环境  </p><p>因为某个还未解决的问题，没有使用Laradock里的MySQL容器，我就想着使用另外一台服务器运行MySQL，当整个部署完成后，MySQL远程连接开启。启动项目：）   </p><h2 id="问题展现"><a href="#问题展现" class="headerlink" title="问题展现"></a>问题展现</h2><p>。。。。怎么有点慢，打开 Laravel Debugbar，发现页面加载耗时10S(……)，再次查看，发现每次请求,第一条sql耗时将近10S,后面的sql语句还算正常。  </p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>通过查询相关资料，原来是MySQL还要进行DNS解析，这就好办了禁用DNS解析就行通过在mysql的配置文件里添加  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><p>如果禁用DNS查询MySQL怎么知道远程连接的客户端在哪个位置呢，这个也好解决，只要在配置MySQL远程连接时指定一个固定的IP就行(必须使用IP地址)。  </p><p>之后再打开应用就快很多了。</p><blockquote><p>When a new thread connects to mysqld, mysqld will spawn a new thread to handle the request. This thread will first check if the hostname is in the hostname cache. If not the thread will call gethostbyaddr_r() and gethostbyname_r() to resolve the hostname.</p><p>If the operating system doesn’t support the above thread-safe calls, the thread will lock a mutex and call gethostbyaddr() and gethostbyname() instead. Note that in this case no other thread can resolve other hostnames that is not in the hostname cache until the first thread is ready.</p><p>You can disable DNS host lookup by starting mysqld with –skip-name-resolve. In this case you can however only use IP names in the MySQL privilege tables.</p><p>If you have a very slow DNS and many hosts, you can get more performance by either disabling DNS lookop with –skip-name-resolve or by increasing the HOST_CACHE_SIZE define (default: 128) and recompile mysqld.</p><p>You can disable the hostname cache with –skip-host-cache. You can clear the hostname cache with FLUSH HOSTS or mysqladmin flush-hosts.</p><p>If you don’t want to allow connections over TCP/IP, you can do this by starting mysqld with –skip-networking.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近学习了个小项目, 打算把它作为我们队的论坛系统，但部署到服务器上时发现 打开一个页面要等好久。在此记录下如何解决的，最后的处理结果也是非常简单。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MYSQL优化" scheme="https://joewt.com/categories/MYSQL%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="MYSQL" scheme="https://joewt.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>网络IPC: 套接字(十六)</title>
    <link href="https://joewt.com/2018/08/03/network-IPC/"/>
    <id>https://joewt.com/2018/08/03/network-IPC/</id>
    <published>2018-08-03T06:03:47.000Z</published>
    <updated>2018-08-03T08:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX系统提供的经典进程间通信机制(IPC): 管道、FIFO、消息队列、信号量以及共享存储。这些机制允许在同一台计算机上运行的进程可以相互通信。本章内容主要是研究在不同计算机上的进程相互通信的机制: 网络进程间通信(network IPC)。  </p><a id="more"></a><h2 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h2><p>套接字描述符在UNIX系统上被当做一种文件描述符，UNIX系统一切皆文件。<br>调用socket函数，创建一个套接字  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int damain, int type, int protocol);</span><br><span class="line">//成功：返回描述符，出错：返回-1</span><br></pre></td></tr></table></figure><p>参数domain确定通信特征，包括地址格式  </p><table><thead><tr><th style="text-align:left">域</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">AF_INET</td><td style="text-align:left">IPv4</td></tr><tr><td style="text-align:left">AF_INET6</td><td style="text-align:left">IPv6</td></tr><tr><td style="text-align:left">AF_UNIX</td><td style="text-align:left">UNIX域</td></tr><tr><td style="text-align:left">AF_UPSPEC</td><td style="text-align:left">未指定</td></tr></tbody></table><p>参数type确定套接字类型，进一步确定通信特征   </p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">SOCK_DGRAM</td><td style="text-align:left">固定长度、无连接、不可靠的报文传递</td></tr><tr><td style="text-align:left">SOCK_RAW</td><td style="text-align:left">IP协议的数据报接口</td></tr><tr><td style="text-align:left">SOCK_SEQPACKET</td><td style="text-align:left">固定长度、有序的、可靠的、面向连接的报文传递</td></tr><tr><td style="text-align:left">SOCK_STREAM</td><td style="text-align:left">有序的、可靠的、双向的、面向连接的字节流</td></tr></tbody></table><p>参数protocal通常是0、表示为给定的域和套接字类型选择默认协议  </p><p>数据报(SOCK_DGRAM)接口，类似于UDP通信，两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。<br>字节流(SOCK_STREAM),类似于TCP，在交换数据前，需要建立一个逻辑连接。  </p><p>套接字通信时双向的。可以采用shutdown函数来禁止一个套接字的I/O。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int shutdown(int sockfd, int how);</span><br><span class="line">//成功：返回0 失败：返回-1</span><br></pre></td></tr></table></figure><p>how参数  </p><ul><li>SHUT_RE(关闭读端)，无法从套接字读取数据</li><li>SHUT_WR(关闭写端)，无法使用套接字发送数据</li><li>SHUT_RDWR，无法读，也无法读  </li></ul><p>有两个函数用于点分十进制和二进制地址格式之前的相互转换  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">const char *inet_ntop(int domain, const void *restrict addr,</span><br><span class="line">                    char *restrict str, socklen_t size);</span><br><span class="line">                    //成功：返回地址字符串指针，出错：返回NULL</span><br><span class="line"></span><br><span class="line">int inet_pton(int domain, const char *restrict str,</span><br><span class="line">                void *restrict addr);</span><br><span class="line">                    //成功：返回1，格式无效返回0，失败：返回-1</span><br></pre></td></tr></table></figure><h2 id="将套接字与地址关联"><a href="#将套接字与地址关联" class="headerlink" title="将套接字与地址关联"></a>将套接字与地址关联</h2><p>使用bind函数来关联地址和套接字  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t len);</span><br><span class="line">//成功：返回0，失败：返回-1</span><br></pre></td></tr></table></figure><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>使用connect函数来建立连接  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t len);</span><br><span class="line">//成功：返回0，失败：返回-1</span><br></pre></td></tr></table></figure><p>在connect中指定的地址是我们想与之通信的服务器地址。如果sockfd没有绑定到一个地址，connect会给调用者绑定一个默认地址。  </p><p>服务器调用listen函数宣告它愿意接受连接请求  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">//成功：返回0，失败：返回-1</span><br></pre></td></tr></table></figure><p>参数backlog提供了一个提示，提示系统该进程所要入队的未完成连接请求数量。实际值由系统决定<br>一旦队列满，系统就会拒绝多余的连接请求，所以backlog的值应该基于服务器期望负载和处理量来选择，其中处理量是指接受连接请求与启动服务的数量。<br>一旦服务器调用了listen，所用的套接字就能接收连接请求。使用accept函数来获得连接请求并建立连接。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *restrict addr,</span><br><span class="line">            socklen_t *restrict len);</span><br><span class="line">            //成功：返回文件描述符，出错：返回-1</span><br></pre></td></tr></table></figure><p>函数accept返回的是套接字描述符，该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字(sockfd)具有相同的套接字类型和地址族。传给accept的原始套接字没有关联到这个连接，而是继续保持可用状态并接收其他连接请求。<br>如果不关心客户端标识，可以将参赛addr和len设为NULL。否则，在调用accept之前，将addr参数设为足够大的缓冲区来存放地址，并且将len指向的整数设为这个缓冲区的字节大小。返回时，accept会在缓冲区填充客户端的地址，并且更新指向len的整数来反映该地址的大小。<br>如果没有连接请求等待，accept会阻塞直到一个请求到来。如果sockfd处于非阻塞模式，accept会返回-1，并将errno设置为EAGAIN或EWOULDBLOCK。<br>如果服务器调用accept，并且当前没有连接请求，服务器会阻塞直到一个请求到来。另外，服务器可以使用poll或select来等待一个请求的到来。在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现。  </p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);</span><br><span class="line">//成功: 返回发送的字节数，失败：返回-1</span><br></pre></td></tr></table></figure><p>对于支持报文边界的协议，如果尝试发送单个报文的长度超过协议锁支持的最大长度，那么send会失败，并将errno设为EMSGSIZE。对于字节流协议，send会阻塞直到整个数据传输完成。函数sendto和send类似。区别在于sendto可以在无连接的套接字上指定一个目标地址。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr * destaddr, socklen_t destlen);</span><br><span class="line">//成功：返回发送的字节数，失败：返回-1</span><br></pre></td></tr></table></figure><p>使用recv函数接收数据   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);</span><br><span class="line">//返回数据的字节长度，无数据或等放已经按序结束，返回0，出错：返回-1</span><br></pre></td></tr></table></figure><h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>通常，recv函数没有数据可用时会阻塞等待。同样的，当套接字输出队列没有足够空间来发送消息时，send函数会阻塞。在套接字非阻塞模式下，行为会改变。在这种情况下，这些函数不会阻塞而是会失败，将errno设置为EWOULDBLOCK或者EAGAIN。当这种情况发生时，可以用poll或select来判断能否接收或者传输数据。  </p><p>Single UNIX Specification 包含通用异步I/O机制的支持。套接字机制有自己的处理异步I/O的方式。<br>在基于套接字的异步I/O中，当从套接字中读取数据时，或者当套接字写队列中空间变得可用时，可以安排要发送的信号SIGIO。<br>启用异步I/O的步骤  </p><ol><li>建立套接字所有权，这样信号可以被传递到合适的进程。  <ul><li>在fcntl中使用F_SETOWN命令</li><li>在ioctl中使用FIOSETOWN命令</li><li>在ioctl中使用SIOCSGRP命令 </li></ul></li><li>通知套接字当I/O操作不会阻塞时发信号。  <ul><li>在fcntl中使用F_SETFL命令并且启用文件标志<code>O_ASYNC</code>。</li><li>在ioctl中使用FIOASYNC命令。</li></ul></li></ol><p>但没有得到普遍支持</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;UNIX系统提供的经典进程间通信机制(IPC): 管道、FIFO、消息队列、信号量以及共享存储。这些机制允许在同一台计算机上运行的进程可以相互通信。本章内容主要是研究在不同计算机上的进程相互通信的机制: 网络进程间通信(network IPC)。  &lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>守护进程(十三)</title>
    <link href="https://joewt.com/2018/07/10/daemons/"/>
    <id>https://joewt.com/2018/07/10/daemons/</id>
    <published>2018-07-09T16:17:42.000Z</published>
    <updated>2018-10-19T07:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>守护进程(daemon)是在系统引导装入时启动，仅在系统关闭时才终止。守护进程是在后台运行的。  </p><h2 id="守护进程特征"><a href="#守护进程特征" class="headerlink" title="守护进程特征"></a>守护进程特征</h2><p>在命令行下输入 ps -axj(BSD系统)  查看系统中各个进程的状态。  </p><a id="more"></a><p><img src="http://img.hnitoj.cn/apue/img/chapter13/figure13-1.png" alt="">  </p><p>父ID为0的个进程通常是内核进程，内核进程存在于系统的整个生命周期，他们以超级用户特权运行，无控制终端，无命令行。  </p><p>在ps的输出中，内核守护进程的名字出现在方括号中。  </p><p><img src="http://img.hnitoj.cn/apue/img/chapter13/figure13-2.png" alt="">  </p><p>可以看到Linux使用了kthreadd的特殊内核进程来创建其他的内核进程，所以其他内核进程的父进程为2 也就是kthreadd进程。对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。如在Linux中。  </p><ul><li>kswapd 内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢写会磁盘。</li><li>flush  守护进程在可用内存达到设置的最小阀值时将脏页面冲洗至磁盘。同时它还定期将脏页面冲洗会磁盘防止数据丢失。</li><li>sync_supers 定期将文件系统元数据冲洗至磁盘。</li><li>jbd 帮助实现了ext4文件系统中的日志功能。</li></ul><hr><ul><li>进程1通常是init进程，它是系统守护进程，主要负责启动各运行层次特定的系统服务。  </li><li>rpcbind守护进程提供将RPC程序号映射为网络端口号的服务。  </li><li>rsyslogd守护进程可以被由管理员启用的将系统日志记录的任何程序使用  </li><li>inetd守护进程。侦听系统网络接口，以便取得来自网络的对各种网络服务进程的请求  </li><li>nfsd、nfsiod、lockd、rpciod、rpc.idmapd、rpc.statd、rpc.mountd提供了网络文件系统的支持。  </li></ul><h2 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h2><p>编写一个守护进程需要遵循一些规则，防止产生不必要的交互。  </p><ol><li>调用umask将文件模式创建屏蔽字设置为一个已知值通常为0</li><li>调用fork，然后父进程exit</li><li>调用setsid创建一个新会话</li><li>当前工作目录更改为根目录</li><li>关闭不需要的文件描述符</li><li>某些守护进程打开/dev/null 使其具有文件描述符0、1、2</li></ol><h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程出错处理，大多数守护进程都使用 BSD的syslog设施。  </p><p><img src="http://img.hnitoj.cn/apue/img/chapter13/figure13-3.png" alt="">  </p><p> 有3种产生日志消息的方式  </p><ol><li>内核例程可以调用log函数。</li><li>大多数用户进程(守护进程)调用syslog(3)函数来产生日志消息，</li><li>无论一个用户进程是在此主机上，还是在通过TPC/IP网络连接到此主机的其他主机上，都可以将日志消息发送到UDP的514端口。  </li></ol><p> 通常，syslogd守护进程读取所有3种格式的日志消息。启动时读取一个配置文件，通常是/etc/syslogd.conf该文件决定了不同种类的消息应送到何处。  </p><p> syslog设施的接口是syslog函数  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;syslog.h&gt;</span><br><span class="line">void openlog(const char *ident, int option, int facility);</span><br><span class="line">void syslog(int priority, const char *format, ...);</span><br><span class="line">void closelog(void);</span><br><span class="line">int setlogmask(int maskpri);</span><br></pre></td></tr></table></figure><h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p> 某些守护进程会实现为，在任意时刻只运行该守护进程的一个副本。对于cron守护进程而言，如果有多个实例运行，那么每个副本都可能试图开始某个预定的操作，会造成重复执行，这可能会出错。  </p><p> 如果守护进程需要访问一个设备，而该设备驱动程序有时会阻止想要多次打开/dev 目录下相应设备节点的尝试。这就限制了在一个时刻只能运行守护进程的一个副本。但如果没有这种设备可供使用，那么就需要自行处理。   </p><p> 文件和记录锁机制为一种方法提供了基础，该方法保证一个守护进程只有一个副本在运行。如果每一个守护进程创建一个固定名字的文件，并在该文件的整体上加一把写锁，那么只允许创建一把这样的锁。在此之后创建写锁的尝试都会失败，这向后续进程副本指明已有一个副本正在运行。  </p><h2 id="守护进程惯例"><a href="#守护进程惯例" class="headerlink" title="守护进程惯例"></a>守护进程惯例</h2><p> 在UNIX系统中，守护进程遵循以下通用惯例  </p><ul><li>若守护进程使用锁文件，那么该文件通常存储在/var/run目录中。</li><li>若守护进程支持配置选项，那么配置文件一般位于/etc下，如/etc/syslog.conf  </li><li>守护进程可以由命令行启动，但通常它们是由系统启动脚本之一启动的<code>/etc/rc*或/etc/init.d/*</code>。</li><li>配置文件一般只在启动时读取，如果更改配置文件，就要重启进程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;守护进程(daemon)是在系统引导装入时启动，仅在系统关闭时才终止。守护进程是在后台运行的。  &lt;/p&gt;
&lt;h2 id=&quot;守护进程特征&quot;&gt;&lt;a href=&quot;#守护进程特征&quot; class=&quot;headerlink&quot; title=&quot;守护进程特征&quot;&gt;&lt;/a&gt;守护进程特征&lt;/h2&gt;&lt;p&gt;在命令行下输入 ps -axj(BSD系统)  查看系统中各个进程的状态。  &lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TP5集成Swoole</title>
    <link href="https://joewt.com/2018/06/20/thinkphpMeetsSwoole/"/>
    <id>https://joewt.com/2018/06/20/thinkphpMeetsSwoole/</id>
    <published>2018-06-20T12:45:28.000Z</published>
    <updated>2018-10-19T07:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>thinkphp5.1和swoole  </p><p>tp5的安装使用composer安装，使用以下命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project topthink/think  tp5  --prefer-dist</span><br></pre></td></tr></table></figure></p><blockquote><p>thinkphp5.1.18更新,完善了swoole的支持,不用再自己更改Request类了  </p></blockquote><p><a href="http://www.thinkphp.cn/topic/57791.html" target="_blank" rel="noopener"><br>ThinkPHP5.1.18版本发布——完善Swoole/Workerman支持</a></p><p>swoole的安装参考我写的swoole安装教程  </p><h2 id="swoole简单使用"><a href="#swoole简单使用" class="headerlink" title="swoole简单使用"></a>swoole简单使用</h2><a id="more"></a><p>一般来说我们的浏览器发起一个请求先走nginx或apache，然后通过fast_CGI交给php来执行php代码,FPM是fast_cgi的进程管理器,FPM通过一些配置管理很多的fast_cgi进程。<br>当我们使用swoole来开启一个http服务的话就不需要使用fpm了。</p><p>首先看官方文档的一个例子  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$http = new swoole_http_server(&quot;127.0.0.1&quot;, 9501);</span><br><span class="line">//在收到一个http请求后，会调用该函数</span><br><span class="line">$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123;</span><br><span class="line">    //发送http响应体，结束请求处理</span><br><span class="line">    $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>如果想加载静态的html文件，可以使用document_root配置  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$http = new swoole_http_server(&quot;127.0.0.1&quot;, 9501);</span><br><span class="line">//worker_num设置启动的worker进程数</span><br><span class="line">$http-&gt;set(</span><br><span class="line">    [</span><br><span class="line">        &apos;enable_static_handler&apos; =&gt; true,</span><br><span class="line">        &apos;document_root&apos; =&gt; &quot;/thinkphp/public/static/live&quot;,</span><br><span class="line">        &apos;worker_num&apos; =&gt; 5,</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123;</span><br><span class="line">    $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">$http-&gt;start();</span><br></pre></td></tr></table></figure><p>使用命令行运行该程序，打开浏览器即可看到结果,这里就不给结果了。  </p><h2 id="tp5结合swoole"><a href="#tp5结合swoole" class="headerlink" title="tp5结合swoole"></a>tp5结合swoole</h2><p>首先把上面的http_server的代码放到tp5的项目目录下，我是放到了项目的根目录下<br><img src="http://img.hnitoj.cn/figure1.1.png" alt="">  </p><ul><li><p>如果我们不修改，当我们输入url的时候并不会找到相应的控制器方法。swoole通过request事件，通过回调函数处理相应的请求get,post等。  </p></li><li><p>通过swoole的workerstart事件回调函数加载框架代码</p></li><li><p>通过观察tp5的代码可以看到,index.php首先加载了引导文件start.php, start.php又加载了base.php文件。我们要加载的便是该文件  </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$http-&gt;on(&apos;WorkerStart&apos;,function(swoole_server $server,$worker_id)&#123;</span><br><span class="line">    define(&apos;APP_PATH&apos;, __DIR__ . &apos;/../application/&apos;);</span><br><span class="line">    // 这里 引入 base.php  而不引入start.php  是因为</span><br><span class="line">    // start.php 的话 就会执行thinkphp 的相应的控制器方法了</span><br><span class="line">    require __DIR__ . &apos;/../thinkphp/base.php&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>这样便把tp5的代码加载到worker进程里,接着处理请求部分<br>因为tp5使用原生的php代码，所以需要把swoole的请求转换下。swoole接收get，post跟原生的不一样。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$http-&gt;on(&apos;request&apos;, function ($request, $response) use($http)&#123;</span><br><span class="line">    if(isset($request-&gt;server))&#123;</span><br><span class="line">        foreach($request-&gt;server as $k =&gt; $v)&#123;</span><br><span class="line">            $_SERVER[strtoupper($k)] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isset($request-&gt;server))&#123;</span><br><span class="line">        foreach($request-&gt;server as $k =&gt; $v)&#123;</span><br><span class="line">            $_SERVER[strtoupper($k)] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //swoole对于超全局数组并不会释放，所以要先清空一次</span><br><span class="line">    $_GET = [];</span><br><span class="line">    if(isset($request-&gt;get))&#123;</span><br><span class="line">        foreach ($request-&gt;get as $k =&gt; $v)&#123;</span><br><span class="line">            $_GET[$k] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $_POST = [];</span><br><span class="line">    if(isset($request-&gt;post))&#123;</span><br><span class="line">        foreach ($request-&gt;post as $k =&gt; $v)&#123;</span><br><span class="line">            $_POST[$k] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //把返回放到一个缓冲区里</span><br><span class="line">    ob_start();</span><br><span class="line">    try &#123;</span><br><span class="line">        think\Container::get(&apos;app&apos;, [defined(&apos;APP_PATH&apos;) ? APP_PATH : &apos;&apos;])</span><br><span class="line">            -&gt;run()</span><br><span class="line">            -&gt;send();</span><br><span class="line">    &#125;catch(\Exception $e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    echo request()-&gt;action();</span><br><span class="line">    $res = ob_get_contents();</span><br><span class="line">    ob_end_clean();</span><br><span class="line">    $response-&gt;end($res);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样改完后我们测试下 </p><p><img src="http://img.hnitoj.cn/figure1.2.png" alt=""></p><p><img src="http://img.hnitoj.cn/figure1.3.png" alt="">  </p><p><img src="http://img.hnitoj.cn/figure1.4.png" alt=""> </p><p>我们发现当我们修改方法时，始终显示的是index方法，这里有一个解决办法。</p><p>找到thinkphp/library/think/Request.php文件,里面有2个方法更改如下  </p><p><img src="http://img.hnitoj.cn/figure1.6.png" alt=""><br><img src="http://img.hnitoj.cn/figure1.7.png" alt="">  </p><p>之后我们就可以正常的通过url进行访问了。这里改成这样的原因，是因为tp会把模块，控制器，方法放到一个变量中，如果我们有重复访问同一个控制器，方法时这样比较高效。但worker进程并不会注销变量。就造成了访问不同控制器，方法始终是同一个控制器，方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;thinkphp5.1和swoole  &lt;/p&gt;
&lt;p&gt;tp5的安装使用composer安装，使用以下命令安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;composer create-project topthink/think  tp5  --prefer-dist&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;thinkphp5.1.18更新,完善了swoole的支持,不用再自己更改Request类了  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.thinkphp.cn/topic/57791.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;br&gt;ThinkPHP5.1.18版本发布——完善Swoole/Workerman支持&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;swoole的安装参考我写的swoole安装教程  &lt;/p&gt;
&lt;h2 id=&quot;swoole简单使用&quot;&gt;&lt;a href=&quot;#swoole简单使用&quot; class=&quot;headerlink&quot; title=&quot;swoole简单使用&quot;&gt;&lt;/a&gt;swoole简单使用&lt;/h2&gt;
    
    </summary>
    
      <category term="Swoole" scheme="https://joewt.com/categories/Swoole/"/>
    
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
      <category term="swoole" scheme="https://joewt.com/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>线程(十一)上</title>
    <link href="https://joewt.com/2018/06/06/pthread/"/>
    <id>https://joewt.com/2018/06/06/pthread/</id>
    <published>2018-06-05T16:29:40.000Z</published>
    <updated>2018-06-06T03:09:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>线程的一些基础知识，包括线程的创建、线程终止</p></blockquote><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>典型的UNIX进程可以看成只有一个控制线程；一个进程在某一时刻只能做一件事情。有了多个控制线程后，在程序设计时就可以把进程设计成在某一时刻做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处  </p><ol><li>简化处理异步事件的代码</li><li>分解复杂的问题提高整个程序的吞吐量</li><li>使用多线程改善响应时间  </li></ol><a id="more"></a><p>每个线程都包含有表示执行环境所必须的信息。其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。  </p><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>每个线程都有一个线程ID。但跟进程不一样，进程ID在整个系统中是唯一的，线程ID只有在它所属的进程上下文中才有意义。  </p><p>线程ID通过使用pthread_t数据类型表示，必须要使用一个函数对两个线程ID进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_equal(pthread_t tid1, pthread_t tid2);</span><br><span class="line">// 相等返回非零，不同返回0</span><br></pre></td></tr></table></figure></p><p>线程通过调用pthread_self函数获得自身的线程ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_t pthread_self(void);</span><br></pre></td></tr></table></figure></p><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>新增的线程可以通过调用pthread_create函数创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_create(pthread_t *restrict tidp, </span><br><span class="line">                   const pthread_attr_t *restrict attr,</span><br><span class="line">                   void *(*start_rtn)(void *), void *restrict arg);</span><br><span class="line">//成功返回0，失败返回错误编号</span><br></pre></td></tr></table></figure></p><ul><li>当pthread_create成功返回时，新创建线程的线程ID会被设置成tidp指向的内存单元。attr用于定制各种不同的线程属性(第12章介绍)，设置为NULL，表示创建一个具有默认属性的线程。</li><li>新创建的线程从start_rtn函数的地址开始执行，该函数只有一个无类型指针参数arg。如果有多个参数传递，需要把这些参数放到一个结构中，然后传递这个结构的地址进去。</li><li>线程创建时不能保证执行顺序  </li></ul><p>如下程序创建了一个线程，打印了进程ID、新线程的线程ID以及初始线程的线程ID。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t ntid;</span><br><span class="line">void printids(const char *s)&#123;</span><br><span class="line">    pid_t   pid;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    tid = pthread_self();</span><br><span class="line">    printf(&quot;%s pid %lu tid %lu (0x%lx)\n&quot;,s,(unsigned long)pid, (unsigned long)tid, (unsigned long)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * thr_fn(void *arg)&#123;</span><br><span class="line">    printids(&quot;new thread:&quot;);</span><br><span class="line">    return ((void *)0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    err = pthread_create(&amp;ntid, NULL, thr_fn, NULL);</span><br><span class="line">    if(err !=0 )</span><br><span class="line">        err_exit(err, &quot;can&apos;t create thread&quot;);</span><br><span class="line">    printids(&quot;main thread:&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图所示<br><img src="/img/chapter-11/figure11.2.png" alt=""><br>可以看到打印出了相同的进程ID，但在mac系统上线程ID不在相同地址段范围  </p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、<code>_Exit</code>或者<code>_exit</code>，那么整个进程就会终止。<br>单个线程可以通过3种方式退出，可以在不终止整个进程的情况下，停止它的控制流。 </p><ol><li>线程可以简单的从启动例程中返回，返回值是线程的退出码。</li><li>线程可以被同一进程中的其他线程取消。</li><li>线程调用pthread_exit。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_exit(void *rval_ptr);</span><br></pre></td></tr></table></figure><p>rval_ptr参数是一个无类型指针，进程中的其他线程可以通过调用pthread_join函数访问到这个指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_join(pthread_t thread, void **rval_ptr);</span><br><span class="line">//成功返回0，失败返回错误编号</span><br></pre></td></tr></table></figure><ul><li>调用线程将一直阻塞，直到指定的线程调用pthread_exit、从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，rval_ptr就包含返回码。如果线程被取消，由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED。  </li><li>通过调用pthread_join自动把线程置于分离状态，这样资源就可以恢复。如果线程已经处于分离状态，pthread_join就会调用失败，返回EINVAL  </li></ul><p>如下程序展示了如何获取已经终止线程的退出码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *thr_fn1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;thread 1 returning\n&quot;);</span><br><span class="line">    return((void *)0);</span><br><span class="line">&#125;</span><br><span class="line">void *thr_fn2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;thread 2 exiting\n&quot;);</span><br><span class="line">    pthread_exit((void *)2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int         err;</span><br><span class="line">    pthread_t   tid1,tid2;</span><br><span class="line">    void        *tret;</span><br><span class="line">    err = pthread_create(&amp;tid1,NULL,thr_fn1,NULL);</span><br><span class="line">    if (err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t create thread 1&quot;);</span><br><span class="line">    err = pthread_create(&amp;tid2,NULL,thr_fn2,NULL);</span><br><span class="line">    if (err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t create thread 2&quot;);</span><br><span class="line">    err = pthread_join(tid1, &amp;tret);</span><br><span class="line">    if(err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t join with thread 1&quot;);</span><br><span class="line">    printf(&quot;thread 1 exit code %ld\n&quot;,(long)tret);</span><br><span class="line">    err = pthread_join(tid2, &amp;tret);</span><br><span class="line">    if (err != 0)</span><br><span class="line">        err_exit(err, &quot;can&apos;t join with thread 2&quot;);</span><br><span class="line">    printf(&quot;thred 2 exit code %ld\n&quot;,(long)tret);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:<br><img src="/img/chapter-11/figure11.3.png" alt="">  </p><p>线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_cancel(pthread_t tid);</span><br><span class="line">//成功返回0，失败返回错误编号</span><br></pre></td></tr></table></figure><p>pthread_cancel并不等待线程终止，它仅仅提出请求  </p><p>线程可以安排它退出时需要调用的函数(线程清理处理程序)。一个线程可以建立多个清理处理程序。处理程序记录在栈中，他们的执行顺序与他们注册时相反。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_cleanup_push(void (*rtn)(void *), void *arg);</span><br><span class="line">void pthread_cleanup_pop(int execute);</span><br></pre></td></tr></table></figure><p>当线程执行以下动作时，清理函数rtn是由pthread_cleanup_push函数调度的，调用时只有一个参数arg:  </p><ul><li>调用pthread_exit时</li><li>响应取消请求时</li><li>用非零execute参数调用pthread_cleanup_pop时  </li></ul><p>如果execute参数设置为0，清理函数将不被调用。  </p><p>如下程序是使用线程清理处理程序的例子  </p><pre><code>#include &quot;apue.h&quot;#include &lt;pthread.h&gt;void cleanup(void *arg){    printf(&quot;cleanup: %s\n&quot;,(char *)arg);}void *thr_fn1(void *arg){    printf(&quot;thread 1 start\n&quot;);    pthread_cleanup_push(cleanup, &quot;thread 1 first handler&quot;);    pthread_cleanup_push(cleanup, &quot;thread 1 second handler&quot;);    printf(&quot;thread 1 push complete\n&quot;);    if (arg)        return ((void *)1);    pthread_cleanup_pop(0);    pthread_cleanup_pop(0);    return ((void *)1);}void *thr_fn2(void *arg){    printf(&quot;thread 2 start\n&quot;);    pthread_cleanup_push(cleanup, &quot;thread 2 first handler&quot;);    pthread_cleanup_push(cleanup, &quot;thread 2 second handler&quot;);    printf(&quot;thread 2 push complete\n&quot;);    if (arg)        return ((void *)2);    pthread_cleanup_pop(0);    pthread_cleanup_pop(0);    return ((void *)2);}int main(int argc, const char *args[]){    int             err;    pthread_t       tid1,tid2;    void            *tret;    err = pthread_create(&amp;tid1, NULL, thr_fn1, (void*)1);    if (err !=0 )        err_exit(err, &quot;can&apos;t create thread 1&quot;);    err = pthread_create(&amp;tid2, NULL, thr_fn2, (void*)1);    if (err !=0 )        err_exit(err, &quot;can&apos;t create thread 2&quot;);    err = pthread_join(tid1, &amp;tret);    if (err !=0 )        err_exit(err, &quot;can&apos;t join with thread 1&quot;);    printf(&quot;thread 1 exit code %ld\n&quot;, (long)tret);    err = pthread_join(tid2, &amp;tret);    if (err !=0 )        err_exit(err, &quot;can&apos;t join with thread 2&quot;);    printf(&quot;thread 2 exit code %ld\n&quot;, (long)tret);    exit(0);}</code></pre><p>运行结果如下<br><img src="/img/chapter-11/figure11.5.png" alt="">  </p><p>mac 下会产生core文件。这是因为在mac平台上，pthread_cleanup_push是用宏实现的，而宏把某些上下文存放到栈上。当线程1在调用pthread_cleanup_push和调用pthread_cleanup_pop之间返回时，栈已被改写，而这个平台在调用清理处理程序时就用了这个被改写的上下文。在Single UNIX Specification中，函数如果在调用pthread_cleanup_push和pthread_cleanup_pop之间返回，会产生未定义行为。唯一的可移植方法是调用pthread_exit.  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;线程的一些基础知识，包括线程的创建、线程终止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程的概念&quot;&gt;&lt;a href=&quot;#线程的概念&quot; class=&quot;headerlink&quot; title=&quot;线程的概念&quot;&gt;&lt;/a&gt;线程的概念&lt;/h2&gt;&lt;p&gt;典型的UNIX进程可以看成只有一个控制线程；一个进程在某一时刻只能做一件事情。有了多个控制线程后，在程序设计时就可以把进程设计成在某一时刻做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化处理异步事件的代码&lt;/li&gt;
&lt;li&gt;分解复杂的问题提高整个程序的吞吐量&lt;/li&gt;
&lt;li&gt;使用多线程改善响应时间  &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="https://joewt.com/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="UNIX" scheme="https://joewt.com/tags/UNIX/"/>
    
      <category term="C" scheme="https://joewt.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何真正消化一本书？</title>
    <link href="https://joewt.com/2018/05/06/ReadingBooks/"/>
    <id>https://joewt.com/2018/05/06/ReadingBooks/</id>
    <published>2018-05-06T04:02:31.000Z</published>
    <updated>2018-05-06T04:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是李笑来正在预售的《七年就是一辈子》中的内容，略经 36 氪编辑。作者李笑来的微信公众号为 “学习学习再学习（xiaolai-xuexi）”。</p></blockquote><p>书大抵上分为两种：虚构类（Fiction），非虚构类（Non-Fiction）。读非虚构类的书籍，是为了获取新知识，并应用到生活中，让自己获得进步；就我个人而言，我更喜欢看非虚构类的书籍，从中获得的愉悦，感觉更大，因为那种愉悦通常有更为坚实的支撑 —— 进步。而虚构类的书籍，在大学毕业之后已经很少读了，可能是因为我自己在那里很难体会到太多的乐趣，更可能的另外一个原因是我已经彻底把获取那种愉悦的途径转移到了影视作品上。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="(一)"></a>(一)</h2><p>我读书很快，也因此读得很多，但我从来不强调自己的阅读速度 —— 甚至，我坚持认为“阅读速度” 是个伪概念，在我眼里，只有 “理解速度”，理解速度快，才能有效提高阅读量。</p><p>曾经有一段时间，我阅读英文书籍的时候，干脆是在电脑上用键盘敲，边敲边读…… 因为那个时候我发现自己的理解速度甚至跟不上手指头敲键盘的速度。别说遇到生词需要去查了，甚至常常出现的情况是，手指已经将一句话敲完了，却发现自己的脑子竟然不能理解这句话的确切意思……</p><p>没多久，理解速度开始提高，我也没啥兴趣拿着一本书 “一目十行” 地读。遇到好书，我会抽时间朗读完，一本二十万字左右的书朗读完，也不过十几个小时，中间断断续续，也能一个星期内搞定。更多的时候，时间花在那些需要停下来认真思考的部分，需要停下来心平气和地开开脑洞的部分，需要反复搜索寻找更多资料与关联的部分……反正，眼球快速移动本身，没有任何意义。</p><blockquote><p>阅读，是为了理解，而理解这事儿，慢，即是快；快，便是无。</p></blockquote><h2 id="二"><a href="#二" class="headerlink" title="(二)"></a>(二)</h2><p><strong><strong> 大多数情况下，我的阅读并没有功利性。完整性阅读，是没办法有功利性的，因为其实完全没办法知道所读、所学的东西究竟什么时候才能真正发挥它的核能量。</strong></strong> 还有另外一层原因是，还没读完（输入），还没消化完（处理），当然也完全没有开始行动（实践），所以，别说发挥核能量了，连发挥一点能量的可能性都很少。</p><p>另外一种阅读，我称之为检索性阅读。这种阅读本身就是功利性的，比如为了支持某个论点去搜索更为精彩、更为经典的事例；又比如为了思考得更为全面，去翻翻不同属性的人群是如何看待某个问题的；再比如，为了以上同样的目的去检索自己已读过的书库……</p><p>我总觉得阅读是构成自己生命的最重要组成部分之一，所以当然很舍不得降低它的质量。在信息泛滥的时代里（注意，不是知识泛滥），有个小技巧特别管用：<strong>标题党的文章直接不看了——说实话，即便错过什么了，也没什么可惜。</strong>这个小技巧真的不知道帮我节约了多少时间，提高了多少生活质量。</p><p>我从来都懒得接受 “碎片化 xx” 之类的概念，比如，碎片化阅读，碎片化思考，碎片化时间什么的，谁爱碎谁自己碎去，我才不想要一个碎片化的生活呢。</p><p>信息这东西，必须系统才有价值。碎片化的信息也许有用，但就算完全忽略，也不至于致命。舍了就舍了，没啥。这种勇气其实不少人都有，巴菲特就是其中之一。害怕错过什么，是一种情绪，来自于空虚的情绪：因为什么都没有，所以就渴望有一点什么，所以就特别害怕错过任何机会。充实的人，是不怕错过什么的，因为已经充实，错过点什么，真的无所谓，机会有的是，错过一大把又如何，反正因为充实而能够相信自己确实有实力终归抓到至少一个适合自己的机会。</p><p>所以，一定要读书，而不是把本来只不过是获得知识的辅助手段而已的杂志、文摘、新闻等等当做唯一主要手段。买好书，读好书，读懂好书，然后用知识改变自己的生活。</p><h2 id="三"><a href="#三" class="headerlink" title="(三)"></a>(三)</h2><p><strong>别人是不可能帮你吃饭的。同样的道理，别人其实是完全没办法帮你读书的。</strong>虽然我们在学校的时候，总是习惯了由老师带着、逼着读完整本书。</p><p>我一直觉得现在的学校其实是一种特别诡异的存在：一个学期好几个月，好几个老师就带着学生们完整地读完那么几本书，然后有些老师其实还讲不明白，大部分学生还学不明白…… 于是，生命就那么被浪费了。</p><p>从另外一个角度望过去，这几乎是在刻意把学生们变傻、变笨。这是在潜移默化地告诉学生们，“这东西好难的！难到什么地步呢？难到一届又一届的学生，都要花很长时间学，然后大部分还学不会、学不好呢！”</p><p>最要命的还不是拉长原本可以很短的理解时间，而是让学生们学啊学啊学啊学，就不让学生们用！这是什么道理？你看多少人，小学六年，初中三年，高中三年，大学本科四年，加起来都十六年了，学了十六年英语，然后竟然从来没用过……</p><p>说来说去，总结起来就是：别被他们骗了，你本来没那么傻……</p><h2 id="四"><a href="#四" class="headerlink" title="(四)"></a>(四)</h2><p><strong>拿来一本书，就好像要打一场仗，打仗之前最好先考察一下地形吧？</strong>同样的道理，拿来一本书，不应该是抓起来就从第一个字开始读起，一直读到最后……应该先看看目录，再看看附录，仔细读读前言，也不妨在网上先扫扫书评……要先大致对这本书有个了解，然后再开始行动比较好。</p><p>不同的作者有不同的组织方式，但大体上都是差不多的。总是要分章节。每一章其实都是在着重讲解一个概念，它的应用，它的方法论。而陆续的章节，通常是必须理解上一个概念之后才能进一步理解的概念，及其应用与方法论。所以，一头扎入内容之前，最好把这些概念大致过一遍，不理解没关系，哪怕先记住那些概念的名字和先后关系都很有帮助。</p><p><strong>在读的过程中，不断整理这些概念与方法论之间的关系，其实是 “消化” 的必要过程。</strong>有些人从小就学会了并且早就习惯这么做，而大多数人一辈子不会这么干 —— 这就是为什么最终绝大多数人只具备读半本杂志，看个豆腐块文章的能力，而不大可能真正独立消化一整本书的根本原因。</p><h2 id="五"><a href="#五" class="headerlink" title="(五)"></a>(五)</h2><p><strong>在阅读的过程中，要不断向后总结，向前预期 </strong>—— 这是最基本的理解技巧。在阅读的过程中，要不断总结刚才输入的东西都有什么，它们之间是什么样的关系；与此同时，还要不断预期下一步的内容是什么……这是一个不断循环的输入处理的过程。很多人懂得向后总结，却不懂得也应该同时不断向前预期，于是他们只有输入与处理这两个部分。当然绝大多数人除了输入之外什么都没有，连处理都没有。最终只有少数人的阅读理解过程是不断循环地 “输入、处理、输出” 的过程，尽管这里的 “输出” 某种意义上不过是 “伪输出”……</p><p>向前预期，常常相当于为 “跳读、略读” 提供一个安全机制。读着读着，发现作者提出了一个自己已经深入了解过的论点，再往下扫一眼，发现论据也是自己之前了解的，那这一部分就可以安全地跳过了。又由于一直保持着一个预期，再往下读的时候，发现 “嗯？怎么回事儿？跟我想的不一样呢？” 那就要折回去认真找原因……反之，要是一样，说明自己的跨越是正确的么。</p><p>所以说，在良好的阅读习惯下，理解速度会不断积累，最终不断加快 —— 因为所有的知识都有共同点：它们不一定能用在哪里，它们早晚必然融会贯通。所以，理解过的东西越多，理解新的东西就越快。说穿了，理解能力差，无非就是见识少，仅此而已。</p><h2 id="六"><a href="#六" class="headerlink" title="(六)"></a>(六)</h2><p>一旦遇到需要分享 “如何读书” 的场合，我总是会提起这句话：</p><blockquote><p>我有一个奇怪的本领：就是，把一本书拿过来，我即便读不懂，我也能读得完。</p></blockquote><p>这句话总是引来哄堂大笑，可实际上，首先我是认真的；其次，却也更为重要的是，觉得这事儿荒谬恰恰是大多数人其实不懂如何读书的表现。</p><p>读不懂怎么办？没关系，只有一个办法靠谱：硬着头皮读完，然后反复读很多遍。这是一个特别重要的本领，很多人不知道。其实，重要的知识，从来都是通过反复学习才能获得的。一下就能学会得东西，通常上价值不大。</p><p>有一点弄不明白就放弃，那能学会什么呢？</p><p>还有一个常见现象：有些书籍就是难懂，因为它的内容结构并不完全线性，也就是说，第二章的内容需要第五章的知识才能理解彻底…… 所以，最终，只有我们这种不怕暂时读不懂，能硬着头皮读完，然后再反复来过的人才能消化这种书籍。</p><h2 id="七"><a href="#七" class="headerlink" title="(七)"></a>(七)</h2><p>一定要用起来。很多有用的东西，之所以最终没用，是因为压根没用过。知识无用，这是二货思维，所有的知识都是有用的，哪怕巫术都有用，更何况知识。可是不用的东西，没用起来的东西，还不如虚无 —— 因为读过、学过，时间与精力已经耗费了，这可是最宝贵的不可逆不可回收不可再生资源！</p><p>2000 年，我突击考了 TOEFL、GRE，就跑去新东方应聘出国留学培训教师职位；2005 年开始前后写了两年多，终于觉得自己能用文字讲明白道理了，就写了《把时间当作朋友》；2012 年我学了 Ruby On Rails，就和李路和沙欣哲一起搞出来了一个 Knewone；2014 年我学会了使用 Sketch，就用它设计了若干个 APP 的原型，顺带逼着几个程序员也变成了设计师；2015 年上半年，我读了许多本关于社区建设的书（其中包括那本著名的 The Art of Community: Building the New Age of Participation， <a href="http://www.artofcommunityonline.org），你看我正在打造社群……" target="_blank" rel="noopener">http://www.artofcommunityonline.org），你看我正在打造社群……</a> 不仅如此，我还帮很多人打造社群。</p><p>不用，学它干嘛？这与我读书的原则也是相通的：不用认真读的书，读它干嘛？这与我对生活的态度也是一样的，既然活着，就要活好，活得精彩。</p><h2 id="八"><a href="#八" class="headerlink" title="(八)"></a>(八)</h2><p>暂时用不起来怎么办？教！我总是重复这句话：</p><blockquote><p>教是最好的学习方法。</p></blockquote><p>把你学到的，总结好的，琢磨清楚的那些知识（不是胡说八道的那些东西）传递出去，分享给你身边的人。“教”，不一定非要像老师一样在课堂上给一帮学生讲（还不允许他们打断）……“教” 可以有很多种形式，比如，“分享”，就是 “教” 的一种形式。在饭桌上都可以进行：</p><p>“我最近读到一个新的概念，特震撼：三度影响力…… 原来肥胖症居然在某种程度上是可以传染的！”</p><p>如果你的朋友对此感兴趣，那你就要再仔细一点说明其机理，其作用，甚至用更多的来自自己身边的例子去讲解。在一来二去的交谈中，你会发现自己也还有很多没弄明白的地方，还有很多地方需要更准确的陈述，需要更精彩、更令人信服、惊叹的论据…… 怎么办？回来改进呗，下次在另外一个饭桌上再演练一次……</p><p>所以，我也总是分享这个道理：</p><blockquote><p>分享，不仅需要能力支撑，也是培养能力的最重要手段。知识分享，没有成本，只有收益 —— 双方都有的收益。</p></blockquote><p>分享的技巧很简单：</p><blockquote><ol><li>真诚，只分享自己确实觉得好的东西；</li><li>也是真诚，绝对不能居高临下地装蛋；</li><li>还是真诚，对方完全有可能不理解你。</li></ol></blockquote><h2 id="九"><a href="#九" class="headerlink" title="(九)"></a>(九)</h2><p>还没完！别忘了问自己这个最重要的问题：</p><p>这个概念、这个方法论、这个道理、这个知识，还可以用在什么地方？</p><p>这是让你真正培养融会贯通能力的方式。所谓的聪明就是这么来的：脑子里有足够多清晰正确的概念与方法论，然后它们之间还有正确应有的关联…… 所以聪明的操作系统总是有更多的想法、更多的方案、更多的可能性。</p><p>万一想到了可以 “出其不意” 地使用的场景，那就赚大了，因为同样的东西到了你的手里却发挥了不一样的作用，你当然与众不同，也只能与众不同。</p><h2 id="十"><a href="#十" class="headerlink" title="(十)"></a>(十)</h2><p><strong>与喜欢学习的人泡在一起</strong> —— 这一点真的特别重要(当然跟喜欢的人在一起共同学习提高了啦(手动艾特某人))。潜移默化的力量是非常大的，与喜欢学习的人在一起，正面的影响力很大；与不喜欢学习的人在一起，负面的影响力不仅很大也很可怕。</p><p>寻找那些终生学习的人，把他们当作朋友，把他们当作榜样。</p><p>网络时代有个好处，这种人虽然身边并不多见，但网络上却很常见。为什么呢？网络消灭了地域的限制，甚至消灭了语言的限制。我就有个很长期的榜样：Bruce Eckel。我根本不认识他，也没有过任何传统意义上的交往，连 email 往来都没有。他是 Thinking In C++ 的作者。十多年前，他在网上发布 Thinking In C++ 第一版的写作计划，然后以极快的速度更新完成…… 毫无疑问，见识到有人这样，就成了后来我写书的时候 “雷厉风行” 的根本原因和动力。再反过来说，人家写书都可以这样，我们读书怎么可以拖拖拉拉呢？</p><blockquote><p>转载: <a href="https://www.ycjcl.cc/" target="_blank" rel="noopener">信鑫-King’s Blog</a>&gt;&gt;<a href="https://www.ycjcl.cc/2016/01/22/ru-he-zhen-zheng-xiao-hua-ben-shu-zhuan-zi-36kr/" target="_blank" rel="noopener">如何真正消化一本书？(转自36Kr)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是李笑来正在预售的《七年就是一辈子》中的内容，略经 36 氪编辑。作者李笑来的微信公众号为 “学习学习再学习（xiaolai-xuexi）”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书大抵上分为两种：虚构类（Fiction），非虚构类（Non-Fiction）。读非虚构类的书籍，是为了获取新知识，并应用到生活中，让自己获得进步；就我个人而言，我更喜欢看非虚构类的书籍，从中获得的愉悦，感觉更大，因为那种愉悦通常有更为坚实的支撑 —— 进步。而虚构类的书籍，在大学毕业之后已经很少读了，可能是因为我自己在那里很难体会到太多的乐趣，更可能的另外一个原因是我已经彻底把获取那种愉悦的途径转移到了影视作品上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="book" scheme="https://joewt.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>swoole安装</title>
    <link href="https://joewt.com/2018/04/13/swoole-install/"/>
    <id>https://joewt.com/2018/04/13/swoole-install/</id>
    <published>2018-04-13T02:08:51.000Z</published>
    <updated>2018-10-19T07:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>各个环境下有所区别，我使用的是mac系统，首先说的是mac系统下的安装  </p><p>mac系统 自带的有php，这里并不用自带的。使用mamp,php的目录在如下的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/mamp/bin/php</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="noopener">swoole</a></p><p>下载最新的版本即可</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完解压后，目录下会有一个make.sh 这是个简易的安装脚本<br>需要改下phpize，改成mamp下的phpize，在<code>/Applicatons/mamp/bin/php/php7.xxx/bin/</code>目录下<br>./configure 有一些编译参数，根据自己的情况而定<br><a href="https://wiki.swoole.com/wiki/page/437.html" target="_blank" rel="noopener">这里查看</a></p><p>之后执行脚本即可</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装成功后，修改php.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=swoole.so</span><br></pre></td></tr></table></figure></p><p>之后通过php -m 查看扩展是否安装成功,使用mamp下的php命令</p><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><p>一个官方的案例–创建TCP服务器<br>server.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建Server对象，监听 127.0.0.1:9501端口</span><br><span class="line">$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501); </span><br><span class="line"></span><br><span class="line">//监听连接进入事件</span><br><span class="line">$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123;  </span><br><span class="line">    echo &quot;Client: Connect.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听数据接收事件</span><br><span class="line">$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123;</span><br><span class="line">    $serv-&gt;send($fd, &quot;Server: &quot;.$data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听连接关闭事件</span><br><span class="line">$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123;</span><br><span class="line">    echo &quot;Client: Close.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//启动服务器</span><br><span class="line">$serv-&gt;start();</span><br></pre></td></tr></table></figure></p><p><img src="http://img.hnitoj.cn/swoole-install-finish.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;各个环境下有所区别，我使用的是mac系统，首先说的是mac系统下的安装  &lt;/p&gt;
&lt;p&gt;mac系统 自带的有php，这里并不用自带的。使用mamp,php的目录在如下的目录下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/Applications/mamp/bin/php&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swoole" scheme="https://joewt.com/categories/Swoole/"/>
    
    
      <category term="PHP" scheme="https://joewt.com/tags/PHP/"/>
    
      <category term="swoole" scheme="https://joewt.com/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局</title>
    <link href="https://joewt.com/2018/03/07/css-layout/"/>
    <id>https://joewt.com/2018/03/07/css-layout/</id>
    <published>2018-03-07T14:06:10.000Z</published>
    <updated>2018-10-19T07:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h3><ul><li>CSS知识体系的重中之重</li><li>早期以table为主（简单）  </li><li>后来以技巧性布局为主（难）</li><li>现在有flexbox/grid（偏简单）</li><li>响应式布局是必备知识</li></ul><h3 id="常用布局方法"><a href="#常用布局方法" class="headerlink" title="常用布局方法"></a>常用布局方法</h3><ul><li>table 表格布局</li><li>float 浮动+margin</li><li>inline-block 布局</li><li>flexbox 布局</li></ul><a id="more"></a><h3 id="布局属性"><a href="#布局属性" class="headerlink" title="布局属性"></a>布局属性</h3><p>盒子模型<br><img src="http://img.hnitoj.cn/hz.png" alt=""> </p><h4 id="设置布局的两个基本属性-display-position"><a href="#设置布局的两个基本属性-display-position" class="headerlink" title="设置布局的两个基本属性 display/position"></a>设置布局的两个基本属性 display/position</h4><ul><li>确定元素的显示类型<ul><li>block(块级元素)/inline(内联元素或者叫行内元素)/inline-block(行内块级元素)</li></ul></li><li>确定元素位置<ul><li>static/relative/absolute/fixed</li></ul></li></ul><p>position:   </p><ul><li>relative: 根据元素原来的位置进行偏移</li><li>absolute: 脱离文档流，不会对其他元素造成影响 相对于最近的 absolute或relative进行偏移</li><li>fixed: 脱离文档流，是相对于屏幕 可视区域 固定的</li></ul><p>z-index: 定义层级 设置谁显示在最上方，越大就越在最上，对设置了relative,absolute,fixed的有用</p><h3 id="flexbox布局"><a href="#flexbox布局" class="headerlink" title="flexbox布局"></a>flexbox布局</h3><ul><li>弹性盒子</li><li>盒子本来就是并列的</li><li>指定宽度即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.flex &#123;</span><br><span class="line">  flex: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果想设置固定的宽度</span><br><span class="line">.xxx &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  flex: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;flex&quot;&gt;</span><br><span class="line">      xxxx</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h3><ul><li>元素浮动</li><li>脱离文档流</li><li>但不会脱离文本流</li></ul><h5 id="float"><a href="#float" class="headerlink" title="float"></a>float</h5><ul><li><p>对自身的影响</p><ul><li>形成“块” （BFC）</li><li>位置尽量靠上</li><li>位置尽量靠左(右) 在靠上的前提下</li></ul></li><li><p>对兄弟的影响</p><ul><li>上面贴非float元素</li><li>旁边贴float元素</li><li>不影响其他块级元素位置</li><li>影响其他块级元素内部文本</li></ul></li><li><p>对父级元素的影响</p><ul><li>从布局上“消失”</li><li>高度塌陷</li></ul></li><li><p>清除浮动</p><ul><li>overflow: hidden(auto)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container2::after&#123;</span><br><span class="line">           content: &apos;ffff&apos;;</span><br><span class="line">           clear: both;</span><br><span class="line">           display: block;</span><br><span class="line">           height: 0;</span><br><span class="line">           visibility: hidden;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2栏布局"><a href="#2栏布局" class="headerlink" title="2栏布局"></a>2栏布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: 800px;</span><br><span class="line">            height: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: blue;</span><br><span class="line">            float: left;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: 200px;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">            left</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">            right</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="3栏布局"><a href="#3栏布局" class="headerlink" title="3栏布局"></a>3栏布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .container&#123;</span><br><span class="line">        width: 800px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        background: blue;</span><br><span class="line">        float: left;</span><br><span class="line">        height: 100%;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        background: red;</span><br><span class="line">        float: right;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .middle&#123;</span><br><span class="line">        margin-left: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">        left</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">            right</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        middle</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h2&gt;&lt;h3 id=&quot;CSS-布局&quot;&gt;&lt;a href=&quot;#CSS-布局&quot; class=&quot;headerlink&quot; title=&quot;CSS 布局&quot;&gt;&lt;/a&gt;CSS 布局&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CSS知识体系的重中之重&lt;/li&gt;
&lt;li&gt;早期以table为主（简单）  &lt;/li&gt;
&lt;li&gt;后来以技巧性布局为主（难）&lt;/li&gt;
&lt;li&gt;现在有flexbox/grid（偏简单）&lt;/li&gt;
&lt;li&gt;响应式布局是必备知识&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用布局方法&quot;&gt;&lt;a href=&quot;#常用布局方法&quot; class=&quot;headerlink&quot; title=&quot;常用布局方法&quot;&gt;&lt;/a&gt;常用布局方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;table 表格布局&lt;/li&gt;
&lt;li&gt;float 浮动+margin&lt;/li&gt;
&lt;li&gt;inline-block 布局&lt;/li&gt;
&lt;li&gt;flexbox 布局&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS学习" scheme="https://joewt.com/categories/CSS%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="https://joewt.com/tags/CSS/"/>
    
  </entry>
  
</feed>
